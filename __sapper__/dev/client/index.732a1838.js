import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, a7 as create_slot, ad as classMap, $ as assign, W as compute_rest_props, v as validate_slots, ae as forwardEventsBuilder, Y as get_current_component, X as getContext, a0 as exclude_internal_props, af as useActions, p as element, x as claim_element, y as children, u as detach_dev, a9 as set_attributes, D as add_location, F as insert_dev, aa as action_destroyer, a8 as update_slot, a2 as get_spread_update, ab as is_function, J as transition_in, K as transition_out, ac as run_all, a6 as binding_callbacks, L as List$1, I as Item, aS as Separator, T as Text, q as create_component, o as space, t as text, A as claim_component, w as claim_space, z as claim_text, E as attr_dev, H as mount_component, G as append_dev, aw as set_data_dev, M as destroy_component, ak as bind, bn as Meta, P as PrimaryText, l as SecondaryText, al as add_flush_callback, ag as validate_each_argument, a1 as empty, a4 as group_outros, a5 as check_outros, aj as destroy_each, O as noop, bo as Group, bm as Subheader, r as query_selector_all } from './client.ec94238b.js';
import { D as Demo } from './Demo.9c515360.js';
import { G as Graphic } from './Graphic.805b8c09.js';
import { R as Radio } from './Radio.52add3e3.js';
import { C as Checkbox } from './Checkbox.52871e38.js';

/* packages/list/Label.svelte generated by Svelte v3.37.0 */

const file$9 = "packages/list/Label.svelte";

function create_fragment$9(ctx) {
	let label;
	let label_class_value;
	let label_for_value;
	let useActions_action;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[8].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);

	let label_levels = [
		{
			class: label_class_value = classMap({
				[/*className*/ ctx[1]]: true,
				"mdc-deprecated-list-item__text": true
			})
		},
		{
			for: label_for_value = /*inputProps*/ ctx[4] ? /*inputProps*/ ctx[4].id : null
		},
		/*$$restProps*/ ctx[5]
	];

	let label_data = {};

	for (let i = 0; i < label_levels.length; i += 1) {
		label_data = assign(label_data, label_levels[i]);
	}

	const block = {
		c: function create() {
			label = element("label");
			if (default_slot) default_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			label = claim_element(nodes, "LABEL", { class: true, for: true });
			var label_nodes = children(label);
			if (default_slot) default_slot.l(label_nodes);
			label_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_attributes(label, label_data);
			add_location(label, file$9, 0, 0, 0);
		},
		m: function mount(target, anchor) {
			insert_dev(target, label, anchor);

			if (default_slot) {
				default_slot.m(label, null);
			}

			/*label_binding*/ ctx[9](label);
			current = true;

			if (!mounted) {
				dispose = [
					action_destroyer(useActions_action = useActions.call(null, label, /*use*/ ctx[0])),
					action_destroyer(/*forwardEvents*/ ctx[3].call(null, label))
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 128) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[7], dirty, null, null);
				}
			}

			set_attributes(label, label_data = get_spread_update(label_levels, [
				(!current || dirty & /*className*/ 2 && label_class_value !== (label_class_value = classMap({
					[/*className*/ ctx[1]]: true,
					"mdc-deprecated-list-item__text": true
				}))) && { class: label_class_value },
				{ for: label_for_value },
				dirty & /*$$restProps*/ 32 && /*$$restProps*/ ctx[5]
			]));

			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(label);
			if (default_slot) default_slot.d(detaching);
			/*label_binding*/ ctx[9](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$9.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$9($$self, $$props, $$invalidate) {
	const omit_props_names = ["use","class","getElement"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Label", slots, ['default']);
	const forwardEvents = forwardEventsBuilder(get_current_component());
	let { use = [] } = $$props;
	let { class: className = "" } = $$props;
	let element;
	let inputProps = getContext("SMUI:generic:input:props") || {};

	function getElement() {
		return element;
	}

	function label_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			element = $$value;
			$$invalidate(2, element);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("use" in $$new_props) $$invalidate(0, use = $$new_props.use);
		if ("class" in $$new_props) $$invalidate(1, className = $$new_props.class);
		if ("$$scope" in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		getContext,
		get_current_component,
		forwardEventsBuilder,
		classMap,
		useActions,
		forwardEvents,
		use,
		className,
		element,
		inputProps,
		getElement
	});

	$$self.$inject_state = $$new_props => {
		if ("use" in $$props) $$invalidate(0, use = $$new_props.use);
		if ("className" in $$props) $$invalidate(1, className = $$new_props.className);
		if ("element" in $$props) $$invalidate(2, element = $$new_props.element);
		if ("inputProps" in $$props) $$invalidate(4, inputProps = $$new_props.inputProps);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		use,
		className,
		element,
		forwardEvents,
		inputProps,
		$$restProps,
		getElement,
		$$scope,
		slots,
		label_binding
	];
}

class Label extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$9, create_fragment$9, safe_not_equal, { use: 0, class: 1, getElement: 6 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Label",
			options,
			id: create_fragment$9.name
		});
	}

	get use() {
		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set use(value) {
		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get getElement() {
		return this.$$.ctx[6];
	}

	set getElement(value) {
		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/demo/list/_Simple.svelte generated by Svelte v3.37.0 */
const file$8 = "src/routes/demo/list/_Simple.svelte";

// (3:51) <Text>
function create_default_slot_8$6(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Cut");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Cut");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_8$6.name,
		type: "slot",
		source: "(3:51) <Text>",
		ctx
	});

	return block;
}

// (3:4) <Item on:SMUI:action={() => (clicked = 'Cut')}>
function create_default_slot_7$6(ctx) {
	let text_1;
	let current;

	text_1 = new Text({
			props: {
				$$slots: { default: [create_default_slot_8$6] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(text_1.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(text_1.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(text_1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const text_1_changes = {};

			if (dirty & /*$$scope*/ 32) {
				text_1_changes.$$scope = { dirty, ctx };
			}

			text_1.$set(text_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(text_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(text_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(text_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_7$6.name,
		type: "slot",
		source: "(3:4) <Item on:SMUI:action={() => (clicked = 'Cut')}>",
		ctx
	});

	return block;
}

// (4:52) <Text>
function create_default_slot_6$7(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Copy");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Copy");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_6$7.name,
		type: "slot",
		source: "(4:52) <Text>",
		ctx
	});

	return block;
}

// (4:4) <Item on:SMUI:action={() => (clicked = 'Copy')}>
function create_default_slot_5$8(ctx) {
	let text_1;
	let current;

	text_1 = new Text({
			props: {
				$$slots: { default: [create_default_slot_6$7] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(text_1.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(text_1.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(text_1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const text_1_changes = {};

			if (dirty & /*$$scope*/ 32) {
				text_1_changes.$$scope = { dirty, ctx };
			}

			text_1.$set(text_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(text_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(text_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(text_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_5$8.name,
		type: "slot",
		source: "(4:4) <Item on:SMUI:action={() => (clicked = 'Copy')}>",
		ctx
	});

	return block;
}

// (5:53) <Text>
function create_default_slot_4$8(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Paste");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Paste");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_4$8.name,
		type: "slot",
		source: "(5:53) <Text>",
		ctx
	});

	return block;
}

// (5:4) <Item on:SMUI:action={() => (clicked = 'Paste')}>
function create_default_slot_3$8(ctx) {
	let text_1;
	let current;

	text_1 = new Text({
			props: {
				$$slots: { default: [create_default_slot_4$8] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(text_1.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(text_1.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(text_1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const text_1_changes = {};

			if (dirty & /*$$scope*/ 32) {
				text_1_changes.$$scope = { dirty, ctx };
			}

			text_1.$set(text_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(text_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(text_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(text_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3$8.name,
		type: "slot",
		source: "(5:4) <Item on:SMUI:action={() => (clicked = 'Paste')}>",
		ctx
	});

	return block;
}

// (7:54) <Text>
function create_default_slot_2$8(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Delete");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Delete");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2$8.name,
		type: "slot",
		source: "(7:54) <Text>",
		ctx
	});

	return block;
}

// (7:4) <Item on:SMUI:action={() => (clicked = 'Delete')}>
function create_default_slot_1$8(ctx) {
	let text_1;
	let current;

	text_1 = new Text({
			props: {
				$$slots: { default: [create_default_slot_2$8] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(text_1.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(text_1.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(text_1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const text_1_changes = {};

			if (dirty & /*$$scope*/ 32) {
				text_1_changes.$$scope = { dirty, ctx };
			}

			text_1.$set(text_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(text_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(text_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(text_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$8.name,
		type: "slot",
		source: "(7:4) <Item on:SMUI:action={() => (clicked = 'Delete')}>",
		ctx
	});

	return block;
}

// (2:2) <List class="demo-list">
function create_default_slot$8(ctx) {
	let item0;
	let t0;
	let item1;
	let t1;
	let item2;
	let t2;
	let separator;
	let t3;
	let item3;
	let current;

	item0 = new Item({
			props: {
				$$slots: { default: [create_default_slot_7$6] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	item0.$on("SMUI:action", /*SMUI_action_handler*/ ctx[1]);

	item1 = new Item({
			props: {
				$$slots: { default: [create_default_slot_5$8] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	item1.$on("SMUI:action", /*SMUI_action_handler_1*/ ctx[2]);

	item2 = new Item({
			props: {
				$$slots: { default: [create_default_slot_3$8] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	item2.$on("SMUI:action", /*SMUI_action_handler_2*/ ctx[3]);
	separator = new Separator({ $$inline: true });

	item3 = new Item({
			props: {
				$$slots: { default: [create_default_slot_1$8] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	item3.$on("SMUI:action", /*SMUI_action_handler_3*/ ctx[4]);

	const block = {
		c: function create() {
			create_component(item0.$$.fragment);
			t0 = space();
			create_component(item1.$$.fragment);
			t1 = space();
			create_component(item2.$$.fragment);
			t2 = space();
			create_component(separator.$$.fragment);
			t3 = space();
			create_component(item3.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(item0.$$.fragment, nodes);
			t0 = claim_space(nodes);
			claim_component(item1.$$.fragment, nodes);
			t1 = claim_space(nodes);
			claim_component(item2.$$.fragment, nodes);
			t2 = claim_space(nodes);
			claim_component(separator.$$.fragment, nodes);
			t3 = claim_space(nodes);
			claim_component(item3.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(item0, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(item1, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(item2, target, anchor);
			insert_dev(target, t2, anchor);
			mount_component(separator, target, anchor);
			insert_dev(target, t3, anchor);
			mount_component(item3, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const item0_changes = {};

			if (dirty & /*$$scope*/ 32) {
				item0_changes.$$scope = { dirty, ctx };
			}

			item0.$set(item0_changes);
			const item1_changes = {};

			if (dirty & /*$$scope*/ 32) {
				item1_changes.$$scope = { dirty, ctx };
			}

			item1.$set(item1_changes);
			const item2_changes = {};

			if (dirty & /*$$scope*/ 32) {
				item2_changes.$$scope = { dirty, ctx };
			}

			item2.$set(item2_changes);
			const item3_changes = {};

			if (dirty & /*$$scope*/ 32) {
				item3_changes.$$scope = { dirty, ctx };
			}

			item3.$set(item3_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(item0.$$.fragment, local);
			transition_in(item1.$$.fragment, local);
			transition_in(item2.$$.fragment, local);
			transition_in(separator.$$.fragment, local);
			transition_in(item3.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(item0.$$.fragment, local);
			transition_out(item1.$$.fragment, local);
			transition_out(item2.$$.fragment, local);
			transition_out(separator.$$.fragment, local);
			transition_out(item3.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(item0, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(item1, detaching);
			if (detaching) detach_dev(t1);
			destroy_component(item2, detaching);
			if (detaching) detach_dev(t2);
			destroy_component(separator, detaching);
			if (detaching) detach_dev(t3);
			destroy_component(item3, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$8.name,
		type: "slot",
		source: "(2:2) <List class=\\\"demo-list\\\">",
		ctx
	});

	return block;
}

function create_fragment$8(ctx) {
	let div;
	let list;
	let t0;
	let pre;
	let t1;
	let t2;
	let current;

	list = new List$1({
			props: {
				class: "demo-list",
				$$slots: { default: [create_default_slot$8] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			div = element("div");
			create_component(list.$$.fragment);
			t0 = space();
			pre = element("pre");
			t1 = text("Clicked: ");
			t2 = text(/*clicked*/ ctx[0]);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			claim_component(list.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			t0 = claim_space(nodes);
			pre = claim_element(nodes, "PRE", { class: true });
			var pre_nodes = children(pre);
			t1 = claim_text(pre_nodes, "Clicked: ");
			t2 = claim_text(pre_nodes, /*clicked*/ ctx[0]);
			pre_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "svelte-16qb95n");
			add_location(div, file$8, 0, 0, 0);
			attr_dev(pre, "class", "status svelte-16qb95n");
			add_location(pre, file$8, 10, 0, 381);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(list, div, null);
			insert_dev(target, t0, anchor);
			insert_dev(target, pre, anchor);
			append_dev(pre, t1);
			append_dev(pre, t2);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const list_changes = {};

			if (dirty & /*$$scope, clicked*/ 33) {
				list_changes.$$scope = { dirty, ctx };
			}

			list.$set(list_changes);
			if (!current || dirty & /*clicked*/ 1) set_data_dev(t2, /*clicked*/ ctx[0]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(list.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(list.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(list);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(pre);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$8.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$8($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Simple", slots, []);
	let clicked = "nothing yet";
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Simple> was created with unknown prop '${key}'`);
	});

	const SMUI_action_handler = () => $$invalidate(0, clicked = "Cut");
	const SMUI_action_handler_1 = () => $$invalidate(0, clicked = "Copy");
	const SMUI_action_handler_2 = () => $$invalidate(0, clicked = "Paste");
	const SMUI_action_handler_3 = () => $$invalidate(0, clicked = "Delete");
	$$self.$capture_state = () => ({ List: List$1, Item, Separator, Text, clicked });

	$$self.$inject_state = $$props => {
		if ("clicked" in $$props) $$invalidate(0, clicked = $$props.clicked);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		clicked,
		SMUI_action_handler,
		SMUI_action_handler_1,
		SMUI_action_handler_2,
		SMUI_action_handler_3
	];
}

class Simple extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$8, create_fragment$8, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Simple",
			options,
			id: create_fragment$8.name
		});
	}
}

/* src/routes/demo/list/_GraphicsDense.svelte generated by Svelte v3.37.0 */
const file$7 = "src/routes/demo/list/_GraphicsDense.svelte";

// (4:6) <Graphic class="material-icons">
function create_default_slot_12$3(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("edit");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "edit");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_12$3.name,
		type: "slot",
		source: "(4:6) <Graphic class=\\\"material-icons\\\">",
		ctx
	});

	return block;
}

// (5:6) <Text>
function create_default_slot_11$3(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Edit");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Edit");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_11$3.name,
		type: "slot",
		source: "(5:6) <Text>",
		ctx
	});

	return block;
}

// (3:4) <Item on:SMUI:action={() => (clicked = 'Edit')}>
function create_default_slot_10$4(ctx) {
	let graphic;
	let t;
	let text_1;
	let current;

	graphic = new Graphic({
			props: {
				class: "material-icons",
				$$slots: { default: [create_default_slot_12$3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	text_1 = new Text({
			props: {
				$$slots: { default: [create_default_slot_11$3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(graphic.$$.fragment);
			t = space();
			create_component(text_1.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(graphic.$$.fragment, nodes);
			t = claim_space(nodes);
			claim_component(text_1.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(graphic, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(text_1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const graphic_changes = {};

			if (dirty & /*$$scope*/ 32) {
				graphic_changes.$$scope = { dirty, ctx };
			}

			graphic.$set(graphic_changes);
			const text_1_changes = {};

			if (dirty & /*$$scope*/ 32) {
				text_1_changes.$$scope = { dirty, ctx };
			}

			text_1.$set(text_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(graphic.$$.fragment, local);
			transition_in(text_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(graphic.$$.fragment, local);
			transition_out(text_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(graphic, detaching);
			if (detaching) detach_dev(t);
			destroy_component(text_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_10$4.name,
		type: "slot",
		source: "(3:4) <Item on:SMUI:action={() => (clicked = 'Edit')}>",
		ctx
	});

	return block;
}

// (8:6) <Graphic class="material-icons">
function create_default_slot_9$4(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("send");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "send");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_9$4.name,
		type: "slot",
		source: "(8:6) <Graphic class=\\\"material-icons\\\">",
		ctx
	});

	return block;
}

// (9:6) <Text>
function create_default_slot_8$5(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Send");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Send");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_8$5.name,
		type: "slot",
		source: "(9:6) <Text>",
		ctx
	});

	return block;
}

// (7:4) <Item on:SMUI:action={() => (clicked = 'Send')}>
function create_default_slot_7$5(ctx) {
	let graphic;
	let t;
	let text_1;
	let current;

	graphic = new Graphic({
			props: {
				class: "material-icons",
				$$slots: { default: [create_default_slot_9$4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	text_1 = new Text({
			props: {
				$$slots: { default: [create_default_slot_8$5] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(graphic.$$.fragment);
			t = space();
			create_component(text_1.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(graphic.$$.fragment, nodes);
			t = claim_space(nodes);
			claim_component(text_1.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(graphic, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(text_1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const graphic_changes = {};

			if (dirty & /*$$scope*/ 32) {
				graphic_changes.$$scope = { dirty, ctx };
			}

			graphic.$set(graphic_changes);
			const text_1_changes = {};

			if (dirty & /*$$scope*/ 32) {
				text_1_changes.$$scope = { dirty, ctx };
			}

			text_1.$set(text_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(graphic.$$.fragment, local);
			transition_in(text_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(graphic.$$.fragment, local);
			transition_out(text_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(graphic, detaching);
			if (detaching) detach_dev(t);
			destroy_component(text_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_7$5.name,
		type: "slot",
		source: "(7:4) <Item on:SMUI:action={() => (clicked = 'Send')}>",
		ctx
	});

	return block;
}

// (12:6) <Graphic class="material-icons">
function create_default_slot_6$6(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("archive");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "archive");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_6$6.name,
		type: "slot",
		source: "(12:6) <Graphic class=\\\"material-icons\\\">",
		ctx
	});

	return block;
}

// (13:6) <Text>
function create_default_slot_5$7(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Archive");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Archive");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_5$7.name,
		type: "slot",
		source: "(13:6) <Text>",
		ctx
	});

	return block;
}

// (11:4) <Item on:SMUI:action={() => (clicked = 'Archive')}>
function create_default_slot_4$7(ctx) {
	let graphic;
	let t;
	let text_1;
	let current;

	graphic = new Graphic({
			props: {
				class: "material-icons",
				$$slots: { default: [create_default_slot_6$6] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	text_1 = new Text({
			props: {
				$$slots: { default: [create_default_slot_5$7] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(graphic.$$.fragment);
			t = space();
			create_component(text_1.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(graphic.$$.fragment, nodes);
			t = claim_space(nodes);
			claim_component(text_1.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(graphic, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(text_1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const graphic_changes = {};

			if (dirty & /*$$scope*/ 32) {
				graphic_changes.$$scope = { dirty, ctx };
			}

			graphic.$set(graphic_changes);
			const text_1_changes = {};

			if (dirty & /*$$scope*/ 32) {
				text_1_changes.$$scope = { dirty, ctx };
			}

			text_1.$set(text_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(graphic.$$.fragment, local);
			transition_in(text_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(graphic.$$.fragment, local);
			transition_out(text_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(graphic, detaching);
			if (detaching) detach_dev(t);
			destroy_component(text_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_4$7.name,
		type: "slot",
		source: "(11:4) <Item on:SMUI:action={() => (clicked = 'Archive')}>",
		ctx
	});

	return block;
}

// (17:6) <Graphic class="material-icons">
function create_default_slot_3$7(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("clear");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "clear");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3$7.name,
		type: "slot",
		source: "(17:6) <Graphic class=\\\"material-icons\\\">",
		ctx
	});

	return block;
}

// (18:6) <Text>
function create_default_slot_2$7(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Delete");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Delete");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2$7.name,
		type: "slot",
		source: "(18:6) <Text>",
		ctx
	});

	return block;
}

// (16:4) <Item on:SMUI:action={() => (clicked = 'Delete')}>
function create_default_slot_1$7(ctx) {
	let graphic;
	let t;
	let text_1;
	let current;

	graphic = new Graphic({
			props: {
				class: "material-icons",
				$$slots: { default: [create_default_slot_3$7] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	text_1 = new Text({
			props: {
				$$slots: { default: [create_default_slot_2$7] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(graphic.$$.fragment);
			t = space();
			create_component(text_1.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(graphic.$$.fragment, nodes);
			t = claim_space(nodes);
			claim_component(text_1.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(graphic, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(text_1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const graphic_changes = {};

			if (dirty & /*$$scope*/ 32) {
				graphic_changes.$$scope = { dirty, ctx };
			}

			graphic.$set(graphic_changes);
			const text_1_changes = {};

			if (dirty & /*$$scope*/ 32) {
				text_1_changes.$$scope = { dirty, ctx };
			}

			text_1.$set(text_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(graphic.$$.fragment, local);
			transition_in(text_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(graphic.$$.fragment, local);
			transition_out(text_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(graphic, detaching);
			if (detaching) detach_dev(t);
			destroy_component(text_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$7.name,
		type: "slot",
		source: "(16:4) <Item on:SMUI:action={() => (clicked = 'Delete')}>",
		ctx
	});

	return block;
}

// (2:2) <List class="demo-list" dense>
function create_default_slot$7(ctx) {
	let item0;
	let t0;
	let item1;
	let t1;
	let item2;
	let t2;
	let separator;
	let t3;
	let item3;
	let current;

	item0 = new Item({
			props: {
				$$slots: { default: [create_default_slot_10$4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	item0.$on("SMUI:action", /*SMUI_action_handler*/ ctx[1]);

	item1 = new Item({
			props: {
				$$slots: { default: [create_default_slot_7$5] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	item1.$on("SMUI:action", /*SMUI_action_handler_1*/ ctx[2]);

	item2 = new Item({
			props: {
				$$slots: { default: [create_default_slot_4$7] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	item2.$on("SMUI:action", /*SMUI_action_handler_2*/ ctx[3]);
	separator = new Separator({ $$inline: true });

	item3 = new Item({
			props: {
				$$slots: { default: [create_default_slot_1$7] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	item3.$on("SMUI:action", /*SMUI_action_handler_3*/ ctx[4]);

	const block = {
		c: function create() {
			create_component(item0.$$.fragment);
			t0 = space();
			create_component(item1.$$.fragment);
			t1 = space();
			create_component(item2.$$.fragment);
			t2 = space();
			create_component(separator.$$.fragment);
			t3 = space();
			create_component(item3.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(item0.$$.fragment, nodes);
			t0 = claim_space(nodes);
			claim_component(item1.$$.fragment, nodes);
			t1 = claim_space(nodes);
			claim_component(item2.$$.fragment, nodes);
			t2 = claim_space(nodes);
			claim_component(separator.$$.fragment, nodes);
			t3 = claim_space(nodes);
			claim_component(item3.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(item0, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(item1, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(item2, target, anchor);
			insert_dev(target, t2, anchor);
			mount_component(separator, target, anchor);
			insert_dev(target, t3, anchor);
			mount_component(item3, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const item0_changes = {};

			if (dirty & /*$$scope*/ 32) {
				item0_changes.$$scope = { dirty, ctx };
			}

			item0.$set(item0_changes);
			const item1_changes = {};

			if (dirty & /*$$scope*/ 32) {
				item1_changes.$$scope = { dirty, ctx };
			}

			item1.$set(item1_changes);
			const item2_changes = {};

			if (dirty & /*$$scope*/ 32) {
				item2_changes.$$scope = { dirty, ctx };
			}

			item2.$set(item2_changes);
			const item3_changes = {};

			if (dirty & /*$$scope*/ 32) {
				item3_changes.$$scope = { dirty, ctx };
			}

			item3.$set(item3_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(item0.$$.fragment, local);
			transition_in(item1.$$.fragment, local);
			transition_in(item2.$$.fragment, local);
			transition_in(separator.$$.fragment, local);
			transition_in(item3.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(item0.$$.fragment, local);
			transition_out(item1.$$.fragment, local);
			transition_out(item2.$$.fragment, local);
			transition_out(separator.$$.fragment, local);
			transition_out(item3.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(item0, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(item1, detaching);
			if (detaching) detach_dev(t1);
			destroy_component(item2, detaching);
			if (detaching) detach_dev(t2);
			destroy_component(separator, detaching);
			if (detaching) detach_dev(t3);
			destroy_component(item3, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$7.name,
		type: "slot",
		source: "(2:2) <List class=\\\"demo-list\\\" dense>",
		ctx
	});

	return block;
}

function create_fragment$7(ctx) {
	let div;
	let list;
	let t0;
	let pre;
	let t1;
	let t2;
	let current;

	list = new List$1({
			props: {
				class: "demo-list",
				dense: true,
				$$slots: { default: [create_default_slot$7] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			div = element("div");
			create_component(list.$$.fragment);
			t0 = space();
			pre = element("pre");
			t1 = text("Clicked: ");
			t2 = text(/*clicked*/ ctx[0]);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			claim_component(list.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			t0 = claim_space(nodes);
			pre = claim_element(nodes, "PRE", { class: true });
			var pre_nodes = children(pre);
			t1 = claim_text(pre_nodes, "Clicked: ");
			t2 = claim_text(pre_nodes, /*clicked*/ ctx[0]);
			pre_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "svelte-16qb95n");
			add_location(div, file$7, 0, 0, 0);
			attr_dev(pre, "class", "status svelte-16qb95n");
			add_location(pre, file$7, 22, 0, 657);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(list, div, null);
			insert_dev(target, t0, anchor);
			insert_dev(target, pre, anchor);
			append_dev(pre, t1);
			append_dev(pre, t2);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const list_changes = {};

			if (dirty & /*$$scope, clicked*/ 33) {
				list_changes.$$scope = { dirty, ctx };
			}

			list.$set(list_changes);
			if (!current || dirty & /*clicked*/ 1) set_data_dev(t2, /*clicked*/ ctx[0]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(list.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(list.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(list);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(pre);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$7.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$7($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("GraphicsDense", slots, []);
	let clicked = "nothing yet";
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GraphicsDense> was created with unknown prop '${key}'`);
	});

	const SMUI_action_handler = () => $$invalidate(0, clicked = "Edit");
	const SMUI_action_handler_1 = () => $$invalidate(0, clicked = "Send");
	const SMUI_action_handler_2 = () => $$invalidate(0, clicked = "Archive");
	const SMUI_action_handler_3 = () => $$invalidate(0, clicked = "Delete");

	$$self.$capture_state = () => ({
		List: List$1,
		Item,
		Graphic,
		Separator,
		Text,
		clicked
	});

	$$self.$inject_state = $$props => {
		if ("clicked" in $$props) $$invalidate(0, clicked = $$props.clicked);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		clicked,
		SMUI_action_handler,
		SMUI_action_handler_1,
		SMUI_action_handler_2,
		SMUI_action_handler_3
	];
}

class GraphicsDense extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$7, create_fragment$7, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "GraphicsDense",
			options,
			id: create_fragment$7.name
		});
	}
}

/* src/routes/demo/list/_NonInteractive.svelte generated by Svelte v3.37.0 */
const file$6 = "src/routes/demo/list/_NonInteractive.svelte";

// (3:10) <Text>
function create_default_slot_8$4(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Thing 1");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Thing 1");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_8$4.name,
		type: "slot",
		source: "(3:10) <Text>",
		ctx
	});

	return block;
}

// (3:4) <Item>
function create_default_slot_7$4(ctx) {
	let text_1;
	let current;

	text_1 = new Text({
			props: {
				$$slots: { default: [create_default_slot_8$4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(text_1.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(text_1.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(text_1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const text_1_changes = {};

			if (dirty & /*$$scope*/ 1) {
				text_1_changes.$$scope = { dirty, ctx };
			}

			text_1.$set(text_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(text_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(text_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(text_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_7$4.name,
		type: "slot",
		source: "(3:4) <Item>",
		ctx
	});

	return block;
}

// (5:20) <Text>
function create_default_slot_6$5(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Thing 2");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Thing 2");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_6$5.name,
		type: "slot",
		source: "(5:20) <Text>",
		ctx
	});

	return block;
}

// (5:4) <Item activated>
function create_default_slot_5$6(ctx) {
	let text_1;
	let current;

	text_1 = new Text({
			props: {
				$$slots: { default: [create_default_slot_6$5] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(text_1.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(text_1.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(text_1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const text_1_changes = {};

			if (dirty & /*$$scope*/ 1) {
				text_1_changes.$$scope = { dirty, ctx };
			}

			text_1.$set(text_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(text_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(text_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(text_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_5$6.name,
		type: "slot",
		source: "(5:4) <Item activated>",
		ctx
	});

	return block;
}

// (6:10) <Text>
function create_default_slot_4$6(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Thing 3");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Thing 3");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_4$6.name,
		type: "slot",
		source: "(6:10) <Text>",
		ctx
	});

	return block;
}

// (6:4) <Item>
function create_default_slot_3$6(ctx) {
	let text_1;
	let current;

	text_1 = new Text({
			props: {
				$$slots: { default: [create_default_slot_4$6] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(text_1.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(text_1.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(text_1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const text_1_changes = {};

			if (dirty & /*$$scope*/ 1) {
				text_1_changes.$$scope = { dirty, ctx };
			}

			text_1.$set(text_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(text_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(text_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(text_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3$6.name,
		type: "slot",
		source: "(6:4) <Item>",
		ctx
	});

	return block;
}

// (8:10) <Text>
function create_default_slot_2$6(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Thing 4");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Thing 4");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2$6.name,
		type: "slot",
		source: "(8:10) <Text>",
		ctx
	});

	return block;
}

// (8:4) <Item>
function create_default_slot_1$6(ctx) {
	let text_1;
	let current;

	text_1 = new Text({
			props: {
				$$slots: { default: [create_default_slot_2$6] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(text_1.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(text_1.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(text_1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const text_1_changes = {};

			if (dirty & /*$$scope*/ 1) {
				text_1_changes.$$scope = { dirty, ctx };
			}

			text_1.$set(text_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(text_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(text_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(text_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$6.name,
		type: "slot",
		source: "(8:4) <Item>",
		ctx
	});

	return block;
}

// (2:2) <List class="demo-list" nonInteractive>
function create_default_slot$6(ctx) {
	let item0;
	let t0;
	let separator0;
	let t1;
	let item1;
	let t2;
	let item2;
	let t3;
	let separator1;
	let t4;
	let item3;
	let current;

	item0 = new Item({
			props: {
				$$slots: { default: [create_default_slot_7$4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	separator0 = new Separator({ $$inline: true });

	item1 = new Item({
			props: {
				activated: true,
				$$slots: { default: [create_default_slot_5$6] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	item2 = new Item({
			props: {
				$$slots: { default: [create_default_slot_3$6] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	separator1 = new Separator({ $$inline: true });

	item3 = new Item({
			props: {
				$$slots: { default: [create_default_slot_1$6] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(item0.$$.fragment);
			t0 = space();
			create_component(separator0.$$.fragment);
			t1 = space();
			create_component(item1.$$.fragment);
			t2 = space();
			create_component(item2.$$.fragment);
			t3 = space();
			create_component(separator1.$$.fragment);
			t4 = space();
			create_component(item3.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(item0.$$.fragment, nodes);
			t0 = claim_space(nodes);
			claim_component(separator0.$$.fragment, nodes);
			t1 = claim_space(nodes);
			claim_component(item1.$$.fragment, nodes);
			t2 = claim_space(nodes);
			claim_component(item2.$$.fragment, nodes);
			t3 = claim_space(nodes);
			claim_component(separator1.$$.fragment, nodes);
			t4 = claim_space(nodes);
			claim_component(item3.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(item0, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(separator0, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(item1, target, anchor);
			insert_dev(target, t2, anchor);
			mount_component(item2, target, anchor);
			insert_dev(target, t3, anchor);
			mount_component(separator1, target, anchor);
			insert_dev(target, t4, anchor);
			mount_component(item3, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const item0_changes = {};

			if (dirty & /*$$scope*/ 1) {
				item0_changes.$$scope = { dirty, ctx };
			}

			item0.$set(item0_changes);
			const item1_changes = {};

			if (dirty & /*$$scope*/ 1) {
				item1_changes.$$scope = { dirty, ctx };
			}

			item1.$set(item1_changes);
			const item2_changes = {};

			if (dirty & /*$$scope*/ 1) {
				item2_changes.$$scope = { dirty, ctx };
			}

			item2.$set(item2_changes);
			const item3_changes = {};

			if (dirty & /*$$scope*/ 1) {
				item3_changes.$$scope = { dirty, ctx };
			}

			item3.$set(item3_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(item0.$$.fragment, local);
			transition_in(separator0.$$.fragment, local);
			transition_in(item1.$$.fragment, local);
			transition_in(item2.$$.fragment, local);
			transition_in(separator1.$$.fragment, local);
			transition_in(item3.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(item0.$$.fragment, local);
			transition_out(separator0.$$.fragment, local);
			transition_out(item1.$$.fragment, local);
			transition_out(item2.$$.fragment, local);
			transition_out(separator1.$$.fragment, local);
			transition_out(item3.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(item0, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(separator0, detaching);
			if (detaching) detach_dev(t1);
			destroy_component(item1, detaching);
			if (detaching) detach_dev(t2);
			destroy_component(item2, detaching);
			if (detaching) detach_dev(t3);
			destroy_component(separator1, detaching);
			if (detaching) detach_dev(t4);
			destroy_component(item3, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$6.name,
		type: "slot",
		source: "(2:2) <List class=\\\"demo-list\\\" nonInteractive>",
		ctx
	});

	return block;
}

function create_fragment$6(ctx) {
	let div;
	let list;
	let current;

	list = new List$1({
			props: {
				class: "demo-list",
				nonInteractive: true,
				$$slots: { default: [create_default_slot$6] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			div = element("div");
			create_component(list.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			claim_component(list.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "svelte-16qb95n");
			add_location(div, file$6, 0, 0, 0);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(list, div, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const list_changes = {};

			if (dirty & /*$$scope*/ 1) {
				list_changes.$$scope = { dirty, ctx };
			}

			list.$set(list_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(list.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(list.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(list);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$6.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$6($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("NonInteractive", slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<NonInteractive> was created with unknown prop '${key}'`);
	});

	$$self.$capture_state = () => ({ List: List$1, Item, Separator, Text });
	return [];
}

class NonInteractive extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$6, create_fragment$6, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "NonInteractive",
			options,
			id: create_fragment$6.name
		});
	}
}

/* src/routes/demo/list/_TwoLineSelection.svelte generated by Svelte v3.37.0 */

const file$5 = "src/routes/demo/list/_TwoLineSelection.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[5] = list[i];
	return child_ctx;
}

// (22:10) <PrimaryText>
function create_default_slot_5$5(ctx) {
	let t_value = /*item*/ ctx[5].name + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		l: function claim(nodes) {
			t = claim_text(nodes, t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_5$5.name,
		type: "slot",
		source: "(22:10) <PrimaryText>",
		ctx
	});

	return block;
}

// (23:10) <SecondaryText>
function create_default_slot_4$5(ctx) {
	let t_value = /*item*/ ctx[5].description + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		l: function claim(nodes) {
			t = claim_text(nodes, t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_4$5.name,
		type: "slot",
		source: "(23:10) <SecondaryText>",
		ctx
	});

	return block;
}

// (21:8) <Text>
function create_default_slot_3$5(ctx) {
	let primarytext;
	let t;
	let secondarytext;
	let current;

	primarytext = new PrimaryText({
			props: {
				$$slots: { default: [create_default_slot_5$5] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	secondarytext = new SecondaryText({
			props: {
				$$slots: { default: [create_default_slot_4$5] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(primarytext.$$.fragment);
			t = space();
			create_component(secondarytext.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(primarytext.$$.fragment, nodes);
			t = claim_space(nodes);
			claim_component(secondarytext.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(primarytext, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(secondarytext, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const primarytext_changes = {};

			if (dirty & /*$$scope*/ 256) {
				primarytext_changes.$$scope = { dirty, ctx };
			}

			primarytext.$set(primarytext_changes);
			const secondarytext_changes = {};

			if (dirty & /*$$scope*/ 256) {
				secondarytext_changes.$$scope = { dirty, ctx };
			}

			secondarytext.$set(secondarytext_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(primarytext.$$.fragment, local);
			transition_in(secondarytext.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(primarytext.$$.fragment, local);
			transition_out(secondarytext.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(primarytext, detaching);
			if (detaching) detach_dev(t);
			destroy_component(secondarytext, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3$5.name,
		type: "slot",
		source: "(21:8) <Text>",
		ctx
	});

	return block;
}

// (25:8) <Meta class="material-icons">
function create_default_slot_2$5(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("info");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "info");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2$5.name,
		type: "slot",
		source: "(25:8) <Meta class=\\\"material-icons\\\">",
		ctx
	});

	return block;
}

// (10:6) <Item         on:SMUI:action={() => (selection = item.name)}         disabled={item.disabled}         selected={selection === item.name}       >
function create_default_slot_1$5(ctx) {
	let graphic;
	let t0;
	let text_1;
	let t1;
	let meta;
	let t2;
	let current;

	graphic = new Graphic({
			props: {
				style: "background-image: url(https://place-hold.it/40x40?text=" + /*item*/ ctx[5].name.split(" ").map(func).join("") + "&fontsize=16);"
			},
			$$inline: true
		});

	text_1 = new Text({
			props: {
				$$slots: { default: [create_default_slot_3$5] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	meta = new Meta({
			props: {
				class: "material-icons",
				$$slots: { default: [create_default_slot_2$5] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(graphic.$$.fragment);
			t0 = space();
			create_component(text_1.$$.fragment);
			t1 = space();
			create_component(meta.$$.fragment);
			t2 = space();
		},
		l: function claim(nodes) {
			claim_component(graphic.$$.fragment, nodes);
			t0 = claim_space(nodes);
			claim_component(text_1.$$.fragment, nodes);
			t1 = claim_space(nodes);
			claim_component(meta.$$.fragment, nodes);
			t2 = claim_space(nodes);
		},
		m: function mount(target, anchor) {
			mount_component(graphic, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(text_1, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(meta, target, anchor);
			insert_dev(target, t2, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const text_1_changes = {};

			if (dirty & /*$$scope*/ 256) {
				text_1_changes.$$scope = { dirty, ctx };
			}

			text_1.$set(text_1_changes);
			const meta_changes = {};

			if (dirty & /*$$scope*/ 256) {
				meta_changes.$$scope = { dirty, ctx };
			}

			meta.$set(meta_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(graphic.$$.fragment, local);
			transition_in(text_1.$$.fragment, local);
			transition_in(meta.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(graphic.$$.fragment, local);
			transition_out(text_1.$$.fragment, local);
			transition_out(meta.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(graphic, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(text_1, detaching);
			if (detaching) detach_dev(t1);
			destroy_component(meta, detaching);
			if (detaching) detach_dev(t2);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$5.name,
		type: "slot",
		source: "(10:6) <Item         on:SMUI:action={() => (selection = item.name)}         disabled={item.disabled}         selected={selection === item.name}       >",
		ctx
	});

	return block;
}

// (9:4) {#each options as item}
function create_each_block(ctx) {
	let item;
	let current;

	function SMUI_action_handler() {
		return /*SMUI_action_handler*/ ctx[3](/*item*/ ctx[5]);
	}

	item = new Item({
			props: {
				disabled: /*item*/ ctx[5].disabled,
				selected: /*selection*/ ctx[0] === /*item*/ ctx[5].name,
				$$slots: { default: [create_default_slot_1$5] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	item.$on("SMUI:action", SMUI_action_handler);

	const block = {
		c: function create() {
			create_component(item.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(item.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(item, target, anchor);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			const item_changes = {};
			if (dirty & /*selection*/ 1) item_changes.selected = /*selection*/ ctx[0] === /*item*/ ctx[5].name;

			if (dirty & /*$$scope*/ 256) {
				item_changes.$$scope = { dirty, ctx };
			}

			item.$set(item_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(item.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(item.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(item, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(9:4) {#each options as item}",
		ctx
	});

	return block;
}

// (2:2) <List     class="demo-list"     twoLine     avatarList     singleSelection     bind:selectedIndex={selectionIndex}   >
function create_default_slot$5(ctx) {
	let each_1_anchor;
	let current;
	let each_value = /*options*/ ctx[2];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (dirty & /*options, selection*/ 5) {
				each_value = /*options*/ ctx[2];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$5.name,
		type: "slot",
		source: "(2:2) <List     class=\\\"demo-list\\\"     twoLine     avatarList     singleSelection     bind:selectedIndex={selectionIndex}   >",
		ctx
	});

	return block;
}

function create_fragment$5(ctx) {
	let div;
	let list;
	let updating_selectedIndex;
	let t0;
	let pre;
	let t1;
	let t2;
	let t3;
	let t4;
	let current;

	function list_selectedIndex_binding(value) {
		/*list_selectedIndex_binding*/ ctx[4](value);
	}

	let list_props = {
		class: "demo-list",
		twoLine: true,
		avatarList: true,
		singleSelection: true,
		$$slots: { default: [create_default_slot$5] },
		$$scope: { ctx }
	};

	if (/*selectionIndex*/ ctx[1] !== void 0) {
		list_props.selectedIndex = /*selectionIndex*/ ctx[1];
	}

	list = new List$1({ props: list_props, $$inline: true });
	binding_callbacks.push(() => bind(list, "selectedIndex", list_selectedIndex_binding));

	const block = {
		c: function create() {
			div = element("div");
			create_component(list.$$.fragment);
			t0 = space();
			pre = element("pre");
			t1 = text("Selected: ");
			t2 = text(/*selection*/ ctx[0]);
			t3 = text(", value of selectedIndex: ");
			t4 = text(/*selectionIndex*/ ctx[1]);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			claim_component(list.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			t0 = claim_space(nodes);
			pre = claim_element(nodes, "PRE", { class: true });
			var pre_nodes = children(pre);
			t1 = claim_text(pre_nodes, "Selected: ");
			t2 = claim_text(pre_nodes, /*selection*/ ctx[0]);
			t3 = claim_text(pre_nodes, ", value of selectedIndex: ");
			t4 = claim_text(pre_nodes, /*selectionIndex*/ ctx[1]);
			pre_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "svelte-16qb95n");
			add_location(div, file$5, 0, 0, 0);
			attr_dev(pre, "class", "status svelte-16qb95n");
			add_location(pre, file$5, 30, 0, 759);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(list, div, null);
			insert_dev(target, t0, anchor);
			insert_dev(target, pre, anchor);
			append_dev(pre, t1);
			append_dev(pre, t2);
			append_dev(pre, t3);
			append_dev(pre, t4);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const list_changes = {};

			if (dirty & /*$$scope, selection*/ 257) {
				list_changes.$$scope = { dirty, ctx };
			}

			if (!updating_selectedIndex && dirty & /*selectionIndex*/ 2) {
				updating_selectedIndex = true;
				list_changes.selectedIndex = /*selectionIndex*/ ctx[1];
				add_flush_callback(() => updating_selectedIndex = false);
			}

			list.$set(list_changes);
			if (!current || dirty & /*selection*/ 1) set_data_dev(t2, /*selection*/ ctx[0]);
			if (!current || dirty & /*selectionIndex*/ 2) set_data_dev(t4, /*selectionIndex*/ ctx[1]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(list.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(list.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(list);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(pre);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$5.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

const func = val => val.substring(0, 1);

function instance$5($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("TwoLineSelection", slots, []);

	let options = [
		{
			name: "Bruce Willis",
			description: "Actor",
			disabled: false
		},
		{
			name: "Austin Powers",
			description: "Fictional Character",
			disabled: true
		},
		{
			name: "Thomas Edison",
			description: "Inventor",
			disabled: false
		},
		{
			name: "Stephen Hawking",
			description: "Scientist",
			disabled: false
		}
	];

	let selection = "Stephen Hawking";

	// This value is updated when the component is initialized, based on the
	// selected Item's `selected` prop.
	let selectionIndex = null;

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<TwoLineSelection> was created with unknown prop '${key}'`);
	});

	const SMUI_action_handler = item => $$invalidate(0, selection = item.name);

	function list_selectedIndex_binding(value) {
		selectionIndex = value;
		$$invalidate(1, selectionIndex);
	}

	$$self.$capture_state = () => ({
		List: List$1,
		Item,
		Graphic,
		Meta,
		Text,
		PrimaryText,
		SecondaryText,
		options,
		selection,
		selectionIndex
	});

	$$self.$inject_state = $$props => {
		if ("options" in $$props) $$invalidate(2, options = $$props.options);
		if ("selection" in $$props) $$invalidate(0, selection = $$props.selection);
		if ("selectionIndex" in $$props) $$invalidate(1, selectionIndex = $$props.selectionIndex);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		selection,
		selectionIndex,
		options,
		SMUI_action_handler,
		list_selectedIndex_binding
	];
}

class TwoLineSelection extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$5, create_fragment$5, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "TwoLineSelection",
			options,
			id: create_fragment$5.name
		});
	}
}

/* src/routes/demo/list/_ThreeLine.svelte generated by Svelte v3.37.0 */
const file$4 = "src/routes/demo/list/_ThreeLine.svelte";

// (5:8) <PrimaryText>
function create_default_slot_10$3(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("FruitPhone 11");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "FruitPhone 11");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_10$3.name,
		type: "slot",
		source: "(5:8) <PrimaryText>",
		ctx
	});

	return block;
}

// (6:8) <SecondaryText>
function create_default_slot_9$3(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("$1,100");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "$1,100");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_9$3.name,
		type: "slot",
		source: "(6:8) <SecondaryText>",
		ctx
	});

	return block;
}

// (7:8) <SecondaryText>
function create_default_slot_8$3(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("A beautiful phone with good specs.");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "A beautiful phone with good specs.");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_8$3.name,
		type: "slot",
		source: "(7:8) <SecondaryText>",
		ctx
	});

	return block;
}

// (4:6) <Text>
function create_default_slot_7$3(ctx) {
	let primarytext;
	let t0;
	let secondarytext0;
	let t1;
	let secondarytext1;
	let current;

	primarytext = new PrimaryText({
			props: {
				$$slots: { default: [create_default_slot_10$3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	secondarytext0 = new SecondaryText({
			props: {
				$$slots: { default: [create_default_slot_9$3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	secondarytext1 = new SecondaryText({
			props: {
				$$slots: { default: [create_default_slot_8$3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(primarytext.$$.fragment);
			t0 = space();
			create_component(secondarytext0.$$.fragment);
			t1 = space();
			create_component(secondarytext1.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(primarytext.$$.fragment, nodes);
			t0 = claim_space(nodes);
			claim_component(secondarytext0.$$.fragment, nodes);
			t1 = claim_space(nodes);
			claim_component(secondarytext1.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(primarytext, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(secondarytext0, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(secondarytext1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const primarytext_changes = {};

			if (dirty & /*$$scope*/ 1) {
				primarytext_changes.$$scope = { dirty, ctx };
			}

			primarytext.$set(primarytext_changes);
			const secondarytext0_changes = {};

			if (dirty & /*$$scope*/ 1) {
				secondarytext0_changes.$$scope = { dirty, ctx };
			}

			secondarytext0.$set(secondarytext0_changes);
			const secondarytext1_changes = {};

			if (dirty & /*$$scope*/ 1) {
				secondarytext1_changes.$$scope = { dirty, ctx };
			}

			secondarytext1.$set(secondarytext1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(primarytext.$$.fragment, local);
			transition_in(secondarytext0.$$.fragment, local);
			transition_in(secondarytext1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(primarytext.$$.fragment, local);
			transition_out(secondarytext0.$$.fragment, local);
			transition_out(secondarytext1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(primarytext, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(secondarytext0, detaching);
			if (detaching) detach_dev(t1);
			destroy_component(secondarytext1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_7$3.name,
		type: "slot",
		source: "(4:6) <Text>",
		ctx
	});

	return block;
}

// (3:4) <Item>
function create_default_slot_6$4(ctx) {
	let text_1;
	let current;

	text_1 = new Text({
			props: {
				$$slots: { default: [create_default_slot_7$3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(text_1.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(text_1.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(text_1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const text_1_changes = {};

			if (dirty & /*$$scope*/ 1) {
				text_1_changes.$$scope = { dirty, ctx };
			}

			text_1.$set(text_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(text_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(text_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(text_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_6$4.name,
		type: "slot",
		source: "(3:4) <Item>",
		ctx
	});

	return block;
}

// (12:8) <PrimaryText>
function create_default_slot_5$4(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Addition Phone");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Addition Phone");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_5$4.name,
		type: "slot",
		source: "(12:8) <PrimaryText>",
		ctx
	});

	return block;
}

// (13:8) <SecondaryText>
function create_default_slot_4$4(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("$700");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "$700");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_4$4.name,
		type: "slot",
		source: "(13:8) <SecondaryText>",
		ctx
	});

	return block;
}

// (14:8) <SecondaryText           >
function create_default_slot_3$4(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Pretty much the same phone, but a different brand name and OS.");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Pretty much the same phone, but a different brand name and OS.");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3$4.name,
		type: "slot",
		source: "(14:8) <SecondaryText           >",
		ctx
	});

	return block;
}

// (11:6) <Text>
function create_default_slot_2$4(ctx) {
	let primarytext;
	let t0;
	let secondarytext0;
	let t1;
	let secondarytext1;
	let current;

	primarytext = new PrimaryText({
			props: {
				$$slots: { default: [create_default_slot_5$4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	secondarytext0 = new SecondaryText({
			props: {
				$$slots: { default: [create_default_slot_4$4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	secondarytext1 = new SecondaryText({
			props: {
				$$slots: { default: [create_default_slot_3$4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(primarytext.$$.fragment);
			t0 = space();
			create_component(secondarytext0.$$.fragment);
			t1 = space();
			create_component(secondarytext1.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(primarytext.$$.fragment, nodes);
			t0 = claim_space(nodes);
			claim_component(secondarytext0.$$.fragment, nodes);
			t1 = claim_space(nodes);
			claim_component(secondarytext1.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(primarytext, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(secondarytext0, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(secondarytext1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const primarytext_changes = {};

			if (dirty & /*$$scope*/ 1) {
				primarytext_changes.$$scope = { dirty, ctx };
			}

			primarytext.$set(primarytext_changes);
			const secondarytext0_changes = {};

			if (dirty & /*$$scope*/ 1) {
				secondarytext0_changes.$$scope = { dirty, ctx };
			}

			secondarytext0.$set(secondarytext0_changes);
			const secondarytext1_changes = {};

			if (dirty & /*$$scope*/ 1) {
				secondarytext1_changes.$$scope = { dirty, ctx };
			}

			secondarytext1.$set(secondarytext1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(primarytext.$$.fragment, local);
			transition_in(secondarytext0.$$.fragment, local);
			transition_in(secondarytext1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(primarytext.$$.fragment, local);
			transition_out(secondarytext0.$$.fragment, local);
			transition_out(secondarytext1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(primarytext, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(secondarytext0, detaching);
			if (detaching) detach_dev(t1);
			destroy_component(secondarytext1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2$4.name,
		type: "slot",
		source: "(11:6) <Text>",
		ctx
	});

	return block;
}

// (10:4) <Item>
function create_default_slot_1$4(ctx) {
	let text_1;
	let current;

	text_1 = new Text({
			props: {
				$$slots: { default: [create_default_slot_2$4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(text_1.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(text_1.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(text_1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const text_1_changes = {};

			if (dirty & /*$$scope*/ 1) {
				text_1_changes.$$scope = { dirty, ctx };
			}

			text_1.$set(text_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(text_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(text_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(text_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$4.name,
		type: "slot",
		source: "(10:4) <Item>",
		ctx
	});

	return block;
}

// (2:2) <List class="demo-list" threeLine nonInteractive>
function create_default_slot$4(ctx) {
	let item0;
	let t;
	let item1;
	let current;

	item0 = new Item({
			props: {
				$$slots: { default: [create_default_slot_6$4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	item1 = new Item({
			props: {
				$$slots: { default: [create_default_slot_1$4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(item0.$$.fragment);
			t = space();
			create_component(item1.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(item0.$$.fragment, nodes);
			t = claim_space(nodes);
			claim_component(item1.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(item0, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(item1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const item0_changes = {};

			if (dirty & /*$$scope*/ 1) {
				item0_changes.$$scope = { dirty, ctx };
			}

			item0.$set(item0_changes);
			const item1_changes = {};

			if (dirty & /*$$scope*/ 1) {
				item1_changes.$$scope = { dirty, ctx };
			}

			item1.$set(item1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(item0.$$.fragment, local);
			transition_in(item1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(item0.$$.fragment, local);
			transition_out(item1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(item0, detaching);
			if (detaching) detach_dev(t);
			destroy_component(item1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$4.name,
		type: "slot",
		source: "(2:2) <List class=\\\"demo-list\\\" threeLine nonInteractive>",
		ctx
	});

	return block;
}

function create_fragment$4(ctx) {
	let div;
	let list;
	let current;

	list = new List$1({
			props: {
				class: "demo-list",
				threeLine: true,
				nonInteractive: true,
				$$slots: { default: [create_default_slot$4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			div = element("div");
			create_component(list.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			claim_component(list.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "svelte-16qb95n");
			add_location(div, file$4, 0, 0, 0);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(list, div, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const list_changes = {};

			if (dirty & /*$$scope*/ 1) {
				list_changes.$$scope = { dirty, ctx };
			}

			list.$set(list_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(list.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(list.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(list);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("ThreeLine", slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ThreeLine> was created with unknown prop '${key}'`);
	});

	$$self.$capture_state = () => ({
		List: List$1,
		Item,
		Text,
		PrimaryText,
		SecondaryText
	});

	return [];
}

class ThreeLine extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4, create_fragment$4, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ThreeLine",
			options,
			id: create_fragment$4.name
		});
	}
}

/* src/routes/demo/list/_Groups.svelte generated by Svelte v3.37.0 */
const file$3 = "src/routes/demo/list/_Groups.svelte";

// (3:4) <Subheader>
function create_default_slot_24(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Actors");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Actors");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_24.name,
		type: "slot",
		source: "(3:4) <Subheader>",
		ctx
	});

	return block;
}

// (6:8) <Text>
function create_default_slot_23(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Bruce Willis");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Bruce Willis");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_23.name,
		type: "slot",
		source: "(6:8) <Text>",
		ctx
	});

	return block;
}

// (5:6) <Item on:SMUI:action={() => (clicked = 'Bruce Willis')}>
function create_default_slot_22(ctx) {
	let text_1;
	let current;

	text_1 = new Text({
			props: {
				$$slots: { default: [create_default_slot_23] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(text_1.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(text_1.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(text_1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const text_1_changes = {};

			if (dirty & /*$$scope*/ 2048) {
				text_1_changes.$$scope = { dirty, ctx };
			}

			text_1.$set(text_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(text_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(text_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(text_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_22.name,
		type: "slot",
		source: "(5:6) <Item on:SMUI:action={() => (clicked = 'Bruce Willis')}>",
		ctx
	});

	return block;
}

// (9:8) <Text>
function create_default_slot_21(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Tom Hanks");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Tom Hanks");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_21.name,
		type: "slot",
		source: "(9:8) <Text>",
		ctx
	});

	return block;
}

// (8:6) <Item on:SMUI:action={() => (clicked = 'Tom Hanks')}>
function create_default_slot_20(ctx) {
	let text_1;
	let current;

	text_1 = new Text({
			props: {
				$$slots: { default: [create_default_slot_21] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(text_1.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(text_1.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(text_1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const text_1_changes = {};

			if (dirty & /*$$scope*/ 2048) {
				text_1_changes.$$scope = { dirty, ctx };
			}

			text_1.$set(text_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(text_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(text_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(text_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_20.name,
		type: "slot",
		source: "(8:6) <Item on:SMUI:action={() => (clicked = 'Tom Hanks')}>",
		ctx
	});

	return block;
}

// (12:8) <Text>
function create_default_slot_19(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Jack Nicholson");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Jack Nicholson");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_19.name,
		type: "slot",
		source: "(12:8) <Text>",
		ctx
	});

	return block;
}

// (11:6) <Item on:SMUI:action={() => (clicked = 'Jack Nicholson')}>
function create_default_slot_18(ctx) {
	let text_1;
	let current;

	text_1 = new Text({
			props: {
				$$slots: { default: [create_default_slot_19] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(text_1.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(text_1.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(text_1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const text_1_changes = {};

			if (dirty & /*$$scope*/ 2048) {
				text_1_changes.$$scope = { dirty, ctx };
			}

			text_1.$set(text_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(text_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(text_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(text_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_18.name,
		type: "slot",
		source: "(11:6) <Item on:SMUI:action={() => (clicked = 'Jack Nicholson')}>",
		ctx
	});

	return block;
}

// (15:8) <Text>
function create_default_slot_17(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Leonardo DiCaprio");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Leonardo DiCaprio");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_17.name,
		type: "slot",
		source: "(15:8) <Text>",
		ctx
	});

	return block;
}

// (14:6) <Item on:SMUI:action={() => (clicked = 'Leonardo DiCaprio')}>
function create_default_slot_16(ctx) {
	let text_1;
	let current;

	text_1 = new Text({
			props: {
				$$slots: { default: [create_default_slot_17] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(text_1.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(text_1.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(text_1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const text_1_changes = {};

			if (dirty & /*$$scope*/ 2048) {
				text_1_changes.$$scope = { dirty, ctx };
			}

			text_1.$set(text_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(text_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(text_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(text_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_16.name,
		type: "slot",
		source: "(14:6) <Item on:SMUI:action={() => (clicked = 'Leonardo DiCaprio')}>",
		ctx
	});

	return block;
}

// (18:8) <Text>
function create_default_slot_15$2(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Matt Damon");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Matt Damon");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_15$2.name,
		type: "slot",
		source: "(18:8) <Text>",
		ctx
	});

	return block;
}

// (17:6) <Item on:SMUI:action={() => (clicked = 'Matt Damon')}>
function create_default_slot_14$2(ctx) {
	let text_1;
	let current;

	text_1 = new Text({
			props: {
				$$slots: { default: [create_default_slot_15$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(text_1.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(text_1.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(text_1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const text_1_changes = {};

			if (dirty & /*$$scope*/ 2048) {
				text_1_changes.$$scope = { dirty, ctx };
			}

			text_1.$set(text_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(text_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(text_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(text_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_14$2.name,
		type: "slot",
		source: "(17:6) <Item on:SMUI:action={() => (clicked = 'Matt Damon')}>",
		ctx
	});

	return block;
}

// (4:4) <List class="demo-list">
function create_default_slot_13$2(ctx) {
	let item0;
	let t0;
	let item1;
	let t1;
	let item2;
	let t2;
	let item3;
	let t3;
	let item4;
	let current;

	item0 = new Item({
			props: {
				$$slots: { default: [create_default_slot_22] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	item0.$on("SMUI:action", /*SMUI_action_handler*/ ctx[1]);

	item1 = new Item({
			props: {
				$$slots: { default: [create_default_slot_20] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	item1.$on("SMUI:action", /*SMUI_action_handler_1*/ ctx[2]);

	item2 = new Item({
			props: {
				$$slots: { default: [create_default_slot_18] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	item2.$on("SMUI:action", /*SMUI_action_handler_2*/ ctx[3]);

	item3 = new Item({
			props: {
				$$slots: { default: [create_default_slot_16] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	item3.$on("SMUI:action", /*SMUI_action_handler_3*/ ctx[4]);

	item4 = new Item({
			props: {
				$$slots: { default: [create_default_slot_14$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	item4.$on("SMUI:action", /*SMUI_action_handler_4*/ ctx[5]);

	const block = {
		c: function create() {
			create_component(item0.$$.fragment);
			t0 = space();
			create_component(item1.$$.fragment);
			t1 = space();
			create_component(item2.$$.fragment);
			t2 = space();
			create_component(item3.$$.fragment);
			t3 = space();
			create_component(item4.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(item0.$$.fragment, nodes);
			t0 = claim_space(nodes);
			claim_component(item1.$$.fragment, nodes);
			t1 = claim_space(nodes);
			claim_component(item2.$$.fragment, nodes);
			t2 = claim_space(nodes);
			claim_component(item3.$$.fragment, nodes);
			t3 = claim_space(nodes);
			claim_component(item4.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(item0, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(item1, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(item2, target, anchor);
			insert_dev(target, t2, anchor);
			mount_component(item3, target, anchor);
			insert_dev(target, t3, anchor);
			mount_component(item4, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const item0_changes = {};

			if (dirty & /*$$scope*/ 2048) {
				item0_changes.$$scope = { dirty, ctx };
			}

			item0.$set(item0_changes);
			const item1_changes = {};

			if (dirty & /*$$scope*/ 2048) {
				item1_changes.$$scope = { dirty, ctx };
			}

			item1.$set(item1_changes);
			const item2_changes = {};

			if (dirty & /*$$scope*/ 2048) {
				item2_changes.$$scope = { dirty, ctx };
			}

			item2.$set(item2_changes);
			const item3_changes = {};

			if (dirty & /*$$scope*/ 2048) {
				item3_changes.$$scope = { dirty, ctx };
			}

			item3.$set(item3_changes);
			const item4_changes = {};

			if (dirty & /*$$scope*/ 2048) {
				item4_changes.$$scope = { dirty, ctx };
			}

			item4.$set(item4_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(item0.$$.fragment, local);
			transition_in(item1.$$.fragment, local);
			transition_in(item2.$$.fragment, local);
			transition_in(item3.$$.fragment, local);
			transition_in(item4.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(item0.$$.fragment, local);
			transition_out(item1.$$.fragment, local);
			transition_out(item2.$$.fragment, local);
			transition_out(item3.$$.fragment, local);
			transition_out(item4.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(item0, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(item1, detaching);
			if (detaching) detach_dev(t1);
			destroy_component(item2, detaching);
			if (detaching) detach_dev(t2);
			destroy_component(item3, detaching);
			if (detaching) detach_dev(t3);
			destroy_component(item4, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_13$2.name,
		type: "slot",
		source: "(4:4) <List class=\\\"demo-list\\\">",
		ctx
	});

	return block;
}

// (21:4) <Subheader>
function create_default_slot_12$2(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Books");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Books");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_12$2.name,
		type: "slot",
		source: "(21:4) <Subheader>",
		ctx
	});

	return block;
}

// (24:8) <Text>
function create_default_slot_11$2(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("To Kill a Mockingbird");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "To Kill a Mockingbird");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_11$2.name,
		type: "slot",
		source: "(24:8) <Text>",
		ctx
	});

	return block;
}

// (23:6) <Item on:SMUI:action={() => (clicked = 'To Kill a Mockingbird')}>
function create_default_slot_10$2(ctx) {
	let text_1;
	let current;

	text_1 = new Text({
			props: {
				$$slots: { default: [create_default_slot_11$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(text_1.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(text_1.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(text_1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const text_1_changes = {};

			if (dirty & /*$$scope*/ 2048) {
				text_1_changes.$$scope = { dirty, ctx };
			}

			text_1.$set(text_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(text_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(text_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(text_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_10$2.name,
		type: "slot",
		source: "(23:6) <Item on:SMUI:action={() => (clicked = 'To Kill a Mockingbird')}>",
		ctx
	});

	return block;
}

// (27:8) <Text>
function create_default_slot_9$2(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("The Great Gatsby");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "The Great Gatsby");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_9$2.name,
		type: "slot",
		source: "(27:8) <Text>",
		ctx
	});

	return block;
}

// (26:6) <Item on:SMUI:action={() => (clicked = 'The Great Gatsby')}>
function create_default_slot_8$2(ctx) {
	let text_1;
	let current;

	text_1 = new Text({
			props: {
				$$slots: { default: [create_default_slot_9$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(text_1.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(text_1.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(text_1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const text_1_changes = {};

			if (dirty & /*$$scope*/ 2048) {
				text_1_changes.$$scope = { dirty, ctx };
			}

			text_1.$set(text_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(text_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(text_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(text_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_8$2.name,
		type: "slot",
		source: "(26:6) <Item on:SMUI:action={() => (clicked = 'The Great Gatsby')}>",
		ctx
	});

	return block;
}

// (30:8) <Text>
function create_default_slot_7$2(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("1984");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "1984");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_7$2.name,
		type: "slot",
		source: "(30:8) <Text>",
		ctx
	});

	return block;
}

// (29:6) <Item on:SMUI:action={() => (clicked = '1984')}>
function create_default_slot_6$3(ctx) {
	let text_1;
	let current;

	text_1 = new Text({
			props: {
				$$slots: { default: [create_default_slot_7$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(text_1.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(text_1.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(text_1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const text_1_changes = {};

			if (dirty & /*$$scope*/ 2048) {
				text_1_changes.$$scope = { dirty, ctx };
			}

			text_1.$set(text_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(text_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(text_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(text_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_6$3.name,
		type: "slot",
		source: "(29:6) <Item on:SMUI:action={() => (clicked = '1984')}>",
		ctx
	});

	return block;
}

// (33:8) <Text>
function create_default_slot_5$3(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Catch-22");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Catch-22");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_5$3.name,
		type: "slot",
		source: "(33:8) <Text>",
		ctx
	});

	return block;
}

// (32:6) <Item on:SMUI:action={() => (clicked = 'Catch-22')}>
function create_default_slot_4$3(ctx) {
	let text_1;
	let current;

	text_1 = new Text({
			props: {
				$$slots: { default: [create_default_slot_5$3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(text_1.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(text_1.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(text_1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const text_1_changes = {};

			if (dirty & /*$$scope*/ 2048) {
				text_1_changes.$$scope = { dirty, ctx };
			}

			text_1.$set(text_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(text_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(text_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(text_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_4$3.name,
		type: "slot",
		source: "(32:6) <Item on:SMUI:action={() => (clicked = 'Catch-22')}>",
		ctx
	});

	return block;
}

// (38:8) <Text>
function create_default_slot_3$3(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Alice's Adventures in Wonderland");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Alice's Adventures in Wonderland");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3$3.name,
		type: "slot",
		source: "(38:8) <Text>",
		ctx
	});

	return block;
}

// (35:6) <Item         on:SMUI:action={() => (clicked = "Alice's Adventures in Wonderland")}       >
function create_default_slot_2$3(ctx) {
	let text_1;
	let current;

	text_1 = new Text({
			props: {
				$$slots: { default: [create_default_slot_3$3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(text_1.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(text_1.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(text_1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const text_1_changes = {};

			if (dirty & /*$$scope*/ 2048) {
				text_1_changes.$$scope = { dirty, ctx };
			}

			text_1.$set(text_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(text_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(text_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(text_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2$3.name,
		type: "slot",
		source: "(35:6) <Item         on:SMUI:action={() => (clicked = \\\"Alice's Adventures in Wonderland\\\")}       >",
		ctx
	});

	return block;
}

// (22:4) <List class="demo-list">
function create_default_slot_1$3(ctx) {
	let item0;
	let t0;
	let item1;
	let t1;
	let item2;
	let t2;
	let item3;
	let t3;
	let item4;
	let current;

	item0 = new Item({
			props: {
				$$slots: { default: [create_default_slot_10$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	item0.$on("SMUI:action", /*SMUI_action_handler_5*/ ctx[6]);

	item1 = new Item({
			props: {
				$$slots: { default: [create_default_slot_8$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	item1.$on("SMUI:action", /*SMUI_action_handler_6*/ ctx[7]);

	item2 = new Item({
			props: {
				$$slots: { default: [create_default_slot_6$3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	item2.$on("SMUI:action", /*SMUI_action_handler_7*/ ctx[8]);

	item3 = new Item({
			props: {
				$$slots: { default: [create_default_slot_4$3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	item3.$on("SMUI:action", /*SMUI_action_handler_8*/ ctx[9]);

	item4 = new Item({
			props: {
				$$slots: { default: [create_default_slot_2$3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	item4.$on("SMUI:action", /*SMUI_action_handler_9*/ ctx[10]);

	const block = {
		c: function create() {
			create_component(item0.$$.fragment);
			t0 = space();
			create_component(item1.$$.fragment);
			t1 = space();
			create_component(item2.$$.fragment);
			t2 = space();
			create_component(item3.$$.fragment);
			t3 = space();
			create_component(item4.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(item0.$$.fragment, nodes);
			t0 = claim_space(nodes);
			claim_component(item1.$$.fragment, nodes);
			t1 = claim_space(nodes);
			claim_component(item2.$$.fragment, nodes);
			t2 = claim_space(nodes);
			claim_component(item3.$$.fragment, nodes);
			t3 = claim_space(nodes);
			claim_component(item4.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(item0, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(item1, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(item2, target, anchor);
			insert_dev(target, t2, anchor);
			mount_component(item3, target, anchor);
			insert_dev(target, t3, anchor);
			mount_component(item4, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const item0_changes = {};

			if (dirty & /*$$scope*/ 2048) {
				item0_changes.$$scope = { dirty, ctx };
			}

			item0.$set(item0_changes);
			const item1_changes = {};

			if (dirty & /*$$scope*/ 2048) {
				item1_changes.$$scope = { dirty, ctx };
			}

			item1.$set(item1_changes);
			const item2_changes = {};

			if (dirty & /*$$scope*/ 2048) {
				item2_changes.$$scope = { dirty, ctx };
			}

			item2.$set(item2_changes);
			const item3_changes = {};

			if (dirty & /*$$scope*/ 2048) {
				item3_changes.$$scope = { dirty, ctx };
			}

			item3.$set(item3_changes);
			const item4_changes = {};

			if (dirty & /*$$scope*/ 2048) {
				item4_changes.$$scope = { dirty, ctx };
			}

			item4.$set(item4_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(item0.$$.fragment, local);
			transition_in(item1.$$.fragment, local);
			transition_in(item2.$$.fragment, local);
			transition_in(item3.$$.fragment, local);
			transition_in(item4.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(item0.$$.fragment, local);
			transition_out(item1.$$.fragment, local);
			transition_out(item2.$$.fragment, local);
			transition_out(item3.$$.fragment, local);
			transition_out(item4.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(item0, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(item1, detaching);
			if (detaching) detach_dev(t1);
			destroy_component(item2, detaching);
			if (detaching) detach_dev(t2);
			destroy_component(item3, detaching);
			if (detaching) detach_dev(t3);
			destroy_component(item4, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$3.name,
		type: "slot",
		source: "(22:4) <List class=\\\"demo-list\\\">",
		ctx
	});

	return block;
}

// (2:2) <Group>
function create_default_slot$3(ctx) {
	let subheader0;
	let t0;
	let list0;
	let t1;
	let subheader1;
	let t2;
	let list1;
	let current;

	subheader0 = new Subheader({
			props: {
				$$slots: { default: [create_default_slot_24] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	list0 = new List$1({
			props: {
				class: "demo-list",
				$$slots: { default: [create_default_slot_13$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	subheader1 = new Subheader({
			props: {
				$$slots: { default: [create_default_slot_12$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	list1 = new List$1({
			props: {
				class: "demo-list",
				$$slots: { default: [create_default_slot_1$3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(subheader0.$$.fragment);
			t0 = space();
			create_component(list0.$$.fragment);
			t1 = space();
			create_component(subheader1.$$.fragment);
			t2 = space();
			create_component(list1.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(subheader0.$$.fragment, nodes);
			t0 = claim_space(nodes);
			claim_component(list0.$$.fragment, nodes);
			t1 = claim_space(nodes);
			claim_component(subheader1.$$.fragment, nodes);
			t2 = claim_space(nodes);
			claim_component(list1.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(subheader0, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(list0, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(subheader1, target, anchor);
			insert_dev(target, t2, anchor);
			mount_component(list1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const subheader0_changes = {};

			if (dirty & /*$$scope*/ 2048) {
				subheader0_changes.$$scope = { dirty, ctx };
			}

			subheader0.$set(subheader0_changes);
			const list0_changes = {};

			if (dirty & /*$$scope, clicked*/ 2049) {
				list0_changes.$$scope = { dirty, ctx };
			}

			list0.$set(list0_changes);
			const subheader1_changes = {};

			if (dirty & /*$$scope*/ 2048) {
				subheader1_changes.$$scope = { dirty, ctx };
			}

			subheader1.$set(subheader1_changes);
			const list1_changes = {};

			if (dirty & /*$$scope, clicked*/ 2049) {
				list1_changes.$$scope = { dirty, ctx };
			}

			list1.$set(list1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(subheader0.$$.fragment, local);
			transition_in(list0.$$.fragment, local);
			transition_in(subheader1.$$.fragment, local);
			transition_in(list1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(subheader0.$$.fragment, local);
			transition_out(list0.$$.fragment, local);
			transition_out(subheader1.$$.fragment, local);
			transition_out(list1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(subheader0, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(list0, detaching);
			if (detaching) detach_dev(t1);
			destroy_component(subheader1, detaching);
			if (detaching) detach_dev(t2);
			destroy_component(list1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$3.name,
		type: "slot",
		source: "(2:2) <Group>",
		ctx
	});

	return block;
}

function create_fragment$3(ctx) {
	let div;
	let group;
	let t0;
	let pre;
	let t1;
	let t2;
	let current;

	group = new Group({
			props: {
				$$slots: { default: [create_default_slot$3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			div = element("div");
			create_component(group.$$.fragment);
			t0 = space();
			pre = element("pre");
			t1 = text("Clicked: ");
			t2 = text(/*clicked*/ ctx[0]);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			claim_component(group.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			t0 = claim_space(nodes);
			pre = claim_element(nodes, "PRE", { class: true });
			var pre_nodes = children(pre);
			t1 = claim_text(pre_nodes, "Clicked: ");
			t2 = claim_text(pre_nodes, /*clicked*/ ctx[0]);
			pre_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "svelte-16qb95n");
			add_location(div, file$3, 0, 0, 0);
			attr_dev(pre, "class", "status svelte-16qb95n");
			add_location(pre, file$3, 43, 0, 1355);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(group, div, null);
			insert_dev(target, t0, anchor);
			insert_dev(target, pre, anchor);
			append_dev(pre, t1);
			append_dev(pre, t2);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const group_changes = {};

			if (dirty & /*$$scope, clicked*/ 2049) {
				group_changes.$$scope = { dirty, ctx };
			}

			group.$set(group_changes);
			if (!current || dirty & /*clicked*/ 1) set_data_dev(t2, /*clicked*/ ctx[0]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(group.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(group.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(group);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(pre);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Groups", slots, []);
	let clicked = "nothing yet";
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Groups> was created with unknown prop '${key}'`);
	});

	const SMUI_action_handler = () => $$invalidate(0, clicked = "Bruce Willis");
	const SMUI_action_handler_1 = () => $$invalidate(0, clicked = "Tom Hanks");
	const SMUI_action_handler_2 = () => $$invalidate(0, clicked = "Jack Nicholson");
	const SMUI_action_handler_3 = () => $$invalidate(0, clicked = "Leonardo DiCaprio");
	const SMUI_action_handler_4 = () => $$invalidate(0, clicked = "Matt Damon");
	const SMUI_action_handler_5 = () => $$invalidate(0, clicked = "To Kill a Mockingbird");
	const SMUI_action_handler_6 = () => $$invalidate(0, clicked = "The Great Gatsby");
	const SMUI_action_handler_7 = () => $$invalidate(0, clicked = "1984");
	const SMUI_action_handler_8 = () => $$invalidate(0, clicked = "Catch-22");
	const SMUI_action_handler_9 = () => $$invalidate(0, clicked = "Alice's Adventures in Wonderland");

	$$self.$capture_state = () => ({
		List: List$1,
		Group,
		Item,
		Subheader,
		Text,
		clicked
	});

	$$self.$inject_state = $$props => {
		if ("clicked" in $$props) $$invalidate(0, clicked = $$props.clicked);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		clicked,
		SMUI_action_handler,
		SMUI_action_handler_1,
		SMUI_action_handler_2,
		SMUI_action_handler_3,
		SMUI_action_handler_4,
		SMUI_action_handler_5,
		SMUI_action_handler_6,
		SMUI_action_handler_7,
		SMUI_action_handler_8,
		SMUI_action_handler_9
	];
}

class Groups extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3, create_fragment$3, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Groups",
			options,
			id: create_fragment$3.name
		});
	}
}

/* src/routes/demo/list/_Radio.svelte generated by Svelte v3.37.0 */
const file$2 = "src/routes/demo/list/_Radio.svelte";

// (4:6) <Graphic>
function create_default_slot_15$1(ctx) {
	let radio;
	let updating_group;
	let current;

	function radio_group_binding(value) {
		/*radio_group_binding*/ ctx[1](value);
	}

	let radio_props = { value: "Bruce Willis" };

	if (/*selected*/ ctx[0] !== void 0) {
		radio_props.group = /*selected*/ ctx[0];
	}

	radio = new Radio({ props: radio_props, $$inline: true });
	binding_callbacks.push(() => bind(radio, "group", radio_group_binding));

	const block = {
		c: function create() {
			create_component(radio.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(radio.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(radio, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const radio_changes = {};

			if (!updating_group && dirty & /*selected*/ 1) {
				updating_group = true;
				radio_changes.group = /*selected*/ ctx[0];
				add_flush_callback(() => updating_group = false);
			}

			radio.$set(radio_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(radio.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(radio.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(radio, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_15$1.name,
		type: "slot",
		source: "(4:6) <Graphic>",
		ctx
	});

	return block;
}

// (7:6) <Label>
function create_default_slot_14$1(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Bruce Willis");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Bruce Willis");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_14$1.name,
		type: "slot",
		source: "(7:6) <Label>",
		ctx
	});

	return block;
}

// (3:4) <Item>
function create_default_slot_13$1(ctx) {
	let graphic;
	let t;
	let label;
	let current;

	graphic = new Graphic({
			props: {
				$$slots: { default: [create_default_slot_15$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	label = new Label({
			props: {
				$$slots: { default: [create_default_slot_14$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(graphic.$$.fragment);
			t = space();
			create_component(label.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(graphic.$$.fragment, nodes);
			t = claim_space(nodes);
			claim_component(label.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(graphic, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(label, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const graphic_changes = {};

			if (dirty & /*$$scope, selected*/ 65) {
				graphic_changes.$$scope = { dirty, ctx };
			}

			graphic.$set(graphic_changes);
			const label_changes = {};

			if (dirty & /*$$scope*/ 64) {
				label_changes.$$scope = { dirty, ctx };
			}

			label.$set(label_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(graphic.$$.fragment, local);
			transition_in(label.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(graphic.$$.fragment, local);
			transition_out(label.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(graphic, detaching);
			if (detaching) detach_dev(t);
			destroy_component(label, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_13$1.name,
		type: "slot",
		source: "(3:4) <Item>",
		ctx
	});

	return block;
}

// (10:6) <Graphic>
function create_default_slot_12$1(ctx) {
	let radio;
	let updating_group;
	let current;

	function radio_group_binding_1(value) {
		/*radio_group_binding_1*/ ctx[2](value);
	}

	let radio_props = { value: "Tom Hanks" };

	if (/*selected*/ ctx[0] !== void 0) {
		radio_props.group = /*selected*/ ctx[0];
	}

	radio = new Radio({ props: radio_props, $$inline: true });
	binding_callbacks.push(() => bind(radio, "group", radio_group_binding_1));

	const block = {
		c: function create() {
			create_component(radio.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(radio.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(radio, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const radio_changes = {};

			if (!updating_group && dirty & /*selected*/ 1) {
				updating_group = true;
				radio_changes.group = /*selected*/ ctx[0];
				add_flush_callback(() => updating_group = false);
			}

			radio.$set(radio_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(radio.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(radio.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(radio, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_12$1.name,
		type: "slot",
		source: "(10:6) <Graphic>",
		ctx
	});

	return block;
}

// (13:6) <Label>
function create_default_slot_11$1(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Tom Hanks");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Tom Hanks");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_11$1.name,
		type: "slot",
		source: "(13:6) <Label>",
		ctx
	});

	return block;
}

// (9:4) <Item>
function create_default_slot_10$1(ctx) {
	let graphic;
	let t;
	let label;
	let current;

	graphic = new Graphic({
			props: {
				$$slots: { default: [create_default_slot_12$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	label = new Label({
			props: {
				$$slots: { default: [create_default_slot_11$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(graphic.$$.fragment);
			t = space();
			create_component(label.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(graphic.$$.fragment, nodes);
			t = claim_space(nodes);
			claim_component(label.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(graphic, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(label, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const graphic_changes = {};

			if (dirty & /*$$scope, selected*/ 65) {
				graphic_changes.$$scope = { dirty, ctx };
			}

			graphic.$set(graphic_changes);
			const label_changes = {};

			if (dirty & /*$$scope*/ 64) {
				label_changes.$$scope = { dirty, ctx };
			}

			label.$set(label_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(graphic.$$.fragment, local);
			transition_in(label.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(graphic.$$.fragment, local);
			transition_out(label.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(graphic, detaching);
			if (detaching) detach_dev(t);
			destroy_component(label, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_10$1.name,
		type: "slot",
		source: "(9:4) <Item>",
		ctx
	});

	return block;
}

// (16:6) <Graphic>
function create_default_slot_9$1(ctx) {
	let radio;
	let updating_group;
	let current;

	function radio_group_binding_2(value) {
		/*radio_group_binding_2*/ ctx[3](value);
	}

	let radio_props = { value: "Jack Nicholson" };

	if (/*selected*/ ctx[0] !== void 0) {
		radio_props.group = /*selected*/ ctx[0];
	}

	radio = new Radio({ props: radio_props, $$inline: true });
	binding_callbacks.push(() => bind(radio, "group", radio_group_binding_2));

	const block = {
		c: function create() {
			create_component(radio.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(radio.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(radio, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const radio_changes = {};

			if (!updating_group && dirty & /*selected*/ 1) {
				updating_group = true;
				radio_changes.group = /*selected*/ ctx[0];
				add_flush_callback(() => updating_group = false);
			}

			radio.$set(radio_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(radio.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(radio.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(radio, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_9$1.name,
		type: "slot",
		source: "(16:6) <Graphic>",
		ctx
	});

	return block;
}

// (19:6) <Label>
function create_default_slot_8$1(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Jack Nicholson");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Jack Nicholson");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_8$1.name,
		type: "slot",
		source: "(19:6) <Label>",
		ctx
	});

	return block;
}

// (15:4) <Item>
function create_default_slot_7$1(ctx) {
	let graphic;
	let t;
	let label;
	let current;

	graphic = new Graphic({
			props: {
				$$slots: { default: [create_default_slot_9$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	label = new Label({
			props: {
				$$slots: { default: [create_default_slot_8$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(graphic.$$.fragment);
			t = space();
			create_component(label.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(graphic.$$.fragment, nodes);
			t = claim_space(nodes);
			claim_component(label.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(graphic, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(label, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const graphic_changes = {};

			if (dirty & /*$$scope, selected*/ 65) {
				graphic_changes.$$scope = { dirty, ctx };
			}

			graphic.$set(graphic_changes);
			const label_changes = {};

			if (dirty & /*$$scope*/ 64) {
				label_changes.$$scope = { dirty, ctx };
			}

			label.$set(label_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(graphic.$$.fragment, local);
			transition_in(label.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(graphic.$$.fragment, local);
			transition_out(label.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(graphic, detaching);
			if (detaching) detach_dev(t);
			destroy_component(label, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_7$1.name,
		type: "slot",
		source: "(15:4) <Item>",
		ctx
	});

	return block;
}

// (22:6) <Graphic>
function create_default_slot_6$2(ctx) {
	let radio;
	let updating_group;
	let current;

	function radio_group_binding_3(value) {
		/*radio_group_binding_3*/ ctx[4](value);
	}

	let radio_props = { value: "Leonardo DiCaprio" };

	if (/*selected*/ ctx[0] !== void 0) {
		radio_props.group = /*selected*/ ctx[0];
	}

	radio = new Radio({ props: radio_props, $$inline: true });
	binding_callbacks.push(() => bind(radio, "group", radio_group_binding_3));

	const block = {
		c: function create() {
			create_component(radio.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(radio.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(radio, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const radio_changes = {};

			if (!updating_group && dirty & /*selected*/ 1) {
				updating_group = true;
				radio_changes.group = /*selected*/ ctx[0];
				add_flush_callback(() => updating_group = false);
			}

			radio.$set(radio_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(radio.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(radio.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(radio, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_6$2.name,
		type: "slot",
		source: "(22:6) <Graphic>",
		ctx
	});

	return block;
}

// (25:6) <Label>
function create_default_slot_5$2(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Leonardo DiCaprio");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Leonardo DiCaprio");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_5$2.name,
		type: "slot",
		source: "(25:6) <Label>",
		ctx
	});

	return block;
}

// (21:4) <Item>
function create_default_slot_4$2(ctx) {
	let graphic;
	let t;
	let label;
	let current;

	graphic = new Graphic({
			props: {
				$$slots: { default: [create_default_slot_6$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	label = new Label({
			props: {
				$$slots: { default: [create_default_slot_5$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(graphic.$$.fragment);
			t = space();
			create_component(label.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(graphic.$$.fragment, nodes);
			t = claim_space(nodes);
			claim_component(label.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(graphic, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(label, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const graphic_changes = {};

			if (dirty & /*$$scope, selected*/ 65) {
				graphic_changes.$$scope = { dirty, ctx };
			}

			graphic.$set(graphic_changes);
			const label_changes = {};

			if (dirty & /*$$scope*/ 64) {
				label_changes.$$scope = { dirty, ctx };
			}

			label.$set(label_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(graphic.$$.fragment, local);
			transition_in(label.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(graphic.$$.fragment, local);
			transition_out(label.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(graphic, detaching);
			if (detaching) detach_dev(t);
			destroy_component(label, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_4$2.name,
		type: "slot",
		source: "(21:4) <Item>",
		ctx
	});

	return block;
}

// (28:6) <Graphic>
function create_default_slot_3$2(ctx) {
	let radio;
	let updating_group;
	let current;

	function radio_group_binding_4(value) {
		/*radio_group_binding_4*/ ctx[5](value);
	}

	let radio_props = { value: "Matt Damon" };

	if (/*selected*/ ctx[0] !== void 0) {
		radio_props.group = /*selected*/ ctx[0];
	}

	radio = new Radio({ props: radio_props, $$inline: true });
	binding_callbacks.push(() => bind(radio, "group", radio_group_binding_4));

	const block = {
		c: function create() {
			create_component(radio.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(radio.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(radio, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const radio_changes = {};

			if (!updating_group && dirty & /*selected*/ 1) {
				updating_group = true;
				radio_changes.group = /*selected*/ ctx[0];
				add_flush_callback(() => updating_group = false);
			}

			radio.$set(radio_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(radio.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(radio.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(radio, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3$2.name,
		type: "slot",
		source: "(28:6) <Graphic>",
		ctx
	});

	return block;
}

// (31:6) <Label>
function create_default_slot_2$2(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Matt Damon");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Matt Damon");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2$2.name,
		type: "slot",
		source: "(31:6) <Label>",
		ctx
	});

	return block;
}

// (27:4) <Item>
function create_default_slot_1$2(ctx) {
	let graphic;
	let t;
	let label;
	let current;

	graphic = new Graphic({
			props: {
				$$slots: { default: [create_default_slot_3$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	label = new Label({
			props: {
				$$slots: { default: [create_default_slot_2$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(graphic.$$.fragment);
			t = space();
			create_component(label.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(graphic.$$.fragment, nodes);
			t = claim_space(nodes);
			claim_component(label.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(graphic, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(label, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const graphic_changes = {};

			if (dirty & /*$$scope, selected*/ 65) {
				graphic_changes.$$scope = { dirty, ctx };
			}

			graphic.$set(graphic_changes);
			const label_changes = {};

			if (dirty & /*$$scope*/ 64) {
				label_changes.$$scope = { dirty, ctx };
			}

			label.$set(label_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(graphic.$$.fragment, local);
			transition_in(label.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(graphic.$$.fragment, local);
			transition_out(label.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(graphic, detaching);
			if (detaching) detach_dev(t);
			destroy_component(label, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$2.name,
		type: "slot",
		source: "(27:4) <Item>",
		ctx
	});

	return block;
}

// (2:2) <List class="demo-list" radioList>
function create_default_slot$2(ctx) {
	let item0;
	let t0;
	let item1;
	let t1;
	let item2;
	let t2;
	let item3;
	let t3;
	let item4;
	let current;

	item0 = new Item({
			props: {
				$$slots: { default: [create_default_slot_13$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	item1 = new Item({
			props: {
				$$slots: { default: [create_default_slot_10$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	item2 = new Item({
			props: {
				$$slots: { default: [create_default_slot_7$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	item3 = new Item({
			props: {
				$$slots: { default: [create_default_slot_4$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	item4 = new Item({
			props: {
				$$slots: { default: [create_default_slot_1$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(item0.$$.fragment);
			t0 = space();
			create_component(item1.$$.fragment);
			t1 = space();
			create_component(item2.$$.fragment);
			t2 = space();
			create_component(item3.$$.fragment);
			t3 = space();
			create_component(item4.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(item0.$$.fragment, nodes);
			t0 = claim_space(nodes);
			claim_component(item1.$$.fragment, nodes);
			t1 = claim_space(nodes);
			claim_component(item2.$$.fragment, nodes);
			t2 = claim_space(nodes);
			claim_component(item3.$$.fragment, nodes);
			t3 = claim_space(nodes);
			claim_component(item4.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(item0, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(item1, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(item2, target, anchor);
			insert_dev(target, t2, anchor);
			mount_component(item3, target, anchor);
			insert_dev(target, t3, anchor);
			mount_component(item4, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const item0_changes = {};

			if (dirty & /*$$scope, selected*/ 65) {
				item0_changes.$$scope = { dirty, ctx };
			}

			item0.$set(item0_changes);
			const item1_changes = {};

			if (dirty & /*$$scope, selected*/ 65) {
				item1_changes.$$scope = { dirty, ctx };
			}

			item1.$set(item1_changes);
			const item2_changes = {};

			if (dirty & /*$$scope, selected*/ 65) {
				item2_changes.$$scope = { dirty, ctx };
			}

			item2.$set(item2_changes);
			const item3_changes = {};

			if (dirty & /*$$scope, selected*/ 65) {
				item3_changes.$$scope = { dirty, ctx };
			}

			item3.$set(item3_changes);
			const item4_changes = {};

			if (dirty & /*$$scope, selected*/ 65) {
				item4_changes.$$scope = { dirty, ctx };
			}

			item4.$set(item4_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(item0.$$.fragment, local);
			transition_in(item1.$$.fragment, local);
			transition_in(item2.$$.fragment, local);
			transition_in(item3.$$.fragment, local);
			transition_in(item4.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(item0.$$.fragment, local);
			transition_out(item1.$$.fragment, local);
			transition_out(item2.$$.fragment, local);
			transition_out(item3.$$.fragment, local);
			transition_out(item4.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(item0, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(item1, detaching);
			if (detaching) detach_dev(t1);
			destroy_component(item2, detaching);
			if (detaching) detach_dev(t2);
			destroy_component(item3, detaching);
			if (detaching) detach_dev(t3);
			destroy_component(item4, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$2.name,
		type: "slot",
		source: "(2:2) <List class=\\\"demo-list\\\" radioList>",
		ctx
	});

	return block;
}

function create_fragment$2(ctx) {
	let div;
	let list;
	let t0;
	let pre;
	let t1;
	let t2;
	let current;

	list = new List$1({
			props: {
				class: "demo-list",
				radioList: true,
				$$slots: { default: [create_default_slot$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			div = element("div");
			create_component(list.$$.fragment);
			t0 = space();
			pre = element("pre");
			t1 = text("Selected: ");
			t2 = text(/*selected*/ ctx[0]);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			claim_component(list.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			t0 = claim_space(nodes);
			pre = claim_element(nodes, "PRE", { class: true });
			var pre_nodes = children(pre);
			t1 = claim_text(pre_nodes, "Selected: ");
			t2 = claim_text(pre_nodes, /*selected*/ ctx[0]);
			pre_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "svelte-16qb95n");
			add_location(div, file$2, 0, 0, 0);
			attr_dev(pre, "class", "status svelte-16qb95n");
			add_location(pre, file$2, 35, 0, 820);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(list, div, null);
			insert_dev(target, t0, anchor);
			insert_dev(target, pre, anchor);
			append_dev(pre, t1);
			append_dev(pre, t2);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const list_changes = {};

			if (dirty & /*$$scope, selected*/ 65) {
				list_changes.$$scope = { dirty, ctx };
			}

			list.$set(list_changes);
			if (!current || dirty & /*selected*/ 1) set_data_dev(t2, /*selected*/ ctx[0]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(list.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(list.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(list);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(pre);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Radio", slots, []);
	let selected = "Tom Hanks";
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Radio> was created with unknown prop '${key}'`);
	});

	function radio_group_binding(value) {
		selected = value;
		$$invalidate(0, selected);
	}

	function radio_group_binding_1(value) {
		selected = value;
		$$invalidate(0, selected);
	}

	function radio_group_binding_2(value) {
		selected = value;
		$$invalidate(0, selected);
	}

	function radio_group_binding_3(value) {
		selected = value;
		$$invalidate(0, selected);
	}

	function radio_group_binding_4(value) {
		selected = value;
		$$invalidate(0, selected);
	}

	$$self.$capture_state = () => ({
		List: List$1,
		Item,
		Graphic,
		Label,
		Radio,
		selected
	});

	$$self.$inject_state = $$props => {
		if ("selected" in $$props) $$invalidate(0, selected = $$props.selected);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		selected,
		radio_group_binding,
		radio_group_binding_1,
		radio_group_binding_2,
		radio_group_binding_3,
		radio_group_binding_4
	];
}

class Radio_1 extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2, create_fragment$2, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Radio_1",
			options,
			id: create_fragment$2.name
		});
	}
}

/* src/routes/demo/list/_Check.svelte generated by Svelte v3.37.0 */
const file$1 = "src/routes/demo/list/_Check.svelte";

// (4:6) <Label>
function create_default_slot_15(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Bruce Willis");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Bruce Willis");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_15.name,
		type: "slot",
		source: "(4:6) <Label>",
		ctx
	});

	return block;
}

// (5:6) <Meta>
function create_default_slot_14(ctx) {
	let checkbox;
	let updating_group;
	let current;

	function checkbox_group_binding(value) {
		/*checkbox_group_binding*/ ctx[1](value);
	}

	let checkbox_props = { value: "Bruce Willis" };

	if (/*selected*/ ctx[0] !== void 0) {
		checkbox_props.group = /*selected*/ ctx[0];
	}

	checkbox = new Checkbox({ props: checkbox_props, $$inline: true });
	binding_callbacks.push(() => bind(checkbox, "group", checkbox_group_binding));

	const block = {
		c: function create() {
			create_component(checkbox.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(checkbox.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(checkbox, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const checkbox_changes = {};

			if (!updating_group && dirty & /*selected*/ 1) {
				updating_group = true;
				checkbox_changes.group = /*selected*/ ctx[0];
				add_flush_callback(() => updating_group = false);
			}

			checkbox.$set(checkbox_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(checkbox.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(checkbox.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(checkbox, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_14.name,
		type: "slot",
		source: "(5:6) <Meta>",
		ctx
	});

	return block;
}

// (3:4) <Item>
function create_default_slot_13(ctx) {
	let label;
	let t;
	let meta;
	let current;

	label = new Label({
			props: {
				$$slots: { default: [create_default_slot_15] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	meta = new Meta({
			props: {
				$$slots: { default: [create_default_slot_14] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(label.$$.fragment);
			t = space();
			create_component(meta.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(label.$$.fragment, nodes);
			t = claim_space(nodes);
			claim_component(meta.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(label, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(meta, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const label_changes = {};

			if (dirty & /*$$scope*/ 64) {
				label_changes.$$scope = { dirty, ctx };
			}

			label.$set(label_changes);
			const meta_changes = {};

			if (dirty & /*$$scope, selected*/ 65) {
				meta_changes.$$scope = { dirty, ctx };
			}

			meta.$set(meta_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(label.$$.fragment, local);
			transition_in(meta.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(label.$$.fragment, local);
			transition_out(meta.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(label, detaching);
			if (detaching) detach_dev(t);
			destroy_component(meta, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_13.name,
		type: "slot",
		source: "(3:4) <Item>",
		ctx
	});

	return block;
}

// (10:6) <Label>
function create_default_slot_12(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Tom Hanks");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Tom Hanks");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_12.name,
		type: "slot",
		source: "(10:6) <Label>",
		ctx
	});

	return block;
}

// (11:6) <Meta>
function create_default_slot_11(ctx) {
	let checkbox;
	let updating_group;
	let current;

	function checkbox_group_binding_1(value) {
		/*checkbox_group_binding_1*/ ctx[2](value);
	}

	let checkbox_props = { value: "Tom Hanks" };

	if (/*selected*/ ctx[0] !== void 0) {
		checkbox_props.group = /*selected*/ ctx[0];
	}

	checkbox = new Checkbox({ props: checkbox_props, $$inline: true });
	binding_callbacks.push(() => bind(checkbox, "group", checkbox_group_binding_1));

	const block = {
		c: function create() {
			create_component(checkbox.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(checkbox.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(checkbox, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const checkbox_changes = {};

			if (!updating_group && dirty & /*selected*/ 1) {
				updating_group = true;
				checkbox_changes.group = /*selected*/ ctx[0];
				add_flush_callback(() => updating_group = false);
			}

			checkbox.$set(checkbox_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(checkbox.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(checkbox.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(checkbox, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_11.name,
		type: "slot",
		source: "(11:6) <Meta>",
		ctx
	});

	return block;
}

// (9:4) <Item>
function create_default_slot_10(ctx) {
	let label;
	let t;
	let meta;
	let current;

	label = new Label({
			props: {
				$$slots: { default: [create_default_slot_12] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	meta = new Meta({
			props: {
				$$slots: { default: [create_default_slot_11] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(label.$$.fragment);
			t = space();
			create_component(meta.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(label.$$.fragment, nodes);
			t = claim_space(nodes);
			claim_component(meta.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(label, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(meta, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const label_changes = {};

			if (dirty & /*$$scope*/ 64) {
				label_changes.$$scope = { dirty, ctx };
			}

			label.$set(label_changes);
			const meta_changes = {};

			if (dirty & /*$$scope, selected*/ 65) {
				meta_changes.$$scope = { dirty, ctx };
			}

			meta.$set(meta_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(label.$$.fragment, local);
			transition_in(meta.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(label.$$.fragment, local);
			transition_out(meta.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(label, detaching);
			if (detaching) detach_dev(t);
			destroy_component(meta, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_10.name,
		type: "slot",
		source: "(9:4) <Item>",
		ctx
	});

	return block;
}

// (16:6) <Label>
function create_default_slot_9(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Jack Nicholson");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Jack Nicholson");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_9.name,
		type: "slot",
		source: "(16:6) <Label>",
		ctx
	});

	return block;
}

// (17:6) <Meta>
function create_default_slot_8(ctx) {
	let checkbox;
	let updating_group;
	let current;

	function checkbox_group_binding_2(value) {
		/*checkbox_group_binding_2*/ ctx[3](value);
	}

	let checkbox_props = { value: "Jack Nicholson" };

	if (/*selected*/ ctx[0] !== void 0) {
		checkbox_props.group = /*selected*/ ctx[0];
	}

	checkbox = new Checkbox({ props: checkbox_props, $$inline: true });
	binding_callbacks.push(() => bind(checkbox, "group", checkbox_group_binding_2));

	const block = {
		c: function create() {
			create_component(checkbox.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(checkbox.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(checkbox, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const checkbox_changes = {};

			if (!updating_group && dirty & /*selected*/ 1) {
				updating_group = true;
				checkbox_changes.group = /*selected*/ ctx[0];
				add_flush_callback(() => updating_group = false);
			}

			checkbox.$set(checkbox_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(checkbox.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(checkbox.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(checkbox, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_8.name,
		type: "slot",
		source: "(17:6) <Meta>",
		ctx
	});

	return block;
}

// (15:4) <Item>
function create_default_slot_7(ctx) {
	let label;
	let t;
	let meta;
	let current;

	label = new Label({
			props: {
				$$slots: { default: [create_default_slot_9] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	meta = new Meta({
			props: {
				$$slots: { default: [create_default_slot_8] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(label.$$.fragment);
			t = space();
			create_component(meta.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(label.$$.fragment, nodes);
			t = claim_space(nodes);
			claim_component(meta.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(label, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(meta, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const label_changes = {};

			if (dirty & /*$$scope*/ 64) {
				label_changes.$$scope = { dirty, ctx };
			}

			label.$set(label_changes);
			const meta_changes = {};

			if (dirty & /*$$scope, selected*/ 65) {
				meta_changes.$$scope = { dirty, ctx };
			}

			meta.$set(meta_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(label.$$.fragment, local);
			transition_in(meta.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(label.$$.fragment, local);
			transition_out(meta.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(label, detaching);
			if (detaching) detach_dev(t);
			destroy_component(meta, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_7.name,
		type: "slot",
		source: "(15:4) <Item>",
		ctx
	});

	return block;
}

// (22:6) <Label>
function create_default_slot_6$1(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Leonardo DiCaprio");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Leonardo DiCaprio");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_6$1.name,
		type: "slot",
		source: "(22:6) <Label>",
		ctx
	});

	return block;
}

// (23:6) <Meta>
function create_default_slot_5$1(ctx) {
	let checkbox;
	let updating_group;
	let current;

	function checkbox_group_binding_3(value) {
		/*checkbox_group_binding_3*/ ctx[4](value);
	}

	let checkbox_props = { value: "Leonardo DiCaprio" };

	if (/*selected*/ ctx[0] !== void 0) {
		checkbox_props.group = /*selected*/ ctx[0];
	}

	checkbox = new Checkbox({ props: checkbox_props, $$inline: true });
	binding_callbacks.push(() => bind(checkbox, "group", checkbox_group_binding_3));

	const block = {
		c: function create() {
			create_component(checkbox.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(checkbox.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(checkbox, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const checkbox_changes = {};

			if (!updating_group && dirty & /*selected*/ 1) {
				updating_group = true;
				checkbox_changes.group = /*selected*/ ctx[0];
				add_flush_callback(() => updating_group = false);
			}

			checkbox.$set(checkbox_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(checkbox.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(checkbox.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(checkbox, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_5$1.name,
		type: "slot",
		source: "(23:6) <Meta>",
		ctx
	});

	return block;
}

// (21:4) <Item>
function create_default_slot_4$1(ctx) {
	let label;
	let t;
	let meta;
	let current;

	label = new Label({
			props: {
				$$slots: { default: [create_default_slot_6$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	meta = new Meta({
			props: {
				$$slots: { default: [create_default_slot_5$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(label.$$.fragment);
			t = space();
			create_component(meta.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(label.$$.fragment, nodes);
			t = claim_space(nodes);
			claim_component(meta.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(label, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(meta, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const label_changes = {};

			if (dirty & /*$$scope*/ 64) {
				label_changes.$$scope = { dirty, ctx };
			}

			label.$set(label_changes);
			const meta_changes = {};

			if (dirty & /*$$scope, selected*/ 65) {
				meta_changes.$$scope = { dirty, ctx };
			}

			meta.$set(meta_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(label.$$.fragment, local);
			transition_in(meta.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(label.$$.fragment, local);
			transition_out(meta.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(label, detaching);
			if (detaching) detach_dev(t);
			destroy_component(meta, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_4$1.name,
		type: "slot",
		source: "(21:4) <Item>",
		ctx
	});

	return block;
}

// (28:6) <Label>
function create_default_slot_3$1(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Matt Damon");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Matt Damon");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3$1.name,
		type: "slot",
		source: "(28:6) <Label>",
		ctx
	});

	return block;
}

// (29:6) <Meta>
function create_default_slot_2$1(ctx) {
	let checkbox;
	let updating_group;
	let current;

	function checkbox_group_binding_4(value) {
		/*checkbox_group_binding_4*/ ctx[5](value);
	}

	let checkbox_props = { value: "Matt Damon" };

	if (/*selected*/ ctx[0] !== void 0) {
		checkbox_props.group = /*selected*/ ctx[0];
	}

	checkbox = new Checkbox({ props: checkbox_props, $$inline: true });
	binding_callbacks.push(() => bind(checkbox, "group", checkbox_group_binding_4));

	const block = {
		c: function create() {
			create_component(checkbox.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(checkbox.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(checkbox, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const checkbox_changes = {};

			if (!updating_group && dirty & /*selected*/ 1) {
				updating_group = true;
				checkbox_changes.group = /*selected*/ ctx[0];
				add_flush_callback(() => updating_group = false);
			}

			checkbox.$set(checkbox_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(checkbox.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(checkbox.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(checkbox, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2$1.name,
		type: "slot",
		source: "(29:6) <Meta>",
		ctx
	});

	return block;
}

// (27:4) <Item>
function create_default_slot_1$1(ctx) {
	let label;
	let t;
	let meta;
	let current;

	label = new Label({
			props: {
				$$slots: { default: [create_default_slot_3$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	meta = new Meta({
			props: {
				$$slots: { default: [create_default_slot_2$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(label.$$.fragment);
			t = space();
			create_component(meta.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(label.$$.fragment, nodes);
			t = claim_space(nodes);
			claim_component(meta.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(label, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(meta, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const label_changes = {};

			if (dirty & /*$$scope*/ 64) {
				label_changes.$$scope = { dirty, ctx };
			}

			label.$set(label_changes);
			const meta_changes = {};

			if (dirty & /*$$scope, selected*/ 65) {
				meta_changes.$$scope = { dirty, ctx };
			}

			meta.$set(meta_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(label.$$.fragment, local);
			transition_in(meta.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(label.$$.fragment, local);
			transition_out(meta.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(label, detaching);
			if (detaching) detach_dev(t);
			destroy_component(meta, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$1.name,
		type: "slot",
		source: "(27:4) <Item>",
		ctx
	});

	return block;
}

// (2:2) <List class="demo-list" checkList>
function create_default_slot$1(ctx) {
	let item0;
	let t0;
	let item1;
	let t1;
	let item2;
	let t2;
	let item3;
	let t3;
	let item4;
	let current;

	item0 = new Item({
			props: {
				$$slots: { default: [create_default_slot_13] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	item1 = new Item({
			props: {
				$$slots: { default: [create_default_slot_10] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	item2 = new Item({
			props: {
				$$slots: { default: [create_default_slot_7] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	item3 = new Item({
			props: {
				$$slots: { default: [create_default_slot_4$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	item4 = new Item({
			props: {
				$$slots: { default: [create_default_slot_1$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(item0.$$.fragment);
			t0 = space();
			create_component(item1.$$.fragment);
			t1 = space();
			create_component(item2.$$.fragment);
			t2 = space();
			create_component(item3.$$.fragment);
			t3 = space();
			create_component(item4.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(item0.$$.fragment, nodes);
			t0 = claim_space(nodes);
			claim_component(item1.$$.fragment, nodes);
			t1 = claim_space(nodes);
			claim_component(item2.$$.fragment, nodes);
			t2 = claim_space(nodes);
			claim_component(item3.$$.fragment, nodes);
			t3 = claim_space(nodes);
			claim_component(item4.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(item0, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(item1, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(item2, target, anchor);
			insert_dev(target, t2, anchor);
			mount_component(item3, target, anchor);
			insert_dev(target, t3, anchor);
			mount_component(item4, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const item0_changes = {};

			if (dirty & /*$$scope, selected*/ 65) {
				item0_changes.$$scope = { dirty, ctx };
			}

			item0.$set(item0_changes);
			const item1_changes = {};

			if (dirty & /*$$scope, selected*/ 65) {
				item1_changes.$$scope = { dirty, ctx };
			}

			item1.$set(item1_changes);
			const item2_changes = {};

			if (dirty & /*$$scope, selected*/ 65) {
				item2_changes.$$scope = { dirty, ctx };
			}

			item2.$set(item2_changes);
			const item3_changes = {};

			if (dirty & /*$$scope, selected*/ 65) {
				item3_changes.$$scope = { dirty, ctx };
			}

			item3.$set(item3_changes);
			const item4_changes = {};

			if (dirty & /*$$scope, selected*/ 65) {
				item4_changes.$$scope = { dirty, ctx };
			}

			item4.$set(item4_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(item0.$$.fragment, local);
			transition_in(item1.$$.fragment, local);
			transition_in(item2.$$.fragment, local);
			transition_in(item3.$$.fragment, local);
			transition_in(item4.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(item0.$$.fragment, local);
			transition_out(item1.$$.fragment, local);
			transition_out(item2.$$.fragment, local);
			transition_out(item3.$$.fragment, local);
			transition_out(item4.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(item0, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(item1, detaching);
			if (detaching) detach_dev(t1);
			destroy_component(item2, detaching);
			if (detaching) detach_dev(t2);
			destroy_component(item3, detaching);
			if (detaching) detach_dev(t3);
			destroy_component(item4, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$1.name,
		type: "slot",
		source: "(2:2) <List class=\\\"demo-list\\\" checkList>",
		ctx
	});

	return block;
}

function create_fragment$1(ctx) {
	let div;
	let list;
	let t0;
	let pre;
	let t1;
	let t2_value = /*selected*/ ctx[0].join(", ") + "";
	let t2;
	let current;

	list = new List$1({
			props: {
				class: "demo-list",
				checkList: true,
				$$slots: { default: [create_default_slot$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			div = element("div");
			create_component(list.$$.fragment);
			t0 = space();
			pre = element("pre");
			t1 = text("Selected: ");
			t2 = text(t2_value);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			claim_component(list.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			t0 = claim_space(nodes);
			pre = claim_element(nodes, "PRE", { class: true });
			var pre_nodes = children(pre);
			t1 = claim_text(pre_nodes, "Selected: ");
			t2 = claim_text(pre_nodes, t2_value);
			pre_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "svelte-16qb95n");
			add_location(div, file$1, 0, 0, 0);
			attr_dev(pre, "class", "status svelte-16qb95n");
			add_location(pre, file$1, 35, 0, 805);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(list, div, null);
			insert_dev(target, t0, anchor);
			insert_dev(target, pre, anchor);
			append_dev(pre, t1);
			append_dev(pre, t2);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const list_changes = {};

			if (dirty & /*$$scope, selected*/ 65) {
				list_changes.$$scope = { dirty, ctx };
			}

			list.$set(list_changes);
			if ((!current || dirty & /*selected*/ 1) && t2_value !== (t2_value = /*selected*/ ctx[0].join(", ") + "")) set_data_dev(t2, t2_value);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(list.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(list.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(list);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(pre);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Check", slots, []);
	let selected = ["Tom Hanks"];
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Check> was created with unknown prop '${key}'`);
	});

	function checkbox_group_binding(value) {
		selected = value;
		$$invalidate(0, selected);
	}

	function checkbox_group_binding_1(value) {
		selected = value;
		$$invalidate(0, selected);
	}

	function checkbox_group_binding_2(value) {
		selected = value;
		$$invalidate(0, selected);
	}

	function checkbox_group_binding_3(value) {
		selected = value;
		$$invalidate(0, selected);
	}

	function checkbox_group_binding_4(value) {
		selected = value;
		$$invalidate(0, selected);
	}

	$$self.$capture_state = () => ({
		List: List$1,
		Item,
		Meta,
		Label,
		Checkbox,
		selected
	});

	$$self.$inject_state = $$props => {
		if ("selected" in $$props) $$invalidate(0, selected = $$props.selected);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		selected,
		checkbox_group_binding,
		checkbox_group_binding_1,
		checkbox_group_binding_2,
		checkbox_group_binding_3,
		checkbox_group_binding_4
	];
}

class Check extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$1, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Check",
			options,
			id: create_fragment$1.name
		});
	}
}

/* src/routes/demo/list/index.svelte generated by Svelte v3.37.0 */
const file = "src/routes/demo/list/index.svelte";

// (12:2) <Demo component={GraphicsDense} file="list/_GraphicsDense.svelte">
function create_default_slot_6(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("A dense list with graphics");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "A dense list with graphics");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_6.name,
		type: "slot",
		source: "(12:2) <Demo component={GraphicsDense} file=\\\"list/_GraphicsDense.svelte\\\">",
		ctx
	});

	return block;
}

// (16:2) <Demo component={NonInteractive} file="list/_NonInteractive.svelte">
function create_default_slot_5(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("A non-interactive list with activated item");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "A non-interactive list with activated item");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_5.name,
		type: "slot",
		source: "(16:2) <Demo component={NonInteractive} file=\\\"list/_NonInteractive.svelte\\\">",
		ctx
	});

	return block;
}

// (20:2) <Demo component={TwoLineSelection} file="list/_TwoLineSelection.svelte">
function create_default_slot_4(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("A two-line single selection list with avatars, disabled item, and meta");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "A two-line single selection list with avatars, disabled item, and meta");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_4.name,
		type: "slot",
		source: "(20:2) <Demo component={TwoLineSelection} file=\\\"list/_TwoLineSelection.svelte\\\">",
		ctx
	});

	return block;
}

// (24:2) <Demo component={ThreeLine} file="list/_ThreeLine.svelte">
function create_default_slot_3(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("A three-line list");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "A three-line list");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3.name,
		type: "slot",
		source: "(24:2) <Demo component={ThreeLine} file=\\\"list/_ThreeLine.svelte\\\">",
		ctx
	});

	return block;
}

// (28:2) <Demo component={Groups} file="list/_Groups.svelte">
function create_default_slot_2(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("A list group");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "A list group");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2.name,
		type: "slot",
		source: "(28:2) <Demo component={Groups} file=\\\"list/_Groups.svelte\\\">",
		ctx
	});

	return block;
}

// (30:2) <Demo component={Radio} file="list/_Radio.svelte">
function create_default_slot_1(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("A radio list");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "A radio list");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1.name,
		type: "slot",
		source: "(30:2) <Demo component={Radio} file=\\\"list/_Radio.svelte\\\">",
		ctx
	});

	return block;
}

// (32:2) <Demo component={Check} file="list/_Check.svelte">
function create_default_slot(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("A check list with trailing checkboxes");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "A check list with trailing checkboxes");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(32:2) <Demo component={Check} file=\\\"list/_Check.svelte\\\">",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let t0;
	let section;
	let h2;
	let t1;
	let t2;
	let pre;
	let t3;
	let t4;
	let demo0;
	let t5;
	let demo1;
	let t6;
	let demo2;
	let t7;
	let demo3;
	let t8;
	let demo4;
	let t9;
	let demo5;
	let t10;
	let demo6;
	let t11;
	let demo7;
	let current;

	demo0 = new Demo({
			props: {
				component: Simple,
				file: "list/_Simple.svelte"
			},
			$$inline: true
		});

	demo1 = new Demo({
			props: {
				component: GraphicsDense,
				file: "list/_GraphicsDense.svelte",
				$$slots: { default: [create_default_slot_6] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	demo2 = new Demo({
			props: {
				component: NonInteractive,
				file: "list/_NonInteractive.svelte",
				$$slots: { default: [create_default_slot_5] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	demo3 = new Demo({
			props: {
				component: TwoLineSelection,
				file: "list/_TwoLineSelection.svelte",
				$$slots: { default: [create_default_slot_4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	demo4 = new Demo({
			props: {
				component: ThreeLine,
				file: "list/_ThreeLine.svelte",
				$$slots: { default: [create_default_slot_3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	demo5 = new Demo({
			props: {
				component: Groups,
				file: "list/_Groups.svelte",
				$$slots: { default: [create_default_slot_2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	demo6 = new Demo({
			props: {
				component: Radio_1,
				file: "list/_Radio.svelte",
				$$slots: { default: [create_default_slot_1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	demo7 = new Demo({
			props: {
				component: Check,
				file: "list/_Check.svelte",
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			t0 = space();
			section = element("section");
			h2 = element("h2");
			t1 = text("Lists");
			t2 = space();
			pre = element("pre");
			t3 = text("npm i -D @smui/list");
			t4 = space();
			create_component(demo0.$$.fragment);
			t5 = space();
			create_component(demo1.$$.fragment);
			t6 = space();
			create_component(demo2.$$.fragment);
			t7 = space();
			create_component(demo3.$$.fragment);
			t8 = space();
			create_component(demo4.$$.fragment);
			t9 = space();
			create_component(demo5.$$.fragment);
			t10 = space();
			create_component(demo6.$$.fragment);
			t11 = space();
			create_component(demo7.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			const head_nodes = query_selector_all("[data-svelte=\"svelte-5jk5wx\"]", document.head);
			head_nodes.forEach(detach_dev);
			t0 = claim_space(nodes);
			section = claim_element(nodes, "SECTION", {});
			var section_nodes = children(section);
			h2 = claim_element(section_nodes, "H2", {});
			var h2_nodes = children(h2);
			t1 = claim_text(h2_nodes, "Lists");
			h2_nodes.forEach(detach_dev);
			t2 = claim_space(section_nodes);
			pre = claim_element(section_nodes, "PRE", { class: true });
			var pre_nodes = children(pre);
			t3 = claim_text(pre_nodes, "npm i -D @smui/list");
			pre_nodes.forEach(detach_dev);
			t4 = claim_space(section_nodes);
			claim_component(demo0.$$.fragment, section_nodes);
			t5 = claim_space(section_nodes);
			claim_component(demo1.$$.fragment, section_nodes);
			t6 = claim_space(section_nodes);
			claim_component(demo2.$$.fragment, section_nodes);
			t7 = claim_space(section_nodes);
			claim_component(demo3.$$.fragment, section_nodes);
			t8 = claim_space(section_nodes);
			claim_component(demo4.$$.fragment, section_nodes);
			t9 = claim_space(section_nodes);
			claim_component(demo5.$$.fragment, section_nodes);
			t10 = claim_space(section_nodes);
			claim_component(demo6.$$.fragment, section_nodes);
			t11 = claim_space(section_nodes);
			claim_component(demo7.$$.fragment, section_nodes);
			section_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			document.title = "Lists - SMUI";
			add_location(h2, file, 5, 2, 72);
			attr_dev(pre, "class", "demo-spaced");
			add_location(pre, file, 7, 2, 90);
			add_location(section, file, 4, 0, 60);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			insert_dev(target, section, anchor);
			append_dev(section, h2);
			append_dev(h2, t1);
			append_dev(section, t2);
			append_dev(section, pre);
			append_dev(pre, t3);
			append_dev(section, t4);
			mount_component(demo0, section, null);
			append_dev(section, t5);
			mount_component(demo1, section, null);
			append_dev(section, t6);
			mount_component(demo2, section, null);
			append_dev(section, t7);
			mount_component(demo3, section, null);
			append_dev(section, t8);
			mount_component(demo4, section, null);
			append_dev(section, t9);
			mount_component(demo5, section, null);
			append_dev(section, t10);
			mount_component(demo6, section, null);
			append_dev(section, t11);
			mount_component(demo7, section, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const demo1_changes = {};

			if (dirty & /*$$scope*/ 1) {
				demo1_changes.$$scope = { dirty, ctx };
			}

			demo1.$set(demo1_changes);
			const demo2_changes = {};

			if (dirty & /*$$scope*/ 1) {
				demo2_changes.$$scope = { dirty, ctx };
			}

			demo2.$set(demo2_changes);
			const demo3_changes = {};

			if (dirty & /*$$scope*/ 1) {
				demo3_changes.$$scope = { dirty, ctx };
			}

			demo3.$set(demo3_changes);
			const demo4_changes = {};

			if (dirty & /*$$scope*/ 1) {
				demo4_changes.$$scope = { dirty, ctx };
			}

			demo4.$set(demo4_changes);
			const demo5_changes = {};

			if (dirty & /*$$scope*/ 1) {
				demo5_changes.$$scope = { dirty, ctx };
			}

			demo5.$set(demo5_changes);
			const demo6_changes = {};

			if (dirty & /*$$scope*/ 1) {
				demo6_changes.$$scope = { dirty, ctx };
			}

			demo6.$set(demo6_changes);
			const demo7_changes = {};

			if (dirty & /*$$scope*/ 1) {
				demo7_changes.$$scope = { dirty, ctx };
			}

			demo7.$set(demo7_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(demo0.$$.fragment, local);
			transition_in(demo1.$$.fragment, local);
			transition_in(demo2.$$.fragment, local);
			transition_in(demo3.$$.fragment, local);
			transition_in(demo4.$$.fragment, local);
			transition_in(demo5.$$.fragment, local);
			transition_in(demo6.$$.fragment, local);
			transition_in(demo7.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(demo0.$$.fragment, local);
			transition_out(demo1.$$.fragment, local);
			transition_out(demo2.$$.fragment, local);
			transition_out(demo3.$$.fragment, local);
			transition_out(demo4.$$.fragment, local);
			transition_out(demo5.$$.fragment, local);
			transition_out(demo6.$$.fragment, local);
			transition_out(demo7.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(section);
			destroy_component(demo0);
			destroy_component(demo1);
			destroy_component(demo2);
			destroy_component(demo3);
			destroy_component(demo4);
			destroy_component(demo5);
			destroy_component(demo6);
			destroy_component(demo7);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("List", slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<List> was created with unknown prop '${key}'`);
	});

	$$self.$capture_state = () => ({
		Demo,
		Simple,
		GraphicsDense,
		NonInteractive,
		TwoLineSelection,
		ThreeLine,
		Groups,
		Radio: Radio_1,
		Check
	});

	return [];
}

class List extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "List",
			options,
			id: create_fragment.name
		});
	}
}

export default List;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguNzMyYTE4MzguanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3BhY2thZ2VzL2xpc3QvTGFiZWwuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL3JvdXRlcy9kZW1vL2xpc3QvX1NpbXBsZS5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvcm91dGVzL2RlbW8vbGlzdC9fR3JhcGhpY3NEZW5zZS5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvcm91dGVzL2RlbW8vbGlzdC9fVHdvTGluZVNlbGVjdGlvbi5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvcm91dGVzL2RlbW8vbGlzdC9fR3JvdXBzLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9yb3V0ZXMvZGVtby9saXN0L19SYWRpby5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvcm91dGVzL2RlbW8vbGlzdC9fQ2hlY2suc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL3JvdXRlcy9kZW1vL2xpc3QvaW5kZXguc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbIjxsYWJlbFxuICBiaW5kOnRoaXM9e2VsZW1lbnR9XG4gIHVzZTp1c2VBY3Rpb25zPXt1c2V9XG4gIHVzZTpmb3J3YXJkRXZlbnRzXG4gIGNsYXNzPXtjbGFzc01hcCh7XG4gICAgW2NsYXNzTmFtZV06IHRydWUsXG4gICAgJ21kYy1kZXByZWNhdGVkLWxpc3QtaXRlbV9fdGV4dCc6IHRydWUsXG4gIH0pfVxuICBmb3I9e2lucHV0UHJvcHMgPyBpbnB1dFByb3BzLmlkIDogbnVsbH1cbiAgey4uLiQkcmVzdFByb3BzfT48c2xvdCAvPjwvbGFiZWxcbj5cblxuPHNjcmlwdD5cbiAgaW1wb3J0IHsgZ2V0Q29udGV4dCB9IGZyb20gJ3N2ZWx0ZSc7XG4gIGltcG9ydCB7IGdldF9jdXJyZW50X2NvbXBvbmVudCB9IGZyb20gJ3N2ZWx0ZS9pbnRlcm5hbCc7XG4gIGltcG9ydCB7XG4gICAgZm9yd2FyZEV2ZW50c0J1aWxkZXIsXG4gICAgY2xhc3NNYXAsXG4gICAgdXNlQWN0aW9ucyxcbiAgfSBmcm9tICdAc211aS9jb21tb24vaW50ZXJuYWwuanMnO1xuXG4gIGNvbnN0IGZvcndhcmRFdmVudHMgPSBmb3J3YXJkRXZlbnRzQnVpbGRlcihnZXRfY3VycmVudF9jb21wb25lbnQoKSk7XG5cbiAgZXhwb3J0IGxldCB1c2UgPSBbXTtcbiAgbGV0IGNsYXNzTmFtZSA9ICcnO1xuICBleHBvcnQgeyBjbGFzc05hbWUgYXMgY2xhc3MgfTtcblxuICBsZXQgZWxlbWVudDtcbiAgbGV0IGlucHV0UHJvcHMgPSBnZXRDb250ZXh0KCdTTVVJOmdlbmVyaWM6aW5wdXQ6cHJvcHMnKSB8fCB7fTtcblxuICBleHBvcnQgZnVuY3Rpb24gZ2V0RWxlbWVudCgpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuPC9zY3JpcHQ+XG4iLCI8ZGl2PlxuICA8TGlzdCBjbGFzcz1cImRlbW8tbGlzdFwiPlxuICAgIDxJdGVtIG9uOlNNVUk6YWN0aW9uPXsoKSA9PiAoY2xpY2tlZCA9ICdDdXQnKX0+PFRleHQ+Q3V0PC9UZXh0PjwvSXRlbT5cbiAgICA8SXRlbSBvbjpTTVVJOmFjdGlvbj17KCkgPT4gKGNsaWNrZWQgPSAnQ29weScpfT48VGV4dD5Db3B5PC9UZXh0PjwvSXRlbT5cbiAgICA8SXRlbSBvbjpTTVVJOmFjdGlvbj17KCkgPT4gKGNsaWNrZWQgPSAnUGFzdGUnKX0+PFRleHQ+UGFzdGU8L1RleHQ+PC9JdGVtPlxuICAgIDxTZXBhcmF0b3IgLz5cbiAgICA8SXRlbSBvbjpTTVVJOmFjdGlvbj17KCkgPT4gKGNsaWNrZWQgPSAnRGVsZXRlJyl9PjxUZXh0PkRlbGV0ZTwvVGV4dD48L0l0ZW0+XG4gIDwvTGlzdD5cbjwvZGl2PlxuXG48cHJlIGNsYXNzPVwic3RhdHVzXCI+Q2xpY2tlZDoge2NsaWNrZWR9PC9wcmU+XG5cbjxzY3JpcHQ+XG4gIGltcG9ydCBMaXN0LCB7IEl0ZW0sIFNlcGFyYXRvciwgVGV4dCB9IGZyb20gJ0BzbXVpL2xpc3QnO1xuXG4gIGxldCBjbGlja2VkID0gJ25vdGhpbmcgeWV0Jztcbjwvc2NyaXB0PlxuXG48c3R5bGU+XG4gICogOmdsb2JhbCguZGVtby1saXN0KSB7XG4gICAgbWF4LXdpZHRoOiA2MDBweDtcbiAgICBib3JkZXI6IDFweCBzb2xpZFxuICAgICAgdmFyKC0tbWRjLXRoZW1lLXRleHQtaGludC1vbi1iYWNrZ3JvdW5kLCByZ2JhKDAsIDAsIDAsIDAuMSkpO1xuICB9XG48L3N0eWxlPlxuIiwiPGRpdj5cbiAgPExpc3QgY2xhc3M9XCJkZW1vLWxpc3RcIiBkZW5zZT5cbiAgICA8SXRlbSBvbjpTTVVJOmFjdGlvbj17KCkgPT4gKGNsaWNrZWQgPSAnRWRpdCcpfT5cbiAgICAgIDxHcmFwaGljIGNsYXNzPVwibWF0ZXJpYWwtaWNvbnNcIj5lZGl0PC9HcmFwaGljPlxuICAgICAgPFRleHQ+RWRpdDwvVGV4dD5cbiAgICA8L0l0ZW0+XG4gICAgPEl0ZW0gb246U01VSTphY3Rpb249eygpID0+IChjbGlja2VkID0gJ1NlbmQnKX0+XG4gICAgICA8R3JhcGhpYyBjbGFzcz1cIm1hdGVyaWFsLWljb25zXCI+c2VuZDwvR3JhcGhpYz5cbiAgICAgIDxUZXh0PlNlbmQ8L1RleHQ+XG4gICAgPC9JdGVtPlxuICAgIDxJdGVtIG9uOlNNVUk6YWN0aW9uPXsoKSA9PiAoY2xpY2tlZCA9ICdBcmNoaXZlJyl9PlxuICAgICAgPEdyYXBoaWMgY2xhc3M9XCJtYXRlcmlhbC1pY29uc1wiPmFyY2hpdmU8L0dyYXBoaWM+XG4gICAgICA8VGV4dD5BcmNoaXZlPC9UZXh0PlxuICAgIDwvSXRlbT5cbiAgICA8U2VwYXJhdG9yIC8+XG4gICAgPEl0ZW0gb246U01VSTphY3Rpb249eygpID0+IChjbGlja2VkID0gJ0RlbGV0ZScpfT5cbiAgICAgIDxHcmFwaGljIGNsYXNzPVwibWF0ZXJpYWwtaWNvbnNcIj5jbGVhcjwvR3JhcGhpYz5cbiAgICAgIDxUZXh0PkRlbGV0ZTwvVGV4dD5cbiAgICA8L0l0ZW0+XG4gIDwvTGlzdD5cbjwvZGl2PlxuXG48cHJlIGNsYXNzPVwic3RhdHVzXCI+Q2xpY2tlZDoge2NsaWNrZWR9PC9wcmU+XG5cbjxzY3JpcHQ+XG4gIGltcG9ydCBMaXN0LCB7IEl0ZW0sIEdyYXBoaWMsIFNlcGFyYXRvciwgVGV4dCB9IGZyb20gJ0BzbXVpL2xpc3QnO1xuXG4gIGxldCBjbGlja2VkID0gJ25vdGhpbmcgeWV0Jztcbjwvc2NyaXB0PlxuXG48c3R5bGU+XG4gICogOmdsb2JhbCguZGVtby1saXN0KSB7XG4gICAgbWF4LXdpZHRoOiA2MDBweDtcbiAgICBib3JkZXI6IDFweCBzb2xpZFxuICAgICAgdmFyKC0tbWRjLXRoZW1lLXRleHQtaGludC1vbi1iYWNrZ3JvdW5kLCByZ2JhKDAsIDAsIDAsIDAuMSkpO1xuICB9XG48L3N0eWxlPlxuIiwiPGRpdj5cbiAgPExpc3RcbiAgICBjbGFzcz1cImRlbW8tbGlzdFwiXG4gICAgdHdvTGluZVxuICAgIGF2YXRhckxpc3RcbiAgICBzaW5nbGVTZWxlY3Rpb25cbiAgICBiaW5kOnNlbGVjdGVkSW5kZXg9e3NlbGVjdGlvbkluZGV4fVxuICA+XG4gICAgeyNlYWNoIG9wdGlvbnMgYXMgaXRlbX1cbiAgICAgIDxJdGVtXG4gICAgICAgIG9uOlNNVUk6YWN0aW9uPXsoKSA9PiAoc2VsZWN0aW9uID0gaXRlbS5uYW1lKX1cbiAgICAgICAgZGlzYWJsZWQ9e2l0ZW0uZGlzYWJsZWR9XG4gICAgICAgIHNlbGVjdGVkPXtzZWxlY3Rpb24gPT09IGl0ZW0ubmFtZX1cbiAgICAgID5cbiAgICAgICAgPEdyYXBoaWNcbiAgICAgICAgICBzdHlsZT1cImJhY2tncm91bmQtaW1hZ2U6IHVybChodHRwczovL3BsYWNlLWhvbGQuaXQvNDB4NDA/dGV4dD17aXRlbS5uYW1lXG4gICAgICAgICAgICAuc3BsaXQoJyAnKVxuICAgICAgICAgICAgLm1hcCgodmFsKSA9PiB2YWwuc3Vic3RyaW5nKDAsIDEpKVxuICAgICAgICAgICAgLmpvaW4oJycpfSZmb250c2l6ZT0xNik7XCJcbiAgICAgICAgLz5cbiAgICAgICAgPFRleHQ+XG4gICAgICAgICAgPFByaW1hcnlUZXh0PntpdGVtLm5hbWV9PC9QcmltYXJ5VGV4dD5cbiAgICAgICAgICA8U2Vjb25kYXJ5VGV4dD57aXRlbS5kZXNjcmlwdGlvbn08L1NlY29uZGFyeVRleHQ+XG4gICAgICAgIDwvVGV4dD5cbiAgICAgICAgPE1ldGEgY2xhc3M9XCJtYXRlcmlhbC1pY29uc1wiPmluZm88L01ldGE+XG4gICAgICA8L0l0ZW0+XG4gICAgey9lYWNofVxuICA8L0xpc3Q+XG48L2Rpdj5cblxuPHByZVxuICBjbGFzcz1cInN0YXR1c1wiPlNlbGVjdGVkOiB7c2VsZWN0aW9ufSwgdmFsdWUgb2Ygc2VsZWN0ZWRJbmRleDoge3NlbGVjdGlvbkluZGV4fTwvcHJlPlxuXG48c2NyaXB0PlxuICBpbXBvcnQgTGlzdCwge1xuICAgIEl0ZW0sXG4gICAgR3JhcGhpYyxcbiAgICBNZXRhLFxuICAgIFRleHQsXG4gICAgUHJpbWFyeVRleHQsXG4gICAgU2Vjb25kYXJ5VGV4dCxcbiAgfSBmcm9tICdAc211aS9saXN0JztcblxuICBsZXQgb3B0aW9ucyA9IFtcbiAgICB7XG4gICAgICBuYW1lOiAnQnJ1Y2UgV2lsbGlzJyxcbiAgICAgIGRlc2NyaXB0aW9uOiAnQWN0b3InLFxuICAgICAgZGlzYWJsZWQ6IGZhbHNlLFxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ0F1c3RpbiBQb3dlcnMnLFxuICAgICAgZGVzY3JpcHRpb246ICdGaWN0aW9uYWwgQ2hhcmFjdGVyJyxcbiAgICAgIGRpc2FibGVkOiB0cnVlLFxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ1Rob21hcyBFZGlzb24nLFxuICAgICAgZGVzY3JpcHRpb246ICdJbnZlbnRvcicsXG4gICAgICBkaXNhYmxlZDogZmFsc2UsXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnU3RlcGhlbiBIYXdraW5nJyxcbiAgICAgIGRlc2NyaXB0aW9uOiAnU2NpZW50aXN0JyxcbiAgICAgIGRpc2FibGVkOiBmYWxzZSxcbiAgICB9LFxuICBdO1xuICBsZXQgc2VsZWN0aW9uID0gJ1N0ZXBoZW4gSGF3a2luZyc7XG4gIC8vIFRoaXMgdmFsdWUgaXMgdXBkYXRlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgaW5pdGlhbGl6ZWQsIGJhc2VkIG9uIHRoZVxuICAvLyBzZWxlY3RlZCBJdGVtJ3MgYHNlbGVjdGVkYCBwcm9wLlxuICBsZXQgc2VsZWN0aW9uSW5kZXggPSBudWxsO1xuPC9zY3JpcHQ+XG5cbjxzdHlsZT5cbiAgKiA6Z2xvYmFsKC5kZW1vLWxpc3QpIHtcbiAgICBtYXgtd2lkdGg6IDYwMHB4O1xuICAgIGJvcmRlcjogMXB4IHNvbGlkXG4gICAgICB2YXIoLS1tZGMtdGhlbWUtdGV4dC1oaW50LW9uLWJhY2tncm91bmQsIHJnYmEoMCwgMCwgMCwgMC4xKSk7XG4gIH1cbjwvc3R5bGU+XG4iLCI8ZGl2PlxuICA8R3JvdXA+XG4gICAgPFN1YmhlYWRlcj5BY3RvcnM8L1N1YmhlYWRlcj5cbiAgICA8TGlzdCBjbGFzcz1cImRlbW8tbGlzdFwiPlxuICAgICAgPEl0ZW0gb246U01VSTphY3Rpb249eygpID0+IChjbGlja2VkID0gJ0JydWNlIFdpbGxpcycpfT5cbiAgICAgICAgPFRleHQ+QnJ1Y2UgV2lsbGlzPC9UZXh0PlxuICAgICAgPC9JdGVtPlxuICAgICAgPEl0ZW0gb246U01VSTphY3Rpb249eygpID0+IChjbGlja2VkID0gJ1RvbSBIYW5rcycpfT5cbiAgICAgICAgPFRleHQ+VG9tIEhhbmtzPC9UZXh0PlxuICAgICAgPC9JdGVtPlxuICAgICAgPEl0ZW0gb246U01VSTphY3Rpb249eygpID0+IChjbGlja2VkID0gJ0phY2sgTmljaG9sc29uJyl9PlxuICAgICAgICA8VGV4dD5KYWNrIE5pY2hvbHNvbjwvVGV4dD5cbiAgICAgIDwvSXRlbT5cbiAgICAgIDxJdGVtIG9uOlNNVUk6YWN0aW9uPXsoKSA9PiAoY2xpY2tlZCA9ICdMZW9uYXJkbyBEaUNhcHJpbycpfT5cbiAgICAgICAgPFRleHQ+TGVvbmFyZG8gRGlDYXByaW88L1RleHQ+XG4gICAgICA8L0l0ZW0+XG4gICAgICA8SXRlbSBvbjpTTVVJOmFjdGlvbj17KCkgPT4gKGNsaWNrZWQgPSAnTWF0dCBEYW1vbicpfT5cbiAgICAgICAgPFRleHQ+TWF0dCBEYW1vbjwvVGV4dD5cbiAgICAgIDwvSXRlbT5cbiAgICA8L0xpc3Q+XG4gICAgPFN1YmhlYWRlcj5Cb29rczwvU3ViaGVhZGVyPlxuICAgIDxMaXN0IGNsYXNzPVwiZGVtby1saXN0XCI+XG4gICAgICA8SXRlbSBvbjpTTVVJOmFjdGlvbj17KCkgPT4gKGNsaWNrZWQgPSAnVG8gS2lsbCBhIE1vY2tpbmdiaXJkJyl9PlxuICAgICAgICA8VGV4dD5UbyBLaWxsIGEgTW9ja2luZ2JpcmQ8L1RleHQ+XG4gICAgICA8L0l0ZW0+XG4gICAgICA8SXRlbSBvbjpTTVVJOmFjdGlvbj17KCkgPT4gKGNsaWNrZWQgPSAnVGhlIEdyZWF0IEdhdHNieScpfT5cbiAgICAgICAgPFRleHQ+VGhlIEdyZWF0IEdhdHNieTwvVGV4dD5cbiAgICAgIDwvSXRlbT5cbiAgICAgIDxJdGVtIG9uOlNNVUk6YWN0aW9uPXsoKSA9PiAoY2xpY2tlZCA9ICcxOTg0Jyl9PlxuICAgICAgICA8VGV4dD4xOTg0PC9UZXh0PlxuICAgICAgPC9JdGVtPlxuICAgICAgPEl0ZW0gb246U01VSTphY3Rpb249eygpID0+IChjbGlja2VkID0gJ0NhdGNoLTIyJyl9PlxuICAgICAgICA8VGV4dD5DYXRjaC0yMjwvVGV4dD5cbiAgICAgIDwvSXRlbT5cbiAgICAgIDxJdGVtXG4gICAgICAgIG9uOlNNVUk6YWN0aW9uPXsoKSA9PiAoY2xpY2tlZCA9IFwiQWxpY2UncyBBZHZlbnR1cmVzIGluIFdvbmRlcmxhbmRcIil9XG4gICAgICA+XG4gICAgICAgIDxUZXh0PkFsaWNlJ3MgQWR2ZW50dXJlcyBpbiBXb25kZXJsYW5kPC9UZXh0PlxuICAgICAgPC9JdGVtPlxuICAgIDwvTGlzdD5cbiAgPC9Hcm91cD5cbjwvZGl2PlxuXG48cHJlIGNsYXNzPVwic3RhdHVzXCI+Q2xpY2tlZDoge2NsaWNrZWR9PC9wcmU+XG5cbjxzY3JpcHQ+XG4gIGltcG9ydCBMaXN0LCB7IEdyb3VwLCBJdGVtLCBTdWJoZWFkZXIsIFRleHQgfSBmcm9tICdAc211aS9saXN0JztcblxuICBsZXQgY2xpY2tlZCA9ICdub3RoaW5nIHlldCc7XG48L3NjcmlwdD5cblxuPHN0eWxlPlxuICAqIDpnbG9iYWwoLmRlbW8tbGlzdCkge1xuICAgIG1heC13aWR0aDogNjAwcHg7XG4gICAgYm9yZGVyOiAxcHggc29saWRcbiAgICAgIHZhcigtLW1kYy10aGVtZS10ZXh0LWhpbnQtb24tYmFja2dyb3VuZCwgcmdiYSgwLCAwLCAwLCAwLjEpKTtcbiAgfVxuPC9zdHlsZT5cbiIsIjxkaXY+XG4gIDxMaXN0IGNsYXNzPVwiZGVtby1saXN0XCIgcmFkaW9MaXN0PlxuICAgIDxJdGVtPlxuICAgICAgPEdyYXBoaWM+XG4gICAgICAgIDxSYWRpbyBiaW5kOmdyb3VwPXtzZWxlY3RlZH0gdmFsdWU9XCJCcnVjZSBXaWxsaXNcIiAvPlxuICAgICAgPC9HcmFwaGljPlxuICAgICAgPExhYmVsPkJydWNlIFdpbGxpczwvTGFiZWw+XG4gICAgPC9JdGVtPlxuICAgIDxJdGVtPlxuICAgICAgPEdyYXBoaWM+XG4gICAgICAgIDxSYWRpbyBiaW5kOmdyb3VwPXtzZWxlY3RlZH0gdmFsdWU9XCJUb20gSGFua3NcIiAvPlxuICAgICAgPC9HcmFwaGljPlxuICAgICAgPExhYmVsPlRvbSBIYW5rczwvTGFiZWw+XG4gICAgPC9JdGVtPlxuICAgIDxJdGVtPlxuICAgICAgPEdyYXBoaWM+XG4gICAgICAgIDxSYWRpbyBiaW5kOmdyb3VwPXtzZWxlY3RlZH0gdmFsdWU9XCJKYWNrIE5pY2hvbHNvblwiIC8+XG4gICAgICA8L0dyYXBoaWM+XG4gICAgICA8TGFiZWw+SmFjayBOaWNob2xzb248L0xhYmVsPlxuICAgIDwvSXRlbT5cbiAgICA8SXRlbT5cbiAgICAgIDxHcmFwaGljPlxuICAgICAgICA8UmFkaW8gYmluZDpncm91cD17c2VsZWN0ZWR9IHZhbHVlPVwiTGVvbmFyZG8gRGlDYXByaW9cIiAvPlxuICAgICAgPC9HcmFwaGljPlxuICAgICAgPExhYmVsPkxlb25hcmRvIERpQ2FwcmlvPC9MYWJlbD5cbiAgICA8L0l0ZW0+XG4gICAgPEl0ZW0+XG4gICAgICA8R3JhcGhpYz5cbiAgICAgICAgPFJhZGlvIGJpbmQ6Z3JvdXA9e3NlbGVjdGVkfSB2YWx1ZT1cIk1hdHQgRGFtb25cIiAvPlxuICAgICAgPC9HcmFwaGljPlxuICAgICAgPExhYmVsPk1hdHQgRGFtb248L0xhYmVsPlxuICAgIDwvSXRlbT5cbiAgPC9MaXN0PlxuPC9kaXY+XG5cbjxwcmUgY2xhc3M9XCJzdGF0dXNcIj5TZWxlY3RlZDoge3NlbGVjdGVkfTwvcHJlPlxuXG48c2NyaXB0PlxuICBpbXBvcnQgTGlzdCwgeyBJdGVtLCBHcmFwaGljLCBMYWJlbCB9IGZyb20gJ0BzbXVpL2xpc3QnO1xuICBpbXBvcnQgUmFkaW8gZnJvbSAnQHNtdWkvcmFkaW8nO1xuXG4gIGxldCBzZWxlY3RlZCA9ICdUb20gSGFua3MnO1xuPC9zY3JpcHQ+XG5cbjxzdHlsZT5cbiAgKiA6Z2xvYmFsKC5kZW1vLWxpc3QpIHtcbiAgICBtYXgtd2lkdGg6IDYwMHB4O1xuICAgIGJvcmRlcjogMXB4IHNvbGlkXG4gICAgICB2YXIoLS1tZGMtdGhlbWUtdGV4dC1oaW50LW9uLWJhY2tncm91bmQsIHJnYmEoMCwgMCwgMCwgMC4xKSk7XG4gIH1cbjwvc3R5bGU+XG4iLCI8ZGl2PlxuICA8TGlzdCBjbGFzcz1cImRlbW8tbGlzdFwiIGNoZWNrTGlzdD5cbiAgICA8SXRlbT5cbiAgICAgIDxMYWJlbD5CcnVjZSBXaWxsaXM8L0xhYmVsPlxuICAgICAgPE1ldGE+XG4gICAgICAgIDxDaGVja2JveCBiaW5kOmdyb3VwPXtzZWxlY3RlZH0gdmFsdWU9XCJCcnVjZSBXaWxsaXNcIiAvPlxuICAgICAgPC9NZXRhPlxuICAgIDwvSXRlbT5cbiAgICA8SXRlbT5cbiAgICAgIDxMYWJlbD5Ub20gSGFua3M8L0xhYmVsPlxuICAgICAgPE1ldGE+XG4gICAgICAgIDxDaGVja2JveCBiaW5kOmdyb3VwPXtzZWxlY3RlZH0gdmFsdWU9XCJUb20gSGFua3NcIiAvPlxuICAgICAgPC9NZXRhPlxuICAgIDwvSXRlbT5cbiAgICA8SXRlbT5cbiAgICAgIDxMYWJlbD5KYWNrIE5pY2hvbHNvbjwvTGFiZWw+XG4gICAgICA8TWV0YT5cbiAgICAgICAgPENoZWNrYm94IGJpbmQ6Z3JvdXA9e3NlbGVjdGVkfSB2YWx1ZT1cIkphY2sgTmljaG9sc29uXCIgLz5cbiAgICAgIDwvTWV0YT5cbiAgICA8L0l0ZW0+XG4gICAgPEl0ZW0+XG4gICAgICA8TGFiZWw+TGVvbmFyZG8gRGlDYXByaW88L0xhYmVsPlxuICAgICAgPE1ldGE+XG4gICAgICAgIDxDaGVja2JveCBiaW5kOmdyb3VwPXtzZWxlY3RlZH0gdmFsdWU9XCJMZW9uYXJkbyBEaUNhcHJpb1wiIC8+XG4gICAgICA8L01ldGE+XG4gICAgPC9JdGVtPlxuICAgIDxJdGVtPlxuICAgICAgPExhYmVsPk1hdHQgRGFtb248L0xhYmVsPlxuICAgICAgPE1ldGE+XG4gICAgICAgIDxDaGVja2JveCBiaW5kOmdyb3VwPXtzZWxlY3RlZH0gdmFsdWU9XCJNYXR0IERhbW9uXCIgLz5cbiAgICAgIDwvTWV0YT5cbiAgICA8L0l0ZW0+XG4gIDwvTGlzdD5cbjwvZGl2PlxuXG48cHJlIGNsYXNzPVwic3RhdHVzXCI+U2VsZWN0ZWQ6IHtzZWxlY3RlZC5qb2luKCcsICcpfTwvcHJlPlxuXG48c2NyaXB0PlxuICBpbXBvcnQgTGlzdCwgeyBJdGVtLCBNZXRhLCBMYWJlbCB9IGZyb20gJ0BzbXVpL2xpc3QnO1xuICBpbXBvcnQgQ2hlY2tib3ggZnJvbSAnQHNtdWkvY2hlY2tib3gnO1xuXG4gIGxldCBzZWxlY3RlZCA9IFsnVG9tIEhhbmtzJ107XG48L3NjcmlwdD5cblxuPHN0eWxlPlxuICAqIDpnbG9iYWwoLmRlbW8tbGlzdCkge1xuICAgIG1heC13aWR0aDogNjAwcHg7XG4gICAgYm9yZGVyOiAxcHggc29saWRcbiAgICAgIHZhcigtLW1kYy10aGVtZS10ZXh0LWhpbnQtb24tYmFja2dyb3VuZCwgcmdiYSgwLCAwLCAwLCAwLjEpKTtcbiAgfVxuPC9zdHlsZT5cbiIsIjxzdmVsdGU6aGVhZD5cbiAgPHRpdGxlPkxpc3RzIC0gU01VSTwvdGl0bGU+XG48L3N2ZWx0ZTpoZWFkPlxuXG48c2VjdGlvbj5cbiAgPGgyPkxpc3RzPC9oMj5cblxuICA8cHJlIGNsYXNzPVwiZGVtby1zcGFjZWRcIj5ucG0gaSAtRCBAc211aS9saXN0PC9wcmU+XG5cbiAgPERlbW8gY29tcG9uZW50PXtTaW1wbGV9IGZpbGU9XCJsaXN0L19TaW1wbGUuc3ZlbHRlXCIgLz5cblxuICA8RGVtbyBjb21wb25lbnQ9e0dyYXBoaWNzRGVuc2V9IGZpbGU9XCJsaXN0L19HcmFwaGljc0RlbnNlLnN2ZWx0ZVwiPlxuICAgIEEgZGVuc2UgbGlzdCB3aXRoIGdyYXBoaWNzXG4gIDwvRGVtbz5cblxuICA8RGVtbyBjb21wb25lbnQ9e05vbkludGVyYWN0aXZlfSBmaWxlPVwibGlzdC9fTm9uSW50ZXJhY3RpdmUuc3ZlbHRlXCI+XG4gICAgQSBub24taW50ZXJhY3RpdmUgbGlzdCB3aXRoIGFjdGl2YXRlZCBpdGVtXG4gIDwvRGVtbz5cblxuICA8RGVtbyBjb21wb25lbnQ9e1R3b0xpbmVTZWxlY3Rpb259IGZpbGU9XCJsaXN0L19Ud29MaW5lU2VsZWN0aW9uLnN2ZWx0ZVwiPlxuICAgIEEgdHdvLWxpbmUgc2luZ2xlIHNlbGVjdGlvbiBsaXN0IHdpdGggYXZhdGFycywgZGlzYWJsZWQgaXRlbSwgYW5kIG1ldGFcbiAgPC9EZW1vPlxuXG4gIDxEZW1vIGNvbXBvbmVudD17VGhyZWVMaW5lfSBmaWxlPVwibGlzdC9fVGhyZWVMaW5lLnN2ZWx0ZVwiPlxuICAgIEEgdGhyZWUtbGluZSBsaXN0XG4gIDwvRGVtbz5cblxuICA8RGVtbyBjb21wb25lbnQ9e0dyb3Vwc30gZmlsZT1cImxpc3QvX0dyb3Vwcy5zdmVsdGVcIj5BIGxpc3QgZ3JvdXA8L0RlbW8+XG5cbiAgPERlbW8gY29tcG9uZW50PXtSYWRpb30gZmlsZT1cImxpc3QvX1JhZGlvLnN2ZWx0ZVwiPkEgcmFkaW8gbGlzdDwvRGVtbz5cblxuICA8RGVtbyBjb21wb25lbnQ9e0NoZWNrfSBmaWxlPVwibGlzdC9fQ2hlY2suc3ZlbHRlXCI+XG4gICAgQSBjaGVjayBsaXN0IHdpdGggdHJhaWxpbmcgY2hlY2tib3hlc1xuICA8L0RlbW8+XG48L3NlY3Rpb24+XG5cbjxzY3JpcHQ+XG4gIGltcG9ydCBEZW1vIGZyb20gJy4uLy4uLy4uL2NvbXBvbmVudHMvRGVtby5zdmVsdGUnO1xuICBpbXBvcnQgU2ltcGxlIGZyb20gJy4vX1NpbXBsZS5zdmVsdGUnO1xuICBpbXBvcnQgR3JhcGhpY3NEZW5zZSBmcm9tICcuL19HcmFwaGljc0RlbnNlLnN2ZWx0ZSc7XG4gIGltcG9ydCBOb25JbnRlcmFjdGl2ZSBmcm9tICcuL19Ob25JbnRlcmFjdGl2ZS5zdmVsdGUnO1xuICBpbXBvcnQgVHdvTGluZVNlbGVjdGlvbiBmcm9tICcuL19Ud29MaW5lU2VsZWN0aW9uLnN2ZWx0ZSc7XG4gIGltcG9ydCBUaHJlZUxpbmUgZnJvbSAnLi9fVGhyZWVMaW5lLnN2ZWx0ZSc7XG4gIGltcG9ydCBHcm91cHMgZnJvbSAnLi9fR3JvdXBzLnN2ZWx0ZSc7XG4gIGltcG9ydCBSYWRpbyBmcm9tICcuL19SYWRpby5zdmVsdGUnO1xuICBpbXBvcnQgQ2hlY2sgZnJvbSAnLi9fQ2hlY2suc3ZlbHRlJztcbjwvc2NyaXB0PlxuIl0sIm5hbWVzIjpbIlJhZGlvIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs4QkFJUyxRQUFRO21CQUNaLEdBQVMsTUFBRyxJQUFJO0lBQ2pCLGdDQUFnQyxFQUFFLElBQUk7Ozs7eUNBRW5DLEdBQVUscUJBQUcsR0FBVSxJQUFDLEVBQUUsR0FBRyxJQUFJOztrQkFDbEMsR0FBVzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7K0VBUEMsR0FBRzs7Ozs7Ozs7Ozs7Ozs7O3VGQUVaLFFBQVE7b0JBQ1osR0FBUyxNQUFHLElBQUk7S0FDakIsZ0NBQWdDLEVBQUUsSUFBSTs7O2tEQUdwQyxHQUFXOzs7b0lBUEMsR0FBRzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BbUJiLGFBQWEsR0FBRyxvQkFBb0IsQ0FBQyxxQkFBcUI7T0FFckQsR0FBRztjQUNWLFNBQVMsR0FBRyxFQUFFO0tBR2QsT0FBTztLQUNQLFVBQVUsR0FBRyxVQUFVLENBQUMsMEJBQTBCOztVQUV0QyxVQUFVO1NBQ2pCLE9BQU87Ozs7O0dBOUJMLE9BQU87Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt5QkNTVSxHQUFPOzs7Ozs7Ozs7Ozs7MENBQVAsR0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3VFQUFQLEdBQU87Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQUsvQixPQUFPLEdBQUcsYUFBYTs7Ozs7OzttREFiSSxPQUFPLEdBQUcsS0FBSztxREFDZixPQUFPLEdBQUcsTUFBTTtxREFDaEIsT0FBTyxHQUFHLE9BQU87cURBRWpCLE9BQU8sR0FBRyxRQUFROzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7eUJDZ0JyQixHQUFPOzs7Ozs7Ozs7Ozs7MENBQVAsR0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3VFQUFQLEdBQU87Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQUsvQixPQUFPLEdBQUcsYUFBYTs7Ozs7OzttREF6QkksT0FBTyxHQUFHLE1BQU07cURBSWhCLE9BQU8sR0FBRyxNQUFNO3FEQUloQixPQUFPLEdBQUcsU0FBUztxREFLbkIsT0FBTyxHQUFHLFFBQVE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7d0JDTTNCLEdBQUksSUFBQyxJQUFJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt3QkFDUCxHQUFJLElBQUMsV0FBVzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztnRkFQK0IsR0FBSSxJQUFDLElBQUksQ0FDckUsS0FBSyxDQUFDLEdBQUcsRUFDVCxHQUFHLE9BQ0gsSUFBSSxDQUFDLEVBQUU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7dUJBUEYsR0FBSSxJQUFDLFFBQVE7NEJBQ2IsR0FBUyxpQkFBSyxHQUFJLElBQUMsSUFBSTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7c0VBQXZCLEdBQVMsaUJBQUssR0FBSSxJQUFDLElBQUk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OEJBSjlCLEdBQU87Ozs7Z0NBQVosTUFBSTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzZCQUFDLEdBQU87Ozs7K0JBQVosTUFBSTs7Ozs7Ozs7Ozs7Ozs7Ozt3QkFBSixNQUFJOzs7Ozs7Ozs7O2tDQUFKLE1BQUk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt3QkFGYyxHQUFjO2dEQUFkLEdBQWM7Ozs7Ozs7Ozs7Ozs7MkJBeUJWLEdBQVM7O2dDQUE0QixHQUFjOzs7Ozs7Ozs7Ozs7NENBQW5ELEdBQVM7O2lEQUE0QixHQUFjOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0RBekJ2RCxHQUFjOzs7OzsyRUF5QlYsR0FBUztxRkFBNEIsR0FBYzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2FBZDdELEdBQUcsSUFBSyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUMsRUFBRSxDQUFDOzs7Ozs7S0EwQnRDLE9BQU87O0dBRVAsSUFBSSxFQUFFLGNBQWM7R0FDcEIsV0FBVyxFQUFFLE9BQU87R0FDcEIsUUFBUSxFQUFFLEtBQUs7OztHQUdmLElBQUksRUFBRSxlQUFlO0dBQ3JCLFdBQVcsRUFBRSxxQkFBcUI7R0FDbEMsUUFBUSxFQUFFLElBQUk7OztHQUdkLElBQUksRUFBRSxlQUFlO0dBQ3JCLFdBQVcsRUFBRSxVQUFVO0dBQ3ZCLFFBQVEsRUFBRSxLQUFLOzs7R0FHZixJQUFJLEVBQUUsaUJBQWlCO0dBQ3ZCLFdBQVcsRUFBRSxXQUFXO0dBQ3hCLFFBQVEsRUFBRSxLQUFLOzs7O0tBR2YsU0FBUyxHQUFHLGlCQUFpQjs7OztLQUc3QixjQUFjLEdBQUcsSUFBSTs7Ozs7Ozs7cURBMURJLFNBQVMsR0FBRyxJQUFJLENBQUMsSUFBSTs7O0VBSjVCLGNBQWM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3lCQ3FDUixHQUFPOzs7Ozs7Ozs7Ozs7MENBQVAsR0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3VFQUFQLEdBQU87Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQUsvQixPQUFPLEdBQUcsYUFBYTs7Ozs7OzttREE1Q00sT0FBTyxHQUFHLGNBQWM7cURBR3hCLE9BQU8sR0FBRyxXQUFXO3FEQUdyQixPQUFPLEdBQUcsZ0JBQWdCO3FEQUcxQixPQUFPLEdBQUcsbUJBQW1CO3FEQUc3QixPQUFPLEdBQUcsWUFBWTtxREFNdEIsT0FBTyxHQUFHLHVCQUF1QjtxREFHakMsT0FBTyxHQUFHLGtCQUFrQjtxREFHNUIsT0FBTyxHQUFHLE1BQU07cURBR2hCLE9BQU8sR0FBRyxVQUFVO3FEQUl4QixPQUFPLEdBQUcsa0NBQWtDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7a0JDL0JoRCxHQUFRO21DQUFSLEdBQVE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7dUNBQVIsR0FBUTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7a0JBTVIsR0FBUTttQ0FBUixHQUFROzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3VDQUFSLEdBQVE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2tCQU1SLEdBQVE7bUNBQVIsR0FBUTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt1Q0FBUixHQUFROzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztrQkFNUixHQUFRO21DQUFSLEdBQVE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7dUNBQVIsR0FBUTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7a0JBTVIsR0FBUTttQ0FBUixHQUFROzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3VDQUFSLEdBQVE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzBCQU9KLEdBQVE7Ozs7Ozs7Ozs7OzsyQ0FBUixHQUFROzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7eUVBQVIsR0FBUTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tBTWpDLFFBQVEsR0FBRyxXQUFXOzs7Ozs7OztFQXJDRCxRQUFROzs7OztFQU1SLFFBQVE7Ozs7O0VBTVIsUUFBUTs7Ozs7RUFNUixRQUFROzs7OztFQU1SLFFBQVE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztrQkN2QkwsR0FBUTtzQ0FBUixHQUFROzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzBDQUFSLEdBQVE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2tCQU1SLEdBQVE7c0NBQVIsR0FBUTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzswQ0FBUixHQUFROzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztrQkFNUixHQUFRO3NDQUFSLEdBQVE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MENBQVIsR0FBUTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7a0JBTVIsR0FBUTtzQ0FBUixHQUFROzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzBDQUFSLEdBQVE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2tCQU1SLEdBQVE7c0NBQVIsR0FBUTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzswQ0FBUixHQUFROzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7NkJBTVAsR0FBUSxJQUFDLElBQUksQ0FBQyxJQUFJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7cUZBQWxCLEdBQVEsSUFBQyxJQUFJLENBQUMsSUFBSTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tBTTNDLFFBQVEsSUFBSSxXQUFXOzs7Ozs7OztFQXBDQyxRQUFROzs7OztFQU1SLFFBQVE7Ozs7O0VBTVIsUUFBUTs7Ozs7RUFNUixRQUFROzs7OztFQU1SLFFBQVE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7ZUNwQm5CLE1BQU07Ozs7Ozs7O2VBRU4sYUFBYTs7Ozs7Ozs7OztlQUliLGNBQWM7Ozs7Ozs7Ozs7ZUFJZCxnQkFBZ0I7Ozs7Ozs7Ozs7ZUFJaEIsU0FBUzs7Ozs7Ozs7OztlQUlULE1BQU07Ozs7Ozs7Ozs7ZUFFTkEsT0FBSzs7Ozs7Ozs7OztlQUVMLEtBQUs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7In0=
