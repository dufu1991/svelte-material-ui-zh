import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, a7 as create_slot, $ as assign, W as compute_rest_props, v as validate_slots, Y as get_current_component, a0 as exclude_internal_props, p as element, x as claim_element, y as children, u as detach_dev, a9 as set_attributes, D as add_location, F as insert_dev, aa as action_destroyer, a8 as update_slot, a2 as get_spread_update, ab as is_function, J as transition_in, K as transition_out, ac as run_all, a6 as binding_callbacks, X as getContext, q as create_component, a1 as empty, A as claim_component, H as mount_component, a3 as get_spread_object, a4 as group_outros, M as destroy_component, a5 as check_outros, N as svg_element, ai as set_svg_attributes, o as space, t as text, w as claim_space, z as claim_text, E as attr_dev, G as append_dev, aw as set_data_dev, ak as bind, al as add_flush_callback, n as Svg$1, bp as mdiPlus, O as noop, r as query_selector_all } from './client.ec94238b.js';
import { D as Demo } from './Demo.9c515360.js';
import { f as forwardEventsBuilder, u as useActions, c as classMap, F as Fab$1 } from './Fab.5ce9de7b.js';
import { F as FormField } from './FormField.2971fa15.js';
import { C as Checkbox } from './Checkbox.52871e38.js';

/* packages/fab/node_modules/@smui/common/Span.svelte generated by Svelte v3.37.0 */
const file$b = "packages/fab/node_modules/@smui/common/Span.svelte";

function create_fragment$d(ctx) {
	let span;
	let useActions_action;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[6].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);
	let span_levels = [/*$$restProps*/ ctx[3]];
	let span_data = {};

	for (let i = 0; i < span_levels.length; i += 1) {
		span_data = assign(span_data, span_levels[i]);
	}

	const block = {
		c: function create() {
			span = element("span");
			if (default_slot) default_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", {});
			var span_nodes = children(span);
			if (default_slot) default_slot.l(span_nodes);
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_attributes(span, span_data);
			add_location(span, file$b, 0, 0, 0);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);

			if (default_slot) {
				default_slot.m(span, null);
			}

			/*span_binding*/ ctx[7](span);
			current = true;

			if (!mounted) {
				dispose = [
					action_destroyer(useActions_action = useActions.call(null, span, /*use*/ ctx[0])),
					action_destroyer(/*forwardEvents*/ ctx[2].call(null, span))
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 32) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[5], dirty, null, null);
				}
			}

			set_attributes(span, span_data = get_spread_update(span_levels, [dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3]]));
			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			if (default_slot) default_slot.d(detaching);
			/*span_binding*/ ctx[7](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$d.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$d($$self, $$props, $$invalidate) {
	const omit_props_names = ["use","getElement"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Span", slots, ['default']);
	let { use = [] } = $$props;
	const forwardEvents = forwardEventsBuilder(get_current_component());
	let element = null;

	function getElement() {
		return element;
	}

	function span_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			element = $$value;
			$$invalidate(1, element);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("use" in $$new_props) $$invalidate(0, use = $$new_props.use);
		if ("$$scope" in $$new_props) $$invalidate(5, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		get_current_component,
		forwardEventsBuilder,
		useActions,
		use,
		forwardEvents,
		element,
		getElement
	});

	$$self.$inject_state = $$new_props => {
		if ("use" in $$props) $$invalidate(0, use = $$new_props.use);
		if ("element" in $$props) $$invalidate(1, element = $$new_props.element);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		use,
		element,
		forwardEvents,
		$$restProps,
		getElement,
		$$scope,
		slots,
		span_binding
	];
}

class Span extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$d, create_fragment$d, safe_not_equal, { use: 0, getElement: 4 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Span",
			options,
			id: create_fragment$d.name
		});
	}

	get use() {
		throw new Error("<Span>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set use(value) {
		throw new Error("<Span>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get getElement() {
		return this.$$.ctx[4];
	}

	set getElement(value) {
		throw new Error("<Span>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* packages/fab/node_modules/@smui/common/CommonLabel.svelte generated by Svelte v3.37.0 */

// (1:0) <svelte:component   this={component}   bind:this={element}   use={[forwardEvents, ...use]}   class={classMap({     [className]: true,     'mdc-button__label': context === 'button',     'mdc-fab__label': context === 'fab',     'mdc-tab__text-label': context === 'tab',     'mdc-image-list__label': context === 'image-list',     'mdc-snackbar__label': context === 'snackbar',     'mdc-banner__text': context === 'banner',     'mdc-segmented-button__label': context === 'segmented-button',     'mdc-data-table__pagination-rows-per-page-label':       context === 'data-table:pagination',     'mdc-data-table__header-cell-label':       context === 'data-table:sortable-header-cell',   })}   {...context === 'snackbar' ? { 'aria-atomic': 'false' } : {}}   {tabindex}   {...$$restProps}>
function create_default_slot$a(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[9].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		l: function claim(nodes) {
			if (default_slot) default_slot.l(nodes);
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 2048) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[11], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$a.name,
		type: "slot",
		source: "(1:0) <svelte:component   this={component}   bind:this={element}   use={[forwardEvents, ...use]}   class={classMap({     [className]: true,     'mdc-button__label': context === 'button',     'mdc-fab__label': context === 'fab',     'mdc-tab__text-label': context === 'tab',     'mdc-image-list__label': context === 'image-list',     'mdc-snackbar__label': context === 'snackbar',     'mdc-banner__text': context === 'banner',     'mdc-segmented-button__label': context === 'segmented-button',     'mdc-data-table__pagination-rows-per-page-label':       context === 'data-table:pagination',     'mdc-data-table__header-cell-label':       context === 'data-table:sortable-header-cell',   })}   {...context === 'snackbar' ? { 'aria-atomic': 'false' } : {}}   {tabindex}   {...$$restProps}>",
		ctx
	});

	return block;
}

function create_fragment$c(ctx) {
	let switch_instance;
	let switch_instance_anchor;
	let current;

	const switch_instance_spread_levels = [
		{
			use: [/*forwardEvents*/ ctx[4], .../*use*/ ctx[0]]
		},
		{
			class: classMap({
				[/*className*/ ctx[1]]: true,
				"mdc-button__label": /*context*/ ctx[5] === "button",
				"mdc-fab__label": /*context*/ ctx[5] === "fab",
				"mdc-tab__text-label": /*context*/ ctx[5] === "tab",
				"mdc-image-list__label": /*context*/ ctx[5] === "image-list",
				"mdc-snackbar__label": /*context*/ ctx[5] === "snackbar",
				"mdc-banner__text": /*context*/ ctx[5] === "banner",
				"mdc-segmented-button__label": /*context*/ ctx[5] === "segmented-button",
				"mdc-data-table__pagination-rows-per-page-label": /*context*/ ctx[5] === "data-table:pagination",
				"mdc-data-table__header-cell-label": /*context*/ ctx[5] === "data-table:sortable-header-cell"
			})
		},
		/*context*/ ctx[5] === "snackbar"
		? { "aria-atomic": "false" }
		: {},
		{ tabindex: /*tabindex*/ ctx[6] },
		/*$$restProps*/ ctx[7]
	];

	var switch_value = /*component*/ ctx[2];

	function switch_props(ctx) {
		let switch_instance_props = {
			$$slots: { default: [create_default_slot$a] },
			$$scope: { ctx }
		};

		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
		}

		return {
			props: switch_instance_props,
			$$inline: true
		};
	}

	if (switch_value) {
		switch_instance = new switch_value(switch_props(ctx));
		/*switch_instance_binding*/ ctx[10](switch_instance);
	}

	const block = {
		c: function create() {
			if (switch_instance) create_component(switch_instance.$$.fragment);
			switch_instance_anchor = empty();
		},
		l: function claim(nodes) {
			if (switch_instance) claim_component(switch_instance.$$.fragment, nodes);
			switch_instance_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (switch_instance) {
				mount_component(switch_instance, target, anchor);
			}

			insert_dev(target, switch_instance_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const switch_instance_changes = (dirty & /*forwardEvents, use, classMap, className, context, tabindex, $$restProps*/ 243)
			? get_spread_update(switch_instance_spread_levels, [
					dirty & /*forwardEvents, use*/ 17 && {
						use: [/*forwardEvents*/ ctx[4], .../*use*/ ctx[0]]
					},
					dirty & /*classMap, className, context*/ 34 && {
						class: classMap({
							[/*className*/ ctx[1]]: true,
							"mdc-button__label": /*context*/ ctx[5] === "button",
							"mdc-fab__label": /*context*/ ctx[5] === "fab",
							"mdc-tab__text-label": /*context*/ ctx[5] === "tab",
							"mdc-image-list__label": /*context*/ ctx[5] === "image-list",
							"mdc-snackbar__label": /*context*/ ctx[5] === "snackbar",
							"mdc-banner__text": /*context*/ ctx[5] === "banner",
							"mdc-segmented-button__label": /*context*/ ctx[5] === "segmented-button",
							"mdc-data-table__pagination-rows-per-page-label": /*context*/ ctx[5] === "data-table:pagination",
							"mdc-data-table__header-cell-label": /*context*/ ctx[5] === "data-table:sortable-header-cell"
						})
					},
					dirty & /*context*/ 32 && get_spread_object(/*context*/ ctx[5] === "snackbar"
					? { "aria-atomic": "false" }
					: {}),
					dirty & /*tabindex*/ 64 && { tabindex: /*tabindex*/ ctx[6] },
					dirty & /*$$restProps*/ 128 && get_spread_object(/*$$restProps*/ ctx[7])
				])
			: {};

			if (dirty & /*$$scope*/ 2048) {
				switch_instance_changes.$$scope = { dirty, ctx };
			}

			if (switch_value !== (switch_value = /*component*/ ctx[2])) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props(ctx));
					/*switch_instance_binding*/ ctx[10](switch_instance);
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}
		},
		i: function intro(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			/*switch_instance_binding*/ ctx[10](null);
			if (detaching) detach_dev(switch_instance_anchor);
			if (switch_instance) destroy_component(switch_instance, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$c.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$c($$self, $$props, $$invalidate) {
	const omit_props_names = ["use","class","component","getElement"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("CommonLabel", slots, ['default']);
	const forwardEvents = forwardEventsBuilder(get_current_component());
	let { use = [] } = $$props;
	let { class: className = "" } = $$props;
	let element;
	let { component = Span } = $$props;
	const context = getContext("SMUI:label:context");
	const tabindex = getContext("SMUI:label:tabindex");

	function getElement() {
		return element.getElement();
	}

	function switch_instance_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			element = $$value;
			$$invalidate(3, element);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("use" in $$new_props) $$invalidate(0, use = $$new_props.use);
		if ("class" in $$new_props) $$invalidate(1, className = $$new_props.class);
		if ("component" in $$new_props) $$invalidate(2, component = $$new_props.component);
		if ("$$scope" in $$new_props) $$invalidate(11, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		getContext,
		get_current_component,
		forwardEventsBuilder,
		classMap,
		useActions,
		Span,
		forwardEvents,
		use,
		className,
		element,
		component,
		context,
		tabindex,
		getElement
	});

	$$self.$inject_state = $$new_props => {
		if ("use" in $$props) $$invalidate(0, use = $$new_props.use);
		if ("className" in $$props) $$invalidate(1, className = $$new_props.className);
		if ("element" in $$props) $$invalidate(3, element = $$new_props.element);
		if ("component" in $$props) $$invalidate(2, component = $$new_props.component);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		use,
		className,
		component,
		element,
		forwardEvents,
		context,
		tabindex,
		$$restProps,
		getElement,
		slots,
		switch_instance_binding,
		$$scope
	];
}

class CommonLabel extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$c, create_fragment$c, safe_not_equal, {
			use: 0,
			class: 1,
			component: 2,
			getElement: 8
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "CommonLabel",
			options,
			id: create_fragment$c.name
		});
	}

	get use() {
		throw new Error("<CommonLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set use(value) {
		throw new Error("<CommonLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error("<CommonLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<CommonLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get component() {
		throw new Error("<CommonLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set component(value) {
		throw new Error("<CommonLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get getElement() {
		return this.$$.ctx[8];
	}

	set getElement(value) {
		throw new Error("<CommonLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* packages/fab/node_modules/@smui/common/I.svelte generated by Svelte v3.37.0 */
const file$a = "packages/fab/node_modules/@smui/common/I.svelte";

function create_fragment$b(ctx) {
	let i;
	let useActions_action;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[6].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);
	let i_levels = [/*$$restProps*/ ctx[3]];
	let i_data = {};

	for (let i = 0; i < i_levels.length; i += 1) {
		i_data = assign(i_data, i_levels[i]);
	}

	const block = {
		c: function create() {
			i = element("i");
			if (default_slot) default_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			i = claim_element(nodes, "I", {});
			var i_nodes = children(i);
			if (default_slot) default_slot.l(i_nodes);
			i_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_attributes(i, i_data);
			add_location(i, file$a, 0, 0, 0);
		},
		m: function mount(target, anchor) {
			insert_dev(target, i, anchor);

			if (default_slot) {
				default_slot.m(i, null);
			}

			/*i_binding*/ ctx[7](i);
			current = true;

			if (!mounted) {
				dispose = [
					action_destroyer(useActions_action = useActions.call(null, i, /*use*/ ctx[0])),
					action_destroyer(/*forwardEvents*/ ctx[2].call(null, i))
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 32) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[5], dirty, null, null);
				}
			}

			set_attributes(i, i_data = get_spread_update(i_levels, [dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3]]));
			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(i);
			if (default_slot) default_slot.d(detaching);
			/*i_binding*/ ctx[7](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$b.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$b($$self, $$props, $$invalidate) {
	const omit_props_names = ["use","getElement"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("I", slots, ['default']);
	let { use = [] } = $$props;
	const forwardEvents = forwardEventsBuilder(get_current_component());
	let element = null;

	function getElement() {
		return element;
	}

	function i_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			element = $$value;
			$$invalidate(1, element);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("use" in $$new_props) $$invalidate(0, use = $$new_props.use);
		if ("$$scope" in $$new_props) $$invalidate(5, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		get_current_component,
		forwardEventsBuilder,
		useActions,
		use,
		forwardEvents,
		element,
		getElement
	});

	$$self.$inject_state = $$new_props => {
		if ("use" in $$props) $$invalidate(0, use = $$new_props.use);
		if ("element" in $$props) $$invalidate(1, element = $$new_props.element);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		use,
		element,
		forwardEvents,
		$$restProps,
		getElement,
		$$scope,
		slots,
		i_binding
	];
}

class I extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$b, create_fragment$b, safe_not_equal, { use: 0, getElement: 4 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "I",
			options,
			id: create_fragment$b.name
		});
	}

	get use() {
		throw new Error("<I>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set use(value) {
		throw new Error("<I>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get getElement() {
		return this.$$.ctx[4];
	}

	set getElement(value) {
		throw new Error("<I>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* packages/fab/node_modules/@smui/common/Svg.svelte generated by Svelte v3.37.0 */
const file$9 = "packages/fab/node_modules/@smui/common/Svg.svelte";

function create_fragment$a(ctx) {
	let svg;
	let useActions_action;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[6].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);
	let svg_levels = [/*$$restProps*/ ctx[3]];
	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	const block = {
		c: function create() {
			svg = svg_element("svg");
			if (default_slot) default_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			svg = claim_element(nodes, "svg", {}, 1);
			var svg_nodes = children(svg);
			if (default_slot) default_slot.l(svg_nodes);
			svg_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_svg_attributes(svg, svg_data);
			add_location(svg, file$9, 0, 0, 0);
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);

			if (default_slot) {
				default_slot.m(svg, null);
			}

			/*svg_binding*/ ctx[7](svg);
			current = true;

			if (!mounted) {
				dispose = [
					action_destroyer(useActions_action = useActions.call(null, svg, /*use*/ ctx[0])),
					action_destroyer(/*forwardEvents*/ ctx[2].call(null, svg))
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 32) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[5], dirty, null, null);
				}
			}

			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3]]));
			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
			if (default_slot) default_slot.d(detaching);
			/*svg_binding*/ ctx[7](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$a.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$a($$self, $$props, $$invalidate) {
	const omit_props_names = ["use","getElement"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Svg", slots, ['default']);
	let { use = [] } = $$props;
	const forwardEvents = forwardEventsBuilder(get_current_component());
	let element = null;

	function getElement() {
		return element;
	}

	function svg_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			element = $$value;
			$$invalidate(1, element);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("use" in $$new_props) $$invalidate(0, use = $$new_props.use);
		if ("$$scope" in $$new_props) $$invalidate(5, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		get_current_component,
		forwardEventsBuilder,
		useActions,
		use,
		forwardEvents,
		element,
		getElement
	});

	$$self.$inject_state = $$new_props => {
		if ("use" in $$props) $$invalidate(0, use = $$new_props.use);
		if ("element" in $$props) $$invalidate(1, element = $$new_props.element);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		use,
		element,
		forwardEvents,
		$$restProps,
		getElement,
		$$scope,
		slots,
		svg_binding
	];
}

class Svg extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$a, create_fragment$a, safe_not_equal, { use: 0, getElement: 4 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Svg",
			options,
			id: create_fragment$a.name
		});
	}

	get use() {
		throw new Error("<Svg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set use(value) {
		throw new Error("<Svg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get getElement() {
		return this.$$.ctx[4];
	}

	set getElement(value) {
		throw new Error("<Svg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* packages/fab/node_modules/@smui/common/CommonIcon.svelte generated by Svelte v3.37.0 */

// (1:0) <svelte:component   this={component}   bind:this={element}   use={[forwardEvents, ...use]}   class={classMap({     [className]: true,     'mdc-button__icon': context === 'button',     'mdc-fab__icon': context === 'fab',     'mdc-icon-button__icon': context === 'icon-button',     'mdc-icon-button__icon--on': context === 'icon-button' && on,     'mdc-tab__icon': context === 'tab',     'mdc-banner__icon': context === 'banner',     'mdc-segmented-button__icon': context === 'segmented-button',   })}   aria-hidden="true"   {...component === Svg ? { focusable: 'false', tabindex: '-1' } : {}}   {...$$restProps}>
function create_default_slot$9(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[9].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		l: function claim(nodes) {
			if (default_slot) default_slot.l(nodes);
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 2048) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[11], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$9.name,
		type: "slot",
		source: "(1:0) <svelte:component   this={component}   bind:this={element}   use={[forwardEvents, ...use]}   class={classMap({     [className]: true,     'mdc-button__icon': context === 'button',     'mdc-fab__icon': context === 'fab',     'mdc-icon-button__icon': context === 'icon-button',     'mdc-icon-button__icon--on': context === 'icon-button' && on,     'mdc-tab__icon': context === 'tab',     'mdc-banner__icon': context === 'banner',     'mdc-segmented-button__icon': context === 'segmented-button',   })}   aria-hidden=\\\"true\\\"   {...component === Svg ? { focusable: 'false', tabindex: '-1' } : {}}   {...$$restProps}>",
		ctx
	});

	return block;
}

function create_fragment$9(ctx) {
	let switch_instance;
	let switch_instance_anchor;
	let current;

	const switch_instance_spread_levels = [
		{
			use: [/*forwardEvents*/ ctx[5], .../*use*/ ctx[0]]
		},
		{
			class: classMap({
				[/*className*/ ctx[1]]: true,
				"mdc-button__icon": /*context*/ ctx[6] === "button",
				"mdc-fab__icon": /*context*/ ctx[6] === "fab",
				"mdc-icon-button__icon": /*context*/ ctx[6] === "icon-button",
				"mdc-icon-button__icon--on": /*context*/ ctx[6] === "icon-button" && /*on*/ ctx[2],
				"mdc-tab__icon": /*context*/ ctx[6] === "tab",
				"mdc-banner__icon": /*context*/ ctx[6] === "banner",
				"mdc-segmented-button__icon": /*context*/ ctx[6] === "segmented-button"
			})
		},
		{ "aria-hidden": "true" },
		/*component*/ ctx[3] === Svg
		? { focusable: "false", tabindex: "-1" }
		: {},
		/*$$restProps*/ ctx[7]
	];

	var switch_value = /*component*/ ctx[3];

	function switch_props(ctx) {
		let switch_instance_props = {
			$$slots: { default: [create_default_slot$9] },
			$$scope: { ctx }
		};

		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
		}

		return {
			props: switch_instance_props,
			$$inline: true
		};
	}

	if (switch_value) {
		switch_instance = new switch_value(switch_props(ctx));
		/*switch_instance_binding*/ ctx[10](switch_instance);
	}

	const block = {
		c: function create() {
			if (switch_instance) create_component(switch_instance.$$.fragment);
			switch_instance_anchor = empty();
		},
		l: function claim(nodes) {
			if (switch_instance) claim_component(switch_instance.$$.fragment, nodes);
			switch_instance_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (switch_instance) {
				mount_component(switch_instance, target, anchor);
			}

			insert_dev(target, switch_instance_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const switch_instance_changes = (dirty & /*forwardEvents, use, classMap, className, context, on, component, Svg, $$restProps*/ 239)
			? get_spread_update(switch_instance_spread_levels, [
					dirty & /*forwardEvents, use*/ 33 && {
						use: [/*forwardEvents*/ ctx[5], .../*use*/ ctx[0]]
					},
					dirty & /*classMap, className, context, on*/ 70 && {
						class: classMap({
							[/*className*/ ctx[1]]: true,
							"mdc-button__icon": /*context*/ ctx[6] === "button",
							"mdc-fab__icon": /*context*/ ctx[6] === "fab",
							"mdc-icon-button__icon": /*context*/ ctx[6] === "icon-button",
							"mdc-icon-button__icon--on": /*context*/ ctx[6] === "icon-button" && /*on*/ ctx[2],
							"mdc-tab__icon": /*context*/ ctx[6] === "tab",
							"mdc-banner__icon": /*context*/ ctx[6] === "banner",
							"mdc-segmented-button__icon": /*context*/ ctx[6] === "segmented-button"
						})
					},
					switch_instance_spread_levels[2],
					dirty & /*component, Svg*/ 8 && get_spread_object(/*component*/ ctx[3] === Svg
					? { focusable: "false", tabindex: "-1" }
					: {}),
					dirty & /*$$restProps*/ 128 && get_spread_object(/*$$restProps*/ ctx[7])
				])
			: {};

			if (dirty & /*$$scope*/ 2048) {
				switch_instance_changes.$$scope = { dirty, ctx };
			}

			if (switch_value !== (switch_value = /*component*/ ctx[3])) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props(ctx));
					/*switch_instance_binding*/ ctx[10](switch_instance);
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}
		},
		i: function intro(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			/*switch_instance_binding*/ ctx[10](null);
			if (detaching) detach_dev(switch_instance_anchor);
			if (switch_instance) destroy_component(switch_instance, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$9.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$9($$self, $$props, $$invalidate) {
	const omit_props_names = ["use","class","on","component","getElement"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("CommonIcon", slots, ['default']);
	const forwardEvents = forwardEventsBuilder(get_current_component());
	let { use = [] } = $$props;
	let { class: className = "" } = $$props;
	let { on = false } = $$props;
	let element;
	let { component = I } = $$props;
	const context = getContext("SMUI:icon:context");

	function getElement() {
		return element.getElement();
	}

	function switch_instance_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			element = $$value;
			$$invalidate(4, element);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("use" in $$new_props) $$invalidate(0, use = $$new_props.use);
		if ("class" in $$new_props) $$invalidate(1, className = $$new_props.class);
		if ("on" in $$new_props) $$invalidate(2, on = $$new_props.on);
		if ("component" in $$new_props) $$invalidate(3, component = $$new_props.component);
		if ("$$scope" in $$new_props) $$invalidate(11, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		getContext,
		get_current_component,
		forwardEventsBuilder,
		classMap,
		I,
		Svg,
		forwardEvents,
		use,
		className,
		on,
		element,
		component,
		context,
		getElement
	});

	$$self.$inject_state = $$new_props => {
		if ("use" in $$props) $$invalidate(0, use = $$new_props.use);
		if ("className" in $$props) $$invalidate(1, className = $$new_props.className);
		if ("on" in $$props) $$invalidate(2, on = $$new_props.on);
		if ("element" in $$props) $$invalidate(4, element = $$new_props.element);
		if ("component" in $$props) $$invalidate(3, component = $$new_props.component);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		use,
		className,
		on,
		component,
		element,
		forwardEvents,
		context,
		$$restProps,
		getElement,
		slots,
		switch_instance_binding,
		$$scope
	];
}

class CommonIcon extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$9, create_fragment$9, safe_not_equal, {
			use: 0,
			class: 1,
			on: 2,
			component: 3,
			getElement: 8
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "CommonIcon",
			options,
			id: create_fragment$9.name
		});
	}

	get use() {
		throw new Error("<CommonIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set use(value) {
		throw new Error("<CommonIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error("<CommonIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<CommonIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get on() {
		throw new Error("<CommonIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set on(value) {
		throw new Error("<CommonIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get component() {
		throw new Error("<CommonIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set component(value) {
		throw new Error("<CommonIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get getElement() {
		return this.$$.ctx[8];
	}

	set getElement(value) {
		throw new Error("<CommonIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/demo/fab/_Simple.svelte generated by Svelte v3.37.0 */
const file$8 = "src/routes/demo/fab/_Simple.svelte";

// (4:6) <Icon class="material-icons">
function create_default_slot_1$8(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("favorite");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "favorite");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$8.name,
		type: "slot",
		source: "(4:6) <Icon class=\\\"material-icons\\\">",
		ctx
	});

	return block;
}

// (3:4) <Fab on:click={() => clicked++}>
function create_default_slot$8(ctx) {
	let icon;
	let current;

	icon = new CommonIcon({
			props: {
				class: "material-icons",
				$$slots: { default: [create_default_slot_1$8] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(icon.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(icon.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(icon, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const icon_changes = {};

			if (dirty & /*$$scope*/ 4) {
				icon_changes.$$scope = { dirty, ctx };
			}

			icon.$set(icon_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(icon, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$8.name,
		type: "slot",
		source: "(3:4) <Fab on:click={() => clicked++}>",
		ctx
	});

	return block;
}

function create_fragment$8(ctx) {
	let div1;
	let div0;
	let fab;
	let t0;
	let pre;
	let t1;
	let t2;
	let current;

	fab = new Fab$1({
			props: {
				$$slots: { default: [create_default_slot$8] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	fab.$on("click", /*click_handler*/ ctx[1]);

	const block = {
		c: function create() {
			div1 = element("div");
			div0 = element("div");
			create_component(fab.$$.fragment);
			t0 = space();
			pre = element("pre");
			t1 = text("Clicked: ");
			t2 = text(/*clicked*/ ctx[0]);
			this.h();
		},
		l: function claim(nodes) {
			div1 = claim_element(nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			claim_component(fab.$$.fragment, div0_nodes);
			div0_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			t0 = claim_space(nodes);
			pre = claim_element(nodes, "PRE", { class: true });
			var pre_nodes = children(pre);
			t1 = claim_text(pre_nodes, "Clicked: ");
			t2 = claim_text(pre_nodes, /*clicked*/ ctx[0]);
			pre_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "class", "margins");
			add_location(div0, file$8, 1, 2, 22);
			attr_dev(div1, "class", "flexy");
			add_location(div1, file$8, 0, 0, 0);
			attr_dev(pre, "class", "status");
			add_location(pre, file$8, 8, 0, 160);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);
			mount_component(fab, div0, null);
			insert_dev(target, t0, anchor);
			insert_dev(target, pre, anchor);
			append_dev(pre, t1);
			append_dev(pre, t2);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const fab_changes = {};

			if (dirty & /*$$scope*/ 4) {
				fab_changes.$$scope = { dirty, ctx };
			}

			fab.$set(fab_changes);
			if (!current || dirty & /*clicked*/ 1) set_data_dev(t2, /*clicked*/ ctx[0]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(fab.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(fab.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			destroy_component(fab);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(pre);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$8.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$8($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Simple", slots, []);
	let clicked = 0;
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Simple> was created with unknown prop '${key}'`);
	});

	const click_handler = () => $$invalidate(0, clicked++, clicked);
	$$self.$capture_state = () => ({ Fab: Fab$1, Icon: CommonIcon, clicked });

	$$self.$inject_state = $$props => {
		if ("clicked" in $$props) $$invalidate(0, clicked = $$props.clicked);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [clicked, click_handler];
}

class Simple extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$8, create_fragment$8, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Simple",
			options,
			id: create_fragment$8.name
		});
	}
}

/* src/routes/demo/fab/_PrimaryColor.svelte generated by Svelte v3.37.0 */
const file$7 = "src/routes/demo/fab/_PrimaryColor.svelte";

// (4:6) <Icon class="material-icons">
function create_default_slot_1$7(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("favorite");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "favorite");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$7.name,
		type: "slot",
		source: "(4:6) <Icon class=\\\"material-icons\\\">",
		ctx
	});

	return block;
}

// (3:4) <Fab color="primary" on:click={() => clicked++}>
function create_default_slot$7(ctx) {
	let icon;
	let current;

	icon = new CommonIcon({
			props: {
				class: "material-icons",
				$$slots: { default: [create_default_slot_1$7] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(icon.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(icon.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(icon, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const icon_changes = {};

			if (dirty & /*$$scope*/ 4) {
				icon_changes.$$scope = { dirty, ctx };
			}

			icon.$set(icon_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(icon, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$7.name,
		type: "slot",
		source: "(3:4) <Fab color=\\\"primary\\\" on:click={() => clicked++}>",
		ctx
	});

	return block;
}

function create_fragment$7(ctx) {
	let div1;
	let div0;
	let fab;
	let t0;
	let pre;
	let t1;
	let t2;
	let current;

	fab = new Fab$1({
			props: {
				color: "primary",
				$$slots: { default: [create_default_slot$7] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	fab.$on("click", /*click_handler*/ ctx[1]);

	const block = {
		c: function create() {
			div1 = element("div");
			div0 = element("div");
			create_component(fab.$$.fragment);
			t0 = space();
			pre = element("pre");
			t1 = text("Clicked: ");
			t2 = text(/*clicked*/ ctx[0]);
			this.h();
		},
		l: function claim(nodes) {
			div1 = claim_element(nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			claim_component(fab.$$.fragment, div0_nodes);
			div0_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			t0 = claim_space(nodes);
			pre = claim_element(nodes, "PRE", { class: true });
			var pre_nodes = children(pre);
			t1 = claim_text(pre_nodes, "Clicked: ");
			t2 = claim_text(pre_nodes, /*clicked*/ ctx[0]);
			pre_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "class", "margins");
			add_location(div0, file$7, 1, 2, 22);
			attr_dev(div1, "class", "flexy");
			add_location(div1, file$7, 0, 0, 0);
			attr_dev(pre, "class", "status");
			add_location(pre, file$7, 8, 0, 176);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);
			mount_component(fab, div0, null);
			insert_dev(target, t0, anchor);
			insert_dev(target, pre, anchor);
			append_dev(pre, t1);
			append_dev(pre, t2);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const fab_changes = {};

			if (dirty & /*$$scope*/ 4) {
				fab_changes.$$scope = { dirty, ctx };
			}

			fab.$set(fab_changes);
			if (!current || dirty & /*clicked*/ 1) set_data_dev(t2, /*clicked*/ ctx[0]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(fab.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(fab.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			destroy_component(fab);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(pre);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$7.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$7($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("PrimaryColor", slots, []);
	let clicked = 0;
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<PrimaryColor> was created with unknown prop '${key}'`);
	});

	const click_handler = () => $$invalidate(0, clicked++, clicked);
	$$self.$capture_state = () => ({ Fab: Fab$1, Icon: CommonIcon, clicked });

	$$self.$inject_state = $$props => {
		if ("clicked" in $$props) $$invalidate(0, clicked = $$props.clicked);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [clicked, click_handler];
}

class PrimaryColor extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$7, create_fragment$7, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "PrimaryColor",
			options,
			id: create_fragment$7.name
		});
	}
}

/* src/routes/demo/fab/_Exited.svelte generated by Svelte v3.37.0 */
const file$6 = "src/routes/demo/fab/_Exited.svelte";

// (4:6) <Icon class="material-icons">
function create_default_slot_5$4(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("favorite");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "favorite");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_5$4.name,
		type: "slot",
		source: "(4:6) <Icon class=\\\"material-icons\\\">",
		ctx
	});

	return block;
}

// (3:4) <Fab on:click={() => clicked++} {exited}>
function create_default_slot_4$4(ctx) {
	let icon;
	let current;

	icon = new CommonIcon({
			props: {
				class: "material-icons",
				$$slots: { default: [create_default_slot_5$4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(icon.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(icon.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(icon, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const icon_changes = {};

			if (dirty & /*$$scope*/ 128) {
				icon_changes.$$scope = { dirty, ctx };
			}

			icon.$set(icon_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(icon, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_4$4.name,
		type: "slot",
		source: "(3:4) <Fab on:click={() => clicked++} {exited}>",
		ctx
	});

	return block;
}

// (8:4) <FormField>
function create_default_slot_3$5(ctx) {
	let checkbox;
	let updating_checked;
	let current;

	function checkbox_checked_binding(value) {
		/*checkbox_checked_binding*/ ctx[4](value);
	}

	let checkbox_props = {};

	if (/*exited*/ ctx[1] !== void 0) {
		checkbox_props.checked = /*exited*/ ctx[1];
	}

	checkbox = new Checkbox({ props: checkbox_props, $$inline: true });
	binding_callbacks.push(() => bind(checkbox, "checked", checkbox_checked_binding));

	const block = {
		c: function create() {
			create_component(checkbox.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(checkbox.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(checkbox, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const checkbox_changes = {};

			if (!updating_checked && dirty & /*exited*/ 2) {
				updating_checked = true;
				checkbox_changes.checked = /*exited*/ ctx[1];
				add_flush_callback(() => updating_checked = false);
			}

			checkbox.$set(checkbox_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(checkbox.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(checkbox.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(checkbox, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3$5.name,
		type: "slot",
		source: "(8:4) <FormField>",
		ctx
	});

	return block;
}

// (10:6) 
function create_label_slot_1(ctx) {
	let span;
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text("Exited");
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { slot: true });
			var span_nodes = children(span);
			t = claim_text(span_nodes, "Exited");
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "slot", "label");
			add_location(span, file$6, 9, 6, 248);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_label_slot_1.name,
		type: "slot",
		source: "(10:6) ",
		ctx
	});

	return block;
}

// (18:6) <Icon class="material-icons">
function create_default_slot_2$5(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("favorite");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "favorite");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2$5.name,
		type: "slot",
		source: "(18:6) <Icon class=\\\"material-icons\\\">",
		ctx
	});

	return block;
}

// (17:4) <Fab color="primary" on:click={() => clicked++} exited={exitedPrimary}>
function create_default_slot_1$6(ctx) {
	let icon;
	let current;

	icon = new CommonIcon({
			props: {
				class: "material-icons",
				$$slots: { default: [create_default_slot_2$5] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(icon.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(icon.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(icon, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const icon_changes = {};

			if (dirty & /*$$scope*/ 128) {
				icon_changes.$$scope = { dirty, ctx };
			}

			icon.$set(icon_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(icon, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$6.name,
		type: "slot",
		source: "(17:4) <Fab color=\\\"primary\\\" on:click={() => clicked++} exited={exitedPrimary}>",
		ctx
	});

	return block;
}

// (22:4) <FormField>
function create_default_slot$6(ctx) {
	let checkbox;
	let updating_checked;
	let current;

	function checkbox_checked_binding_1(value) {
		/*checkbox_checked_binding_1*/ ctx[6](value);
	}

	let checkbox_props = {};

	if (/*exitedPrimary*/ ctx[2] !== void 0) {
		checkbox_props.checked = /*exitedPrimary*/ ctx[2];
	}

	checkbox = new Checkbox({ props: checkbox_props, $$inline: true });
	binding_callbacks.push(() => bind(checkbox, "checked", checkbox_checked_binding_1));

	const block = {
		c: function create() {
			create_component(checkbox.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(checkbox.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(checkbox, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const checkbox_changes = {};

			if (!updating_checked && dirty & /*exitedPrimary*/ 4) {
				updating_checked = true;
				checkbox_changes.checked = /*exitedPrimary*/ ctx[2];
				add_flush_callback(() => updating_checked = false);
			}

			checkbox.$set(checkbox_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(checkbox.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(checkbox.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(checkbox, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$6.name,
		type: "slot",
		source: "(22:4) <FormField>",
		ctx
	});

	return block;
}

// (24:6) 
function create_label_slot(ctx) {
	let span;
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text("Exited");
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { slot: true });
			var span_nodes = children(span);
			t = claim_text(span_nodes, "Exited");
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "slot", "label");
			add_location(span, file$6, 23, 6, 600);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_label_slot.name,
		type: "slot",
		source: "(24:6) ",
		ctx
	});

	return block;
}

function create_fragment$6(ctx) {
	let div2;
	let div0;
	let fab0;
	let t0;
	let div1;
	let formfield0;
	let t1;
	let div5;
	let div3;
	let fab1;
	let t2;
	let div4;
	let formfield1;
	let t3;
	let pre;
	let t4;
	let t5;
	let current;

	fab0 = new Fab$1({
			props: {
				exited: /*exited*/ ctx[1],
				$$slots: { default: [create_default_slot_4$4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	fab0.$on("click", /*click_handler*/ ctx[3]);

	formfield0 = new FormField({
			props: {
				$$slots: {
					label: [create_label_slot_1],
					default: [create_default_slot_3$5]
				},
				$$scope: { ctx }
			},
			$$inline: true
		});

	fab1 = new Fab$1({
			props: {
				color: "primary",
				exited: /*exitedPrimary*/ ctx[2],
				$$slots: { default: [create_default_slot_1$6] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	fab1.$on("click", /*click_handler_1*/ ctx[5]);

	formfield1 = new FormField({
			props: {
				$$slots: {
					label: [create_label_slot],
					default: [create_default_slot$6]
				},
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			div2 = element("div");
			div0 = element("div");
			create_component(fab0.$$.fragment);
			t0 = space();
			div1 = element("div");
			create_component(formfield0.$$.fragment);
			t1 = space();
			div5 = element("div");
			div3 = element("div");
			create_component(fab1.$$.fragment);
			t2 = space();
			div4 = element("div");
			create_component(formfield1.$$.fragment);
			t3 = space();
			pre = element("pre");
			t4 = text("Clicked: ");
			t5 = text(/*clicked*/ ctx[0]);
			this.h();
		},
		l: function claim(nodes) {
			div2 = claim_element(nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			div0 = claim_element(div2_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			claim_component(fab0.$$.fragment, div0_nodes);
			div0_nodes.forEach(detach_dev);
			t0 = claim_space(div2_nodes);
			div1 = claim_element(div2_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			claim_component(formfield0.$$.fragment, div1_nodes);
			div1_nodes.forEach(detach_dev);
			div2_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			div5 = claim_element(nodes, "DIV", { class: true });
			var div5_nodes = children(div5);
			div3 = claim_element(div5_nodes, "DIV", { class: true });
			var div3_nodes = children(div3);
			claim_component(fab1.$$.fragment, div3_nodes);
			div3_nodes.forEach(detach_dev);
			t2 = claim_space(div5_nodes);
			div4 = claim_element(div5_nodes, "DIV", { class: true });
			var div4_nodes = children(div4);
			claim_component(formfield1.$$.fragment, div4_nodes);
			div4_nodes.forEach(detach_dev);
			div5_nodes.forEach(detach_dev);
			t3 = claim_space(nodes);
			pre = claim_element(nodes, "PRE", { class: true });
			var pre_nodes = children(pre);
			t4 = claim_text(pre_nodes, "Clicked: ");
			t5 = claim_text(pre_nodes, /*clicked*/ ctx[0]);
			pre_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "class", "margins");
			add_location(div0, file$6, 1, 2, 22);
			attr_dev(div1, "class", "margins");
			add_location(div1, file$6, 6, 2, 163);
			attr_dev(div2, "class", "flexy");
			add_location(div2, file$6, 0, 0, 0);
			attr_dev(div3, "class", "margins");
			add_location(div3, file$6, 15, 2, 337);
			attr_dev(div4, "class", "margins");
			add_location(div4, file$6, 20, 2, 508);
			attr_dev(div5, "class", "flexy");
			add_location(div5, file$6, 14, 0, 315);
			attr_dev(pre, "class", "status");
			add_location(pre, file$6, 28, 0, 667);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div2, anchor);
			append_dev(div2, div0);
			mount_component(fab0, div0, null);
			append_dev(div2, t0);
			append_dev(div2, div1);
			mount_component(formfield0, div1, null);
			insert_dev(target, t1, anchor);
			insert_dev(target, div5, anchor);
			append_dev(div5, div3);
			mount_component(fab1, div3, null);
			append_dev(div5, t2);
			append_dev(div5, div4);
			mount_component(formfield1, div4, null);
			insert_dev(target, t3, anchor);
			insert_dev(target, pre, anchor);
			append_dev(pre, t4);
			append_dev(pre, t5);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const fab0_changes = {};
			if (dirty & /*exited*/ 2) fab0_changes.exited = /*exited*/ ctx[1];

			if (dirty & /*$$scope*/ 128) {
				fab0_changes.$$scope = { dirty, ctx };
			}

			fab0.$set(fab0_changes);
			const formfield0_changes = {};

			if (dirty & /*$$scope, exited*/ 130) {
				formfield0_changes.$$scope = { dirty, ctx };
			}

			formfield0.$set(formfield0_changes);
			const fab1_changes = {};
			if (dirty & /*exitedPrimary*/ 4) fab1_changes.exited = /*exitedPrimary*/ ctx[2];

			if (dirty & /*$$scope*/ 128) {
				fab1_changes.$$scope = { dirty, ctx };
			}

			fab1.$set(fab1_changes);
			const formfield1_changes = {};

			if (dirty & /*$$scope, exitedPrimary*/ 132) {
				formfield1_changes.$$scope = { dirty, ctx };
			}

			formfield1.$set(formfield1_changes);
			if (!current || dirty & /*clicked*/ 1) set_data_dev(t5, /*clicked*/ ctx[0]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(fab0.$$.fragment, local);
			transition_in(formfield0.$$.fragment, local);
			transition_in(fab1.$$.fragment, local);
			transition_in(formfield1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(fab0.$$.fragment, local);
			transition_out(formfield0.$$.fragment, local);
			transition_out(fab1.$$.fragment, local);
			transition_out(formfield1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div2);
			destroy_component(fab0);
			destroy_component(formfield0);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(div5);
			destroy_component(fab1);
			destroy_component(formfield1);
			if (detaching) detach_dev(t3);
			if (detaching) detach_dev(pre);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$6.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$6($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Exited", slots, []);
	let clicked = 0;
	let exited = false;
	let exitedPrimary = false;
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Exited> was created with unknown prop '${key}'`);
	});

	const click_handler = () => $$invalidate(0, clicked++, clicked);

	function checkbox_checked_binding(value) {
		exited = value;
		$$invalidate(1, exited);
	}

	const click_handler_1 = () => $$invalidate(0, clicked++, clicked);

	function checkbox_checked_binding_1(value) {
		exitedPrimary = value;
		$$invalidate(2, exitedPrimary);
	}

	$$self.$capture_state = () => ({
		Fab: Fab$1,
		Label: CommonLabel,
		Icon: CommonIcon,
		FormField,
		Checkbox,
		clicked,
		exited,
		exitedPrimary
	});

	$$self.$inject_state = $$props => {
		if ("clicked" in $$props) $$invalidate(0, clicked = $$props.clicked);
		if ("exited" in $$props) $$invalidate(1, exited = $$props.exited);
		if ("exitedPrimary" in $$props) $$invalidate(2, exitedPrimary = $$props.exitedPrimary);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		clicked,
		exited,
		exitedPrimary,
		click_handler,
		checkbox_checked_binding,
		click_handler_1,
		checkbox_checked_binding_1
	];
}

class Exited extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$6, create_fragment$6, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Exited",
			options,
			id: create_fragment$6.name
		});
	}
}

/* src/routes/demo/fab/_Mini.svelte generated by Svelte v3.37.0 */
const file$5 = "src/routes/demo/fab/_Mini.svelte";

// (4:6) <Icon class="material-icons">
function create_default_slot_3$4(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("favorite");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "favorite");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3$4.name,
		type: "slot",
		source: "(4:6) <Icon class=\\\"material-icons\\\">",
		ctx
	});

	return block;
}

// (3:4) <Fab on:click={() => clicked++} mini>
function create_default_slot_2$4(ctx) {
	let icon;
	let current;

	icon = new CommonIcon({
			props: {
				class: "material-icons",
				$$slots: { default: [create_default_slot_3$4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(icon.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(icon.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(icon, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const icon_changes = {};

			if (dirty & /*$$scope*/ 8) {
				icon_changes.$$scope = { dirty, ctx };
			}

			icon.$set(icon_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(icon, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2$4.name,
		type: "slot",
		source: "(3:4) <Fab on:click={() => clicked++} mini>",
		ctx
	});

	return block;
}

// (9:6) <Icon class="material-icons">
function create_default_slot_1$5(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("favorite");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "favorite");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$5.name,
		type: "slot",
		source: "(9:6) <Icon class=\\\"material-icons\\\">",
		ctx
	});

	return block;
}

// (8:4) <Fab color="primary" on:click={() => clicked++} mini>
function create_default_slot$5(ctx) {
	let icon;
	let current;

	icon = new CommonIcon({
			props: {
				class: "material-icons",
				$$slots: { default: [create_default_slot_1$5] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(icon.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(icon.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(icon, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const icon_changes = {};

			if (dirty & /*$$scope*/ 8) {
				icon_changes.$$scope = { dirty, ctx };
			}

			icon.$set(icon_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(icon, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$5.name,
		type: "slot",
		source: "(8:4) <Fab color=\\\"primary\\\" on:click={() => clicked++} mini>",
		ctx
	});

	return block;
}

function create_fragment$5(ctx) {
	let div2;
	let div0;
	let fab0;
	let t0;
	let div1;
	let fab1;
	let t1;
	let pre;
	let t2;
	let t3;
	let current;

	fab0 = new Fab$1({
			props: {
				mini: true,
				$$slots: { default: [create_default_slot_2$4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	fab0.$on("click", /*click_handler*/ ctx[1]);

	fab1 = new Fab$1({
			props: {
				color: "primary",
				mini: true,
				$$slots: { default: [create_default_slot$5] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	fab1.$on("click", /*click_handler_1*/ ctx[2]);

	const block = {
		c: function create() {
			div2 = element("div");
			div0 = element("div");
			create_component(fab0.$$.fragment);
			t0 = space();
			div1 = element("div");
			create_component(fab1.$$.fragment);
			t1 = space();
			pre = element("pre");
			t2 = text("Clicked: ");
			t3 = text(/*clicked*/ ctx[0]);
			this.h();
		},
		l: function claim(nodes) {
			div2 = claim_element(nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			div0 = claim_element(div2_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			claim_component(fab0.$$.fragment, div0_nodes);
			div0_nodes.forEach(detach_dev);
			t0 = claim_space(div2_nodes);
			div1 = claim_element(div2_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			claim_component(fab1.$$.fragment, div1_nodes);
			div1_nodes.forEach(detach_dev);
			div2_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			pre = claim_element(nodes, "PRE", { class: true });
			var pre_nodes = children(pre);
			t2 = claim_text(pre_nodes, "Clicked: ");
			t3 = claim_text(pre_nodes, /*clicked*/ ctx[0]);
			pre_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "class", "margins");
			add_location(div0, file$5, 1, 2, 22);
			attr_dev(div1, "class", "margins");
			add_location(div1, file$5, 6, 2, 159);
			attr_dev(div2, "class", "flexy");
			add_location(div2, file$5, 0, 0, 0);
			attr_dev(pre, "class", "status");
			add_location(pre, file$5, 13, 0, 318);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div2, anchor);
			append_dev(div2, div0);
			mount_component(fab0, div0, null);
			append_dev(div2, t0);
			append_dev(div2, div1);
			mount_component(fab1, div1, null);
			insert_dev(target, t1, anchor);
			insert_dev(target, pre, anchor);
			append_dev(pre, t2);
			append_dev(pre, t3);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const fab0_changes = {};

			if (dirty & /*$$scope*/ 8) {
				fab0_changes.$$scope = { dirty, ctx };
			}

			fab0.$set(fab0_changes);
			const fab1_changes = {};

			if (dirty & /*$$scope*/ 8) {
				fab1_changes.$$scope = { dirty, ctx };
			}

			fab1.$set(fab1_changes);
			if (!current || dirty & /*clicked*/ 1) set_data_dev(t3, /*clicked*/ ctx[0]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(fab0.$$.fragment, local);
			transition_in(fab1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(fab0.$$.fragment, local);
			transition_out(fab1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div2);
			destroy_component(fab0);
			destroy_component(fab1);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(pre);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$5.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$5($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Mini", slots, []);
	let clicked = 0;
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Mini> was created with unknown prop '${key}'`);
	});

	const click_handler = () => $$invalidate(0, clicked++, clicked);
	const click_handler_1 = () => $$invalidate(0, clicked++, clicked);
	$$self.$capture_state = () => ({ Fab: Fab$1, Icon: CommonIcon, clicked });

	$$self.$inject_state = $$props => {
		if ("clicked" in $$props) $$invalidate(0, clicked = $$props.clicked);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [clicked, click_handler, click_handler_1];
}

class Mini extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$5, create_fragment$5, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Mini",
			options,
			id: create_fragment$5.name
		});
	}
}

/* src/routes/demo/fab/_Extended.svelte generated by Svelte v3.37.0 */
const file$4 = "src/routes/demo/fab/_Extended.svelte";

// (4:6) <Icon class="material-icons">
function create_default_slot_9$1(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("favorite");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "favorite");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_9$1.name,
		type: "slot",
		source: "(4:6) <Icon class=\\\"material-icons\\\">",
		ctx
	});

	return block;
}

// (5:6) <Label>
function create_default_slot_8$1(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Extended");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Extended");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_8$1.name,
		type: "slot",
		source: "(5:6) <Label>",
		ctx
	});

	return block;
}

// (3:4) <Fab on:click={() => clicked++} extended>
function create_default_slot_7$2(ctx) {
	let icon;
	let t;
	let label;
	let current;

	icon = new CommonIcon({
			props: {
				class: "material-icons",
				$$slots: { default: [create_default_slot_9$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	label = new CommonLabel({
			props: {
				$$slots: { default: [create_default_slot_8$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(icon.$$.fragment);
			t = space();
			create_component(label.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(icon.$$.fragment, nodes);
			t = claim_space(nodes);
			claim_component(label.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(icon, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(label, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const icon_changes = {};

			if (dirty & /*$$scope*/ 32) {
				icon_changes.$$scope = { dirty, ctx };
			}

			icon.$set(icon_changes);
			const label_changes = {};

			if (dirty & /*$$scope*/ 32) {
				label_changes.$$scope = { dirty, ctx };
			}

			label.$set(label_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			transition_in(label.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			transition_out(label.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(icon, detaching);
			if (detaching) detach_dev(t);
			destroy_component(label, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_7$2.name,
		type: "slot",
		source: "(3:4) <Fab on:click={() => clicked++} extended>",
		ctx
	});

	return block;
}

// (10:6) <Icon class="material-icons">
function create_default_slot_6$3(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("favorite");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "favorite");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_6$3.name,
		type: "slot",
		source: "(10:6) <Icon class=\\\"material-icons\\\">",
		ctx
	});

	return block;
}

// (11:6) <Label>
function create_default_slot_5$3(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Extended");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Extended");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_5$3.name,
		type: "slot",
		source: "(11:6) <Label>",
		ctx
	});

	return block;
}

// (9:4) <Fab color="primary" on:click={() => clicked++} extended>
function create_default_slot_4$3(ctx) {
	let icon;
	let t;
	let label;
	let current;

	icon = new CommonIcon({
			props: {
				class: "material-icons",
				$$slots: { default: [create_default_slot_6$3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	label = new CommonLabel({
			props: {
				$$slots: { default: [create_default_slot_5$3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(icon.$$.fragment);
			t = space();
			create_component(label.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(icon.$$.fragment, nodes);
			t = claim_space(nodes);
			claim_component(label.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(icon, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(label, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const icon_changes = {};

			if (dirty & /*$$scope*/ 32) {
				icon_changes.$$scope = { dirty, ctx };
			}

			icon.$set(icon_changes);
			const label_changes = {};

			if (dirty & /*$$scope*/ 32) {
				label_changes.$$scope = { dirty, ctx };
			}

			label.$set(label_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			transition_in(label.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			transition_out(label.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(icon, detaching);
			if (detaching) detach_dev(t);
			destroy_component(label, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_4$3.name,
		type: "slot",
		source: "(9:4) <Fab color=\\\"primary\\\" on:click={() => clicked++} extended>",
		ctx
	});

	return block;
}

// (16:6) <Label>
function create_default_slot_3$3(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Extended W/o Icon");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Extended W/o Icon");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3$3.name,
		type: "slot",
		source: "(16:6) <Label>",
		ctx
	});

	return block;
}

// (15:4) <Fab on:click={() => clicked++} extended>
function create_default_slot_2$3(ctx) {
	let label;
	let current;

	label = new CommonLabel({
			props: {
				$$slots: { default: [create_default_slot_3$3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(label.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(label.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(label, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const label_changes = {};

			if (dirty & /*$$scope*/ 32) {
				label_changes.$$scope = { dirty, ctx };
			}

			label.$set(label_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(label.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(label.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(label, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2$3.name,
		type: "slot",
		source: "(15:4) <Fab on:click={() => clicked++} extended>",
		ctx
	});

	return block;
}

// (21:6) <Label>
function create_default_slot_1$4(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Extended W/o Icon");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Extended W/o Icon");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$4.name,
		type: "slot",
		source: "(21:6) <Label>",
		ctx
	});

	return block;
}

// (20:4) <Fab color="primary" on:click={() => clicked++} extended>
function create_default_slot$4(ctx) {
	let label;
	let current;

	label = new CommonLabel({
			props: {
				$$slots: { default: [create_default_slot_1$4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(label.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(label.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(label, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const label_changes = {};

			if (dirty & /*$$scope*/ 32) {
				label_changes.$$scope = { dirty, ctx };
			}

			label.$set(label_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(label.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(label.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(label, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$4.name,
		type: "slot",
		source: "(20:4) <Fab color=\\\"primary\\\" on:click={() => clicked++} extended>",
		ctx
	});

	return block;
}

function create_fragment$4(ctx) {
	let div4;
	let div0;
	let fab0;
	let t0;
	let div1;
	let fab1;
	let t1;
	let div2;
	let fab2;
	let t2;
	let div3;
	let fab3;
	let t3;
	let pre;
	let t4;
	let t5;
	let current;

	fab0 = new Fab$1({
			props: {
				extended: true,
				$$slots: { default: [create_default_slot_7$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	fab0.$on("click", /*click_handler*/ ctx[1]);

	fab1 = new Fab$1({
			props: {
				color: "primary",
				extended: true,
				$$slots: { default: [create_default_slot_4$3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	fab1.$on("click", /*click_handler_1*/ ctx[2]);

	fab2 = new Fab$1({
			props: {
				extended: true,
				$$slots: { default: [create_default_slot_2$3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	fab2.$on("click", /*click_handler_2*/ ctx[3]);

	fab3 = new Fab$1({
			props: {
				color: "primary",
				extended: true,
				$$slots: { default: [create_default_slot$4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	fab3.$on("click", /*click_handler_3*/ ctx[4]);

	const block = {
		c: function create() {
			div4 = element("div");
			div0 = element("div");
			create_component(fab0.$$.fragment);
			t0 = space();
			div1 = element("div");
			create_component(fab1.$$.fragment);
			t1 = space();
			div2 = element("div");
			create_component(fab2.$$.fragment);
			t2 = space();
			div3 = element("div");
			create_component(fab3.$$.fragment);
			t3 = space();
			pre = element("pre");
			t4 = text("Clicked: ");
			t5 = text(/*clicked*/ ctx[0]);
			this.h();
		},
		l: function claim(nodes) {
			div4 = claim_element(nodes, "DIV", { class: true });
			var div4_nodes = children(div4);
			div0 = claim_element(div4_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			claim_component(fab0.$$.fragment, div0_nodes);
			div0_nodes.forEach(detach_dev);
			t0 = claim_space(div4_nodes);
			div1 = claim_element(div4_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			claim_component(fab1.$$.fragment, div1_nodes);
			div1_nodes.forEach(detach_dev);
			t1 = claim_space(div4_nodes);
			div2 = claim_element(div4_nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			claim_component(fab2.$$.fragment, div2_nodes);
			div2_nodes.forEach(detach_dev);
			t2 = claim_space(div4_nodes);
			div3 = claim_element(div4_nodes, "DIV", { class: true });
			var div3_nodes = children(div3);
			claim_component(fab3.$$.fragment, div3_nodes);
			div3_nodes.forEach(detach_dev);
			div4_nodes.forEach(detach_dev);
			t3 = claim_space(nodes);
			pre = claim_element(nodes, "PRE", { class: true });
			var pre_nodes = children(pre);
			t4 = claim_text(pre_nodes, "Clicked: ");
			t5 = claim_text(pre_nodes, /*clicked*/ ctx[0]);
			pre_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "class", "margins");
			add_location(div0, file$4, 1, 2, 22);
			attr_dev(div1, "class", "margins");
			add_location(div1, file$4, 7, 2, 193);
			attr_dev(div2, "class", "margins");
			add_location(div2, file$4, 13, 2, 380);
			attr_dev(div3, "class", "margins");
			add_location(div3, file$4, 18, 2, 509);
			attr_dev(div4, "class", "flexy");
			add_location(div4, file$4, 0, 0, 0);
			attr_dev(pre, "class", "status");
			add_location(pre, file$4, 25, 0, 660);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div4, anchor);
			append_dev(div4, div0);
			mount_component(fab0, div0, null);
			append_dev(div4, t0);
			append_dev(div4, div1);
			mount_component(fab1, div1, null);
			append_dev(div4, t1);
			append_dev(div4, div2);
			mount_component(fab2, div2, null);
			append_dev(div4, t2);
			append_dev(div4, div3);
			mount_component(fab3, div3, null);
			insert_dev(target, t3, anchor);
			insert_dev(target, pre, anchor);
			append_dev(pre, t4);
			append_dev(pre, t5);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const fab0_changes = {};

			if (dirty & /*$$scope*/ 32) {
				fab0_changes.$$scope = { dirty, ctx };
			}

			fab0.$set(fab0_changes);
			const fab1_changes = {};

			if (dirty & /*$$scope*/ 32) {
				fab1_changes.$$scope = { dirty, ctx };
			}

			fab1.$set(fab1_changes);
			const fab2_changes = {};

			if (dirty & /*$$scope*/ 32) {
				fab2_changes.$$scope = { dirty, ctx };
			}

			fab2.$set(fab2_changes);
			const fab3_changes = {};

			if (dirty & /*$$scope*/ 32) {
				fab3_changes.$$scope = { dirty, ctx };
			}

			fab3.$set(fab3_changes);
			if (!current || dirty & /*clicked*/ 1) set_data_dev(t5, /*clicked*/ ctx[0]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(fab0.$$.fragment, local);
			transition_in(fab1.$$.fragment, local);
			transition_in(fab2.$$.fragment, local);
			transition_in(fab3.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(fab0.$$.fragment, local);
			transition_out(fab1.$$.fragment, local);
			transition_out(fab2.$$.fragment, local);
			transition_out(fab3.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div4);
			destroy_component(fab0);
			destroy_component(fab1);
			destroy_component(fab2);
			destroy_component(fab3);
			if (detaching) detach_dev(t3);
			if (detaching) detach_dev(pre);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Extended", slots, []);
	let clicked = 0;
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Extended> was created with unknown prop '${key}'`);
	});

	const click_handler = () => $$invalidate(0, clicked++, clicked);
	const click_handler_1 = () => $$invalidate(0, clicked++, clicked);
	const click_handler_2 = () => $$invalidate(0, clicked++, clicked);
	const click_handler_3 = () => $$invalidate(0, clicked++, clicked);
	$$self.$capture_state = () => ({ Fab: Fab$1, Label: CommonLabel, Icon: CommonIcon, clicked });

	$$self.$inject_state = $$props => {
		if ("clicked" in $$props) $$invalidate(0, clicked = $$props.clicked);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [clicked, click_handler, click_handler_1, click_handler_2, click_handler_3];
}

class Extended extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4, create_fragment$4, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Extended",
			options,
			id: create_fragment$4.name
		});
	}
}

/* src/routes/demo/fab/_NoRipple.svelte generated by Svelte v3.37.0 */
const file$3 = "src/routes/demo/fab/_NoRipple.svelte";

// (4:6) <Icon class="material-icons">
function create_default_slot_9(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("favorite");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "favorite");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_9.name,
		type: "slot",
		source: "(4:6) <Icon class=\\\"material-icons\\\">",
		ctx
	});

	return block;
}

// (3:4) <Fab on:click={() => clicked++} ripple={false}>
function create_default_slot_8(ctx) {
	let icon;
	let current;

	icon = new CommonIcon({
			props: {
				class: "material-icons",
				$$slots: { default: [create_default_slot_9] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(icon.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(icon.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(icon, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const icon_changes = {};

			if (dirty & /*$$scope*/ 32) {
				icon_changes.$$scope = { dirty, ctx };
			}

			icon.$set(icon_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(icon, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_8.name,
		type: "slot",
		source: "(3:4) <Fab on:click={() => clicked++} ripple={false}>",
		ctx
	});

	return block;
}

// (9:6) <Icon class="material-icons">
function create_default_slot_7$1(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("favorite");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "favorite");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_7$1.name,
		type: "slot",
		source: "(9:6) <Icon class=\\\"material-icons\\\">",
		ctx
	});

	return block;
}

// (8:4) <Fab color="primary" on:click={() => clicked++} ripple={false}>
function create_default_slot_6$2(ctx) {
	let icon;
	let current;

	icon = new CommonIcon({
			props: {
				class: "material-icons",
				$$slots: { default: [create_default_slot_7$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(icon.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(icon.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(icon, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const icon_changes = {};

			if (dirty & /*$$scope*/ 32) {
				icon_changes.$$scope = { dirty, ctx };
			}

			icon.$set(icon_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(icon, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_6$2.name,
		type: "slot",
		source: "(8:4) <Fab color=\\\"primary\\\" on:click={() => clicked++} ripple={false}>",
		ctx
	});

	return block;
}

// (14:6) <Icon class="material-icons">
function create_default_slot_5$2(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("favorite");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "favorite");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_5$2.name,
		type: "slot",
		source: "(14:6) <Icon class=\\\"material-icons\\\">",
		ctx
	});

	return block;
}

// (15:6) <Label>
function create_default_slot_4$2(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Extended");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Extended");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_4$2.name,
		type: "slot",
		source: "(15:6) <Label>",
		ctx
	});

	return block;
}

// (13:4) <Fab on:click={() => clicked++} extended ripple={false}>
function create_default_slot_3$2(ctx) {
	let icon;
	let t;
	let label;
	let current;

	icon = new CommonIcon({
			props: {
				class: "material-icons",
				$$slots: { default: [create_default_slot_5$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	label = new CommonLabel({
			props: {
				$$slots: { default: [create_default_slot_4$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(icon.$$.fragment);
			t = space();
			create_component(label.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(icon.$$.fragment, nodes);
			t = claim_space(nodes);
			claim_component(label.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(icon, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(label, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const icon_changes = {};

			if (dirty & /*$$scope*/ 32) {
				icon_changes.$$scope = { dirty, ctx };
			}

			icon.$set(icon_changes);
			const label_changes = {};

			if (dirty & /*$$scope*/ 32) {
				label_changes.$$scope = { dirty, ctx };
			}

			label.$set(label_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			transition_in(label.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			transition_out(label.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(icon, detaching);
			if (detaching) detach_dev(t);
			destroy_component(label, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3$2.name,
		type: "slot",
		source: "(13:4) <Fab on:click={() => clicked++} extended ripple={false}>",
		ctx
	});

	return block;
}

// (20:6) <Icon class="material-icons">
function create_default_slot_2$2(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("favorite");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "favorite");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2$2.name,
		type: "slot",
		source: "(20:6) <Icon class=\\\"material-icons\\\">",
		ctx
	});

	return block;
}

// (21:6) <Label>
function create_default_slot_1$3(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Extended");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Extended");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$3.name,
		type: "slot",
		source: "(21:6) <Label>",
		ctx
	});

	return block;
}

// (19:4) <Fab color="primary" on:click={() => clicked++} extended ripple={false}>
function create_default_slot$3(ctx) {
	let icon;
	let t;
	let label;
	let current;

	icon = new CommonIcon({
			props: {
				class: "material-icons",
				$$slots: { default: [create_default_slot_2$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	label = new CommonLabel({
			props: {
				$$slots: { default: [create_default_slot_1$3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(icon.$$.fragment);
			t = space();
			create_component(label.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(icon.$$.fragment, nodes);
			t = claim_space(nodes);
			claim_component(label.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(icon, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(label, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const icon_changes = {};

			if (dirty & /*$$scope*/ 32) {
				icon_changes.$$scope = { dirty, ctx };
			}

			icon.$set(icon_changes);
			const label_changes = {};

			if (dirty & /*$$scope*/ 32) {
				label_changes.$$scope = { dirty, ctx };
			}

			label.$set(label_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			transition_in(label.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			transition_out(label.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(icon, detaching);
			if (detaching) detach_dev(t);
			destroy_component(label, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$3.name,
		type: "slot",
		source: "(19:4) <Fab color=\\\"primary\\\" on:click={() => clicked++} extended ripple={false}>",
		ctx
	});

	return block;
}

function create_fragment$3(ctx) {
	let div4;
	let div0;
	let fab0;
	let t0;
	let div1;
	let fab1;
	let t1;
	let div2;
	let fab2;
	let t2;
	let div3;
	let fab3;
	let t3;
	let pre;
	let t4;
	let t5;
	let current;

	fab0 = new Fab$1({
			props: {
				ripple: false,
				$$slots: { default: [create_default_slot_8] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	fab0.$on("click", /*click_handler*/ ctx[1]);

	fab1 = new Fab$1({
			props: {
				color: "primary",
				ripple: false,
				$$slots: { default: [create_default_slot_6$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	fab1.$on("click", /*click_handler_1*/ ctx[2]);

	fab2 = new Fab$1({
			props: {
				extended: true,
				ripple: false,
				$$slots: { default: [create_default_slot_3$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	fab2.$on("click", /*click_handler_2*/ ctx[3]);

	fab3 = new Fab$1({
			props: {
				color: "primary",
				extended: true,
				ripple: false,
				$$slots: { default: [create_default_slot$3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	fab3.$on("click", /*click_handler_3*/ ctx[4]);

	const block = {
		c: function create() {
			div4 = element("div");
			div0 = element("div");
			create_component(fab0.$$.fragment);
			t0 = space();
			div1 = element("div");
			create_component(fab1.$$.fragment);
			t1 = space();
			div2 = element("div");
			create_component(fab2.$$.fragment);
			t2 = space();
			div3 = element("div");
			create_component(fab3.$$.fragment);
			t3 = space();
			pre = element("pre");
			t4 = text("Clicked: ");
			t5 = text(/*clicked*/ ctx[0]);
			this.h();
		},
		l: function claim(nodes) {
			div4 = claim_element(nodes, "DIV", { class: true });
			var div4_nodes = children(div4);
			div0 = claim_element(div4_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			claim_component(fab0.$$.fragment, div0_nodes);
			div0_nodes.forEach(detach_dev);
			t0 = claim_space(div4_nodes);
			div1 = claim_element(div4_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			claim_component(fab1.$$.fragment, div1_nodes);
			div1_nodes.forEach(detach_dev);
			t1 = claim_space(div4_nodes);
			div2 = claim_element(div4_nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			claim_component(fab2.$$.fragment, div2_nodes);
			div2_nodes.forEach(detach_dev);
			t2 = claim_space(div4_nodes);
			div3 = claim_element(div4_nodes, "DIV", { class: true });
			var div3_nodes = children(div3);
			claim_component(fab3.$$.fragment, div3_nodes);
			div3_nodes.forEach(detach_dev);
			div4_nodes.forEach(detach_dev);
			t3 = claim_space(nodes);
			pre = claim_element(nodes, "PRE", { class: true });
			var pre_nodes = children(pre);
			t4 = claim_text(pre_nodes, "Clicked: ");
			t5 = claim_text(pre_nodes, /*clicked*/ ctx[0]);
			pre_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "class", "margins");
			add_location(div0, file$3, 1, 2, 22);
			attr_dev(div1, "class", "margins");
			add_location(div1, file$3, 6, 2, 169);
			attr_dev(div2, "class", "margins");
			add_location(div2, file$3, 11, 2, 332);
			attr_dev(div3, "class", "margins");
			add_location(div3, file$3, 17, 2, 518);
			attr_dev(div4, "class", "flexy");
			add_location(div4, file$3, 0, 0, 0);
			attr_dev(pre, "class", "status");
			add_location(pre, file$3, 25, 0, 726);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div4, anchor);
			append_dev(div4, div0);
			mount_component(fab0, div0, null);
			append_dev(div4, t0);
			append_dev(div4, div1);
			mount_component(fab1, div1, null);
			append_dev(div4, t1);
			append_dev(div4, div2);
			mount_component(fab2, div2, null);
			append_dev(div4, t2);
			append_dev(div4, div3);
			mount_component(fab3, div3, null);
			insert_dev(target, t3, anchor);
			insert_dev(target, pre, anchor);
			append_dev(pre, t4);
			append_dev(pre, t5);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const fab0_changes = {};

			if (dirty & /*$$scope*/ 32) {
				fab0_changes.$$scope = { dirty, ctx };
			}

			fab0.$set(fab0_changes);
			const fab1_changes = {};

			if (dirty & /*$$scope*/ 32) {
				fab1_changes.$$scope = { dirty, ctx };
			}

			fab1.$set(fab1_changes);
			const fab2_changes = {};

			if (dirty & /*$$scope*/ 32) {
				fab2_changes.$$scope = { dirty, ctx };
			}

			fab2.$set(fab2_changes);
			const fab3_changes = {};

			if (dirty & /*$$scope*/ 32) {
				fab3_changes.$$scope = { dirty, ctx };
			}

			fab3.$set(fab3_changes);
			if (!current || dirty & /*clicked*/ 1) set_data_dev(t5, /*clicked*/ ctx[0]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(fab0.$$.fragment, local);
			transition_in(fab1.$$.fragment, local);
			transition_in(fab2.$$.fragment, local);
			transition_in(fab3.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(fab0.$$.fragment, local);
			transition_out(fab1.$$.fragment, local);
			transition_out(fab2.$$.fragment, local);
			transition_out(fab3.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div4);
			destroy_component(fab0);
			destroy_component(fab1);
			destroy_component(fab2);
			destroy_component(fab3);
			if (detaching) detach_dev(t3);
			if (detaching) detach_dev(pre);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("NoRipple", slots, []);
	let clicked = 0;
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<NoRipple> was created with unknown prop '${key}'`);
	});

	const click_handler = () => $$invalidate(0, clicked++, clicked);
	const click_handler_1 = () => $$invalidate(0, clicked++, clicked);
	const click_handler_2 = () => $$invalidate(0, clicked++, clicked);
	const click_handler_3 = () => $$invalidate(0, clicked++, clicked);
	$$self.$capture_state = () => ({ Fab: Fab$1, Label: CommonLabel, Icon: CommonIcon, clicked });

	$$self.$inject_state = $$props => {
		if ("clicked" in $$props) $$invalidate(0, clicked = $$props.clicked);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [clicked, click_handler, click_handler_1, click_handler_2, click_handler_3];
}

class NoRipple extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3, create_fragment$3, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "NoRipple",
			options,
			id: create_fragment$3.name
		});
	}
}

/* src/routes/demo/fab/_Link.svelte generated by Svelte v3.37.0 */
const file$2 = "src/routes/demo/fab/_Link.svelte";

// (4:6) <Icon class="material-icons">
function create_default_slot_7(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("favorite");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "favorite");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_7.name,
		type: "slot",
		source: "(4:6) <Icon class=\\\"material-icons\\\">",
		ctx
	});

	return block;
}

// (3:4) <Fab on:click={() => clicked++} href="http://example.com" target="_blank">
function create_default_slot_6$1(ctx) {
	let icon;
	let current;

	icon = new CommonIcon({
			props: {
				class: "material-icons",
				$$slots: { default: [create_default_slot_7] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(icon.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(icon.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(icon, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const icon_changes = {};

			if (dirty & /*$$scope*/ 32) {
				icon_changes.$$scope = { dirty, ctx };
			}

			icon.$set(icon_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(icon, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_6$1.name,
		type: "slot",
		source: "(3:4) <Fab on:click={() => clicked++} href=\\\"http://example.com\\\" target=\\\"_blank\\\">",
		ctx
	});

	return block;
}

// (14:6) <Icon class="material-icons">
function create_default_slot_5$1(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("favorite");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "favorite");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_5$1.name,
		type: "slot",
		source: "(14:6) <Icon class=\\\"material-icons\\\">",
		ctx
	});

	return block;
}

// (8:4) <Fab       color="primary"       on:click={() => clicked++}       href="http://example.com"       target="_blank"     >
function create_default_slot_4$1(ctx) {
	let icon;
	let current;

	icon = new CommonIcon({
			props: {
				class: "material-icons",
				$$slots: { default: [create_default_slot_5$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(icon.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(icon.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(icon, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const icon_changes = {};

			if (dirty & /*$$scope*/ 32) {
				icon_changes.$$scope = { dirty, ctx };
			}

			icon.$set(icon_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(icon, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_4$1.name,
		type: "slot",
		source: "(8:4) <Fab       color=\\\"primary\\\"       on:click={() => clicked++}       href=\\\"http://example.com\\\"       target=\\\"_blank\\\"     >",
		ctx
	});

	return block;
}

// (24:6) <Label>
function create_default_slot_3$1(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Link");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Link");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3$1.name,
		type: "slot",
		source: "(24:6) <Label>",
		ctx
	});

	return block;
}

// (18:4) <Fab       on:click={() => clicked++}       href="http://example.com"       target="_blank"       extended     >
function create_default_slot_2$1(ctx) {
	let label;
	let current;

	label = new CommonLabel({
			props: {
				$$slots: { default: [create_default_slot_3$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(label.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(label.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(label, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const label_changes = {};

			if (dirty & /*$$scope*/ 32) {
				label_changes.$$scope = { dirty, ctx };
			}

			label.$set(label_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(label.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(label.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(label, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2$1.name,
		type: "slot",
		source: "(18:4) <Fab       on:click={() => clicked++}       href=\\\"http://example.com\\\"       target=\\\"_blank\\\"       extended     >",
		ctx
	});

	return block;
}

// (35:6) <Label>
function create_default_slot_1$2(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Link");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Link");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$2.name,
		type: "slot",
		source: "(35:6) <Label>",
		ctx
	});

	return block;
}

// (28:4) <Fab       color="primary"       on:click={() => clicked++}       href="http://example.com"       target="_blank"       extended     >
function create_default_slot$2(ctx) {
	let label;
	let current;

	label = new CommonLabel({
			props: {
				$$slots: { default: [create_default_slot_1$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(label.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(label.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(label, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const label_changes = {};

			if (dirty & /*$$scope*/ 32) {
				label_changes.$$scope = { dirty, ctx };
			}

			label.$set(label_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(label.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(label.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(label, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$2.name,
		type: "slot",
		source: "(28:4) <Fab       color=\\\"primary\\\"       on:click={() => clicked++}       href=\\\"http://example.com\\\"       target=\\\"_blank\\\"       extended     >",
		ctx
	});

	return block;
}

function create_fragment$2(ctx) {
	let div4;
	let div0;
	let fab0;
	let t0;
	let div1;
	let fab1;
	let t1;
	let div2;
	let fab2;
	let t2;
	let div3;
	let fab3;
	let t3;
	let pre;
	let t4;
	let t5;
	let current;

	fab0 = new Fab$1({
			props: {
				href: "http://example.com",
				target: "_blank",
				$$slots: { default: [create_default_slot_6$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	fab0.$on("click", /*click_handler*/ ctx[1]);

	fab1 = new Fab$1({
			props: {
				color: "primary",
				href: "http://example.com",
				target: "_blank",
				$$slots: { default: [create_default_slot_4$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	fab1.$on("click", /*click_handler_1*/ ctx[2]);

	fab2 = new Fab$1({
			props: {
				href: "http://example.com",
				target: "_blank",
				extended: true,
				$$slots: { default: [create_default_slot_2$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	fab2.$on("click", /*click_handler_2*/ ctx[3]);

	fab3 = new Fab$1({
			props: {
				color: "primary",
				href: "http://example.com",
				target: "_blank",
				extended: true,
				$$slots: { default: [create_default_slot$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	fab3.$on("click", /*click_handler_3*/ ctx[4]);

	const block = {
		c: function create() {
			div4 = element("div");
			div0 = element("div");
			create_component(fab0.$$.fragment);
			t0 = space();
			div1 = element("div");
			create_component(fab1.$$.fragment);
			t1 = space();
			div2 = element("div");
			create_component(fab2.$$.fragment);
			t2 = space();
			div3 = element("div");
			create_component(fab3.$$.fragment);
			t3 = space();
			pre = element("pre");
			t4 = text("Clicked: ");
			t5 = text(/*clicked*/ ctx[0]);
			this.h();
		},
		l: function claim(nodes) {
			div4 = claim_element(nodes, "DIV", { class: true });
			var div4_nodes = children(div4);
			div0 = claim_element(div4_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			claim_component(fab0.$$.fragment, div0_nodes);
			div0_nodes.forEach(detach_dev);
			t0 = claim_space(div4_nodes);
			div1 = claim_element(div4_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			claim_component(fab1.$$.fragment, div1_nodes);
			div1_nodes.forEach(detach_dev);
			t1 = claim_space(div4_nodes);
			div2 = claim_element(div4_nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			claim_component(fab2.$$.fragment, div2_nodes);
			div2_nodes.forEach(detach_dev);
			t2 = claim_space(div4_nodes);
			div3 = claim_element(div4_nodes, "DIV", { class: true });
			var div3_nodes = children(div3);
			claim_component(fab3.$$.fragment, div3_nodes);
			div3_nodes.forEach(detach_dev);
			div4_nodes.forEach(detach_dev);
			t3 = claim_space(nodes);
			pre = claim_element(nodes, "PRE", { class: true });
			var pre_nodes = children(pre);
			t4 = claim_text(pre_nodes, "Clicked: ");
			t5 = claim_text(pre_nodes, /*clicked*/ ctx[0]);
			pre_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "class", "margins");
			add_location(div0, file$2, 1, 2, 22);
			attr_dev(div1, "class", "margins");
			add_location(div1, file$2, 6, 2, 196);
			attr_dev(div2, "class", "margins");
			add_location(div2, file$2, 16, 2, 415);
			attr_dev(div3, "class", "margins");
			add_location(div3, file$2, 26, 2, 602);
			attr_dev(div4, "class", "flexy");
			add_location(div4, file$2, 0, 0, 0);
			attr_dev(pre, "class", "status");
			add_location(pre, file$2, 39, 0, 817);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div4, anchor);
			append_dev(div4, div0);
			mount_component(fab0, div0, null);
			append_dev(div4, t0);
			append_dev(div4, div1);
			mount_component(fab1, div1, null);
			append_dev(div4, t1);
			append_dev(div4, div2);
			mount_component(fab2, div2, null);
			append_dev(div4, t2);
			append_dev(div4, div3);
			mount_component(fab3, div3, null);
			insert_dev(target, t3, anchor);
			insert_dev(target, pre, anchor);
			append_dev(pre, t4);
			append_dev(pre, t5);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const fab0_changes = {};

			if (dirty & /*$$scope*/ 32) {
				fab0_changes.$$scope = { dirty, ctx };
			}

			fab0.$set(fab0_changes);
			const fab1_changes = {};

			if (dirty & /*$$scope*/ 32) {
				fab1_changes.$$scope = { dirty, ctx };
			}

			fab1.$set(fab1_changes);
			const fab2_changes = {};

			if (dirty & /*$$scope*/ 32) {
				fab2_changes.$$scope = { dirty, ctx };
			}

			fab2.$set(fab2_changes);
			const fab3_changes = {};

			if (dirty & /*$$scope*/ 32) {
				fab3_changes.$$scope = { dirty, ctx };
			}

			fab3.$set(fab3_changes);
			if (!current || dirty & /*clicked*/ 1) set_data_dev(t5, /*clicked*/ ctx[0]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(fab0.$$.fragment, local);
			transition_in(fab1.$$.fragment, local);
			transition_in(fab2.$$.fragment, local);
			transition_in(fab3.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(fab0.$$.fragment, local);
			transition_out(fab1.$$.fragment, local);
			transition_out(fab2.$$.fragment, local);
			transition_out(fab3.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div4);
			destroy_component(fab0);
			destroy_component(fab1);
			destroy_component(fab2);
			destroy_component(fab3);
			if (detaching) detach_dev(t3);
			if (detaching) detach_dev(pre);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Link", slots, []);
	let clicked = 0;
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Link> was created with unknown prop '${key}'`);
	});

	const click_handler = () => $$invalidate(0, clicked++, clicked);
	const click_handler_1 = () => $$invalidate(0, clicked++, clicked);
	const click_handler_2 = () => $$invalidate(0, clicked++, clicked);
	const click_handler_3 = () => $$invalidate(0, clicked++, clicked);
	$$self.$capture_state = () => ({ Fab: Fab$1, Label: CommonLabel, Icon: CommonIcon, clicked });

	$$self.$inject_state = $$props => {
		if ("clicked" in $$props) $$invalidate(0, clicked = $$props.clicked);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [clicked, click_handler, click_handler_1, click_handler_2, click_handler_3];
}

class Link extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2, create_fragment$2, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Link",
			options,
			id: create_fragment$2.name
		});
	}
}

/* src/routes/demo/fab/_Svg.svelte generated by Svelte v3.37.0 */
const file$1 = "src/routes/demo/fab/_Svg.svelte";

// (9:6) <Icon component={Svg} viewBox="2 2 20 20">
function create_default_slot_1$1(ctx) {
	let path;

	const block = {
		c: function create() {
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_element(nodes, "path", { fill: true, d: true, class: true }, 1);
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "fill", "currentColor");
			attr_dev(path, "d", mdiPlus);
			attr_dev(path, "class", "svelte-1jxe9r6");
			add_location(path, file$1, 9, 8, 301);
		},
		m: function mount(target, anchor) {
			insert_dev(target, path, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$1.name,
		type: "slot",
		source: "(9:6) <Icon component={Svg} viewBox=\\\"2 2 20 20\\\">",
		ctx
	});

	return block;
}

// (8:4) <Fab on:click={() => clicked++}>
function create_default_slot$1(ctx) {
	let icon;
	let current;

	icon = new CommonIcon({
			props: {
				component: Svg$1,
				viewBox: "2 2 20 20",
				$$slots: { default: [create_default_slot_1$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(icon.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(icon.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(icon, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const icon_changes = {};

			if (dirty & /*$$scope*/ 4) {
				icon_changes.$$scope = { dirty, ctx };
			}

			icon.$set(icon_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(icon, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$1.name,
		type: "slot",
		source: "(8:4) <Fab on:click={() => clicked++}>",
		ctx
	});

	return block;
}

function create_fragment$1(ctx) {
	let div1;
	let div0;
	let fab;
	let t0;
	let pre;
	let t1;
	let t2;
	let current;

	fab = new Fab$1({
			props: {
				$$slots: { default: [create_default_slot$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	fab.$on("click", /*click_handler*/ ctx[1]);

	const block = {
		c: function create() {
			div1 = element("div");
			div0 = element("div");
			create_component(fab.$$.fragment);
			t0 = space();
			pre = element("pre");
			t1 = text("Clicked: ");
			t2 = text(/*clicked*/ ctx[0]);
			this.h();
		},
		l: function claim(nodes) {
			div1 = claim_element(nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			claim_component(fab.$$.fragment, div0_nodes);
			div0_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			t0 = claim_space(nodes);
			pre = claim_element(nodes, "PRE", { class: true });
			var pre_nodes = children(pre);
			t1 = claim_text(pre_nodes, "Clicked: ");
			t2 = claim_text(pre_nodes, /*clicked*/ ctx[0]);
			pre_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "class", "margins svelte-1jxe9r6");
			add_location(div0, file$1, 1, 2, 22);
			attr_dev(div1, "class", "flexy svelte-1jxe9r6");
			add_location(div1, file$1, 0, 0, 0);
			attr_dev(pre, "class", "status svelte-1jxe9r6");
			add_location(pre, file$1, 15, 0, 384);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);
			mount_component(fab, div0, null);
			insert_dev(target, t0, anchor);
			insert_dev(target, pre, anchor);
			append_dev(pre, t1);
			append_dev(pre, t2);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const fab_changes = {};

			if (dirty & /*$$scope*/ 4) {
				fab_changes.$$scope = { dirty, ctx };
			}

			fab.$set(fab_changes);
			if (!current || dirty & /*clicked*/ 1) set_data_dev(t2, /*clicked*/ ctx[0]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(fab.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(fab.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			destroy_component(fab);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(pre);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Svg", slots, []);
	let clicked = 0;
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Svg> was created with unknown prop '${key}'`);
	});

	const click_handler = () => $$invalidate(0, clicked++, clicked);
	$$self.$capture_state = () => ({ Fab: Fab$1, Icon: CommonIcon, Svg: Svg$1, mdiPlus, clicked });

	$$self.$inject_state = $$props => {
		if ("clicked" in $$props) $$invalidate(0, clicked = $$props.clicked);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [clicked, click_handler];
}

class Svg_1 extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$1, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Svg_1",
			options,
			id: create_fragment$1.name
		});
	}
}

/* src/routes/demo/fab/index.svelte generated by Svelte v3.37.0 */
const file = "src/routes/demo/fab/index.svelte";

// (12:2) <Demo component={PrimaryColor} file="fab/_PrimaryColor.svelte">
function create_default_slot_6(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Primary color");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Primary color");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_6.name,
		type: "slot",
		source: "(12:2) <Demo component={PrimaryColor} file=\\\"fab/_PrimaryColor.svelte\\\">",
		ctx
	});

	return block;
}

// (16:2) <Demo component={Exited} file="fab/_Exited.svelte">
function create_default_slot_5(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Exited");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Exited");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_5.name,
		type: "slot",
		source: "(16:2) <Demo component={Exited} file=\\\"fab/_Exited.svelte\\\">",
		ctx
	});

	return block;
}

// (18:2) <Demo component={Mini} file="fab/_Mini.svelte">
function create_default_slot_4(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Mini");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Mini");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_4.name,
		type: "slot",
		source: "(18:2) <Demo component={Mini} file=\\\"fab/_Mini.svelte\\\">",
		ctx
	});

	return block;
}

// (20:2) <Demo component={Extended} file="fab/_Extended.svelte">
function create_default_slot_3(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Extended");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Extended");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3.name,
		type: "slot",
		source: "(20:2) <Demo component={Extended} file=\\\"fab/_Extended.svelte\\\">",
		ctx
	});

	return block;
}

// (22:2) <Demo component={NoRipple} file="fab/_NoRipple.svelte">
function create_default_slot_2(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("No Ripple");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "No Ripple");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2.name,
		type: "slot",
		source: "(22:2) <Demo component={NoRipple} file=\\\"fab/_NoRipple.svelte\\\">",
		ctx
	});

	return block;
}

// (24:2) <Demo component={Link} file="fab/_Link.svelte">
function create_default_slot_1(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Link");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Link");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1.name,
		type: "slot",
		source: "(24:2) <Demo component={Link} file=\\\"fab/_Link.svelte\\\">",
		ctx
	});

	return block;
}

// (26:2) <Demo component={Svg} file="fab/_Svg.svelte">
function create_default_slot(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Svg");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Svg");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(26:2) <Demo component={Svg} file=\\\"fab/_Svg.svelte\\\">",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let t0;
	let section;
	let h2;
	let t1;
	let t2;
	let pre;
	let t3;
	let t4;
	let demo0;
	let t5;
	let demo1;
	let t6;
	let demo2;
	let t7;
	let demo3;
	let t8;
	let demo4;
	let t9;
	let demo5;
	let t10;
	let demo6;
	let t11;
	let demo7;
	let current;

	demo0 = new Demo({
			props: {
				component: Simple,
				file: "fab/_Simple.svelte"
			},
			$$inline: true
		});

	demo1 = new Demo({
			props: {
				component: PrimaryColor,
				file: "fab/_PrimaryColor.svelte",
				$$slots: { default: [create_default_slot_6] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	demo2 = new Demo({
			props: {
				component: Exited,
				file: "fab/_Exited.svelte",
				$$slots: { default: [create_default_slot_5] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	demo3 = new Demo({
			props: {
				component: Mini,
				file: "fab/_Mini.svelte",
				$$slots: { default: [create_default_slot_4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	demo4 = new Demo({
			props: {
				component: Extended,
				file: "fab/_Extended.svelte",
				$$slots: { default: [create_default_slot_3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	demo5 = new Demo({
			props: {
				component: NoRipple,
				file: "fab/_NoRipple.svelte",
				$$slots: { default: [create_default_slot_2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	demo6 = new Demo({
			props: {
				component: Link,
				file: "fab/_Link.svelte",
				$$slots: { default: [create_default_slot_1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	demo7 = new Demo({
			props: {
				component: Svg_1,
				file: "fab/_Svg.svelte",
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			t0 = space();
			section = element("section");
			h2 = element("h2");
			t1 = text("Floating Action Button");
			t2 = space();
			pre = element("pre");
			t3 = text("npm i -D @smui/fab");
			t4 = space();
			create_component(demo0.$$.fragment);
			t5 = space();
			create_component(demo1.$$.fragment);
			t6 = space();
			create_component(demo2.$$.fragment);
			t7 = space();
			create_component(demo3.$$.fragment);
			t8 = space();
			create_component(demo4.$$.fragment);
			t9 = space();
			create_component(demo5.$$.fragment);
			t10 = space();
			create_component(demo6.$$.fragment);
			t11 = space();
			create_component(demo7.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			const head_nodes = query_selector_all("[data-svelte=\"svelte-1gv1vuy\"]", document.head);
			head_nodes.forEach(detach_dev);
			t0 = claim_space(nodes);
			section = claim_element(nodes, "SECTION", { class: true });
			var section_nodes = children(section);
			h2 = claim_element(section_nodes, "H2", { class: true });
			var h2_nodes = children(h2);
			t1 = claim_text(h2_nodes, "Floating Action Button");
			h2_nodes.forEach(detach_dev);
			t2 = claim_space(section_nodes);
			pre = claim_element(section_nodes, "PRE", { class: true });
			var pre_nodes = children(pre);
			t3 = claim_text(pre_nodes, "npm i -D @smui/fab");
			pre_nodes.forEach(detach_dev);
			t4 = claim_space(section_nodes);
			claim_component(demo0.$$.fragment, section_nodes);
			t5 = claim_space(section_nodes);
			claim_component(demo1.$$.fragment, section_nodes);
			t6 = claim_space(section_nodes);
			claim_component(demo2.$$.fragment, section_nodes);
			t7 = claim_space(section_nodes);
			claim_component(demo3.$$.fragment, section_nodes);
			t8 = claim_space(section_nodes);
			claim_component(demo4.$$.fragment, section_nodes);
			t9 = claim_space(section_nodes);
			claim_component(demo5.$$.fragment, section_nodes);
			t10 = claim_space(section_nodes);
			claim_component(demo6.$$.fragment, section_nodes);
			t11 = claim_space(section_nodes);
			claim_component(demo7.$$.fragment, section_nodes);
			section_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			document.title = "Floating Action Button - SMUI";
			attr_dev(h2, "class", "svelte-103g704");
			add_location(h2, file, 5, 2, 89);
			attr_dev(pre, "class", "demo-spaced svelte-103g704");
			add_location(pre, file, 7, 2, 124);
			attr_dev(section, "class", "svelte-103g704");
			add_location(section, file, 4, 0, 77);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			insert_dev(target, section, anchor);
			append_dev(section, h2);
			append_dev(h2, t1);
			append_dev(section, t2);
			append_dev(section, pre);
			append_dev(pre, t3);
			append_dev(section, t4);
			mount_component(demo0, section, null);
			append_dev(section, t5);
			mount_component(demo1, section, null);
			append_dev(section, t6);
			mount_component(demo2, section, null);
			append_dev(section, t7);
			mount_component(demo3, section, null);
			append_dev(section, t8);
			mount_component(demo4, section, null);
			append_dev(section, t9);
			mount_component(demo5, section, null);
			append_dev(section, t10);
			mount_component(demo6, section, null);
			append_dev(section, t11);
			mount_component(demo7, section, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const demo1_changes = {};

			if (dirty & /*$$scope*/ 1) {
				demo1_changes.$$scope = { dirty, ctx };
			}

			demo1.$set(demo1_changes);
			const demo2_changes = {};

			if (dirty & /*$$scope*/ 1) {
				demo2_changes.$$scope = { dirty, ctx };
			}

			demo2.$set(demo2_changes);
			const demo3_changes = {};

			if (dirty & /*$$scope*/ 1) {
				demo3_changes.$$scope = { dirty, ctx };
			}

			demo3.$set(demo3_changes);
			const demo4_changes = {};

			if (dirty & /*$$scope*/ 1) {
				demo4_changes.$$scope = { dirty, ctx };
			}

			demo4.$set(demo4_changes);
			const demo5_changes = {};

			if (dirty & /*$$scope*/ 1) {
				demo5_changes.$$scope = { dirty, ctx };
			}

			demo5.$set(demo5_changes);
			const demo6_changes = {};

			if (dirty & /*$$scope*/ 1) {
				demo6_changes.$$scope = { dirty, ctx };
			}

			demo6.$set(demo6_changes);
			const demo7_changes = {};

			if (dirty & /*$$scope*/ 1) {
				demo7_changes.$$scope = { dirty, ctx };
			}

			demo7.$set(demo7_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(demo0.$$.fragment, local);
			transition_in(demo1.$$.fragment, local);
			transition_in(demo2.$$.fragment, local);
			transition_in(demo3.$$.fragment, local);
			transition_in(demo4.$$.fragment, local);
			transition_in(demo5.$$.fragment, local);
			transition_in(demo6.$$.fragment, local);
			transition_in(demo7.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(demo0.$$.fragment, local);
			transition_out(demo1.$$.fragment, local);
			transition_out(demo2.$$.fragment, local);
			transition_out(demo3.$$.fragment, local);
			transition_out(demo4.$$.fragment, local);
			transition_out(demo5.$$.fragment, local);
			transition_out(demo6.$$.fragment, local);
			transition_out(demo7.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(section);
			destroy_component(demo0);
			destroy_component(demo1);
			destroy_component(demo2);
			destroy_component(demo3);
			destroy_component(demo4);
			destroy_component(demo5);
			destroy_component(demo6);
			destroy_component(demo7);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Fab", slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Fab> was created with unknown prop '${key}'`);
	});

	$$self.$capture_state = () => ({
		Demo,
		Simple,
		PrimaryColor,
		Exited,
		Mini,
		Extended,
		NoRipple,
		Link,
		Svg: Svg_1
	});

	return [];
}

class Fab extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Fab",
			options,
			id: create_fragment.name
		});
	}
}

export default Fab;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguMDcyNWQ4NGYuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3BhY2thZ2VzL2ZhYi9ub2RlX21vZHVsZXMvQHNtdWkvY29tbW9uL1NwYW4uc3ZlbHRlIiwiLi4vLi4vLi4vcGFja2FnZXMvZmFiL25vZGVfbW9kdWxlcy9Ac211aS9jb21tb24vQ29tbW9uTGFiZWwuc3ZlbHRlIiwiLi4vLi4vLi4vcGFja2FnZXMvZmFiL25vZGVfbW9kdWxlcy9Ac211aS9jb21tb24vSS5zdmVsdGUiLCIuLi8uLi8uLi9wYWNrYWdlcy9mYWIvbm9kZV9tb2R1bGVzL0BzbXVpL2NvbW1vbi9Tdmcuc3ZlbHRlIiwiLi4vLi4vLi4vcGFja2FnZXMvZmFiL25vZGVfbW9kdWxlcy9Ac211aS9jb21tb24vQ29tbW9uSWNvbi5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvcm91dGVzL2RlbW8vZmFiL19TaW1wbGUuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL3JvdXRlcy9kZW1vL2ZhYi9fUHJpbWFyeUNvbG9yLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9yb3V0ZXMvZGVtby9mYWIvX0V4aXRlZC5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvcm91dGVzL2RlbW8vZmFiL19NaW5pLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9yb3V0ZXMvZGVtby9mYWIvX0V4dGVuZGVkLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9yb3V0ZXMvZGVtby9mYWIvX05vUmlwcGxlLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9yb3V0ZXMvZGVtby9mYWIvX0xpbmsuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL3JvdXRlcy9kZW1vL2ZhYi9fU3ZnLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9yb3V0ZXMvZGVtby9mYWIvaW5kZXguc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbIjxzcGFuXG4gIGJpbmQ6dGhpcz17ZWxlbWVudH1cbiAgdXNlOnVzZUFjdGlvbnM9e3VzZX1cbiAgdXNlOmZvcndhcmRFdmVudHNcbiAgey4uLiQkcmVzdFByb3BzfT48c2xvdCAvPjwvc3BhblxuPlxuXG48c2NyaXB0PlxuICBpbXBvcnQgeyBnZXRfY3VycmVudF9jb21wb25lbnQgfSBmcm9tICdzdmVsdGUvaW50ZXJuYWwnO1xuICBpbXBvcnQgeyBmb3J3YXJkRXZlbnRzQnVpbGRlciwgdXNlQWN0aW9ucyB9IGZyb20gJy4vaW50ZXJuYWwuanMnO1xuXG4gIGV4cG9ydCBsZXQgdXNlID0gW107XG5cbiAgY29uc3QgZm9yd2FyZEV2ZW50cyA9IGZvcndhcmRFdmVudHNCdWlsZGVyKGdldF9jdXJyZW50X2NvbXBvbmVudCgpKTtcblxuICBsZXQgZWxlbWVudCA9IG51bGw7XG5cbiAgZXhwb3J0IGZ1bmN0aW9uIGdldEVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbjwvc2NyaXB0PlxuIiwiPHN2ZWx0ZTpjb21wb25lbnRcbiAgdGhpcz17Y29tcG9uZW50fVxuICBiaW5kOnRoaXM9e2VsZW1lbnR9XG4gIHVzZT17W2ZvcndhcmRFdmVudHMsIC4uLnVzZV19XG4gIGNsYXNzPXtjbGFzc01hcCh7XG4gICAgW2NsYXNzTmFtZV06IHRydWUsXG4gICAgJ21kYy1idXR0b25fX2xhYmVsJzogY29udGV4dCA9PT0gJ2J1dHRvbicsXG4gICAgJ21kYy1mYWJfX2xhYmVsJzogY29udGV4dCA9PT0gJ2ZhYicsXG4gICAgJ21kYy10YWJfX3RleHQtbGFiZWwnOiBjb250ZXh0ID09PSAndGFiJyxcbiAgICAnbWRjLWltYWdlLWxpc3RfX2xhYmVsJzogY29udGV4dCA9PT0gJ2ltYWdlLWxpc3QnLFxuICAgICdtZGMtc25hY2tiYXJfX2xhYmVsJzogY29udGV4dCA9PT0gJ3NuYWNrYmFyJyxcbiAgICAnbWRjLWJhbm5lcl9fdGV4dCc6IGNvbnRleHQgPT09ICdiYW5uZXInLFxuICAgICdtZGMtc2VnbWVudGVkLWJ1dHRvbl9fbGFiZWwnOiBjb250ZXh0ID09PSAnc2VnbWVudGVkLWJ1dHRvbicsXG4gICAgJ21kYy1kYXRhLXRhYmxlX19wYWdpbmF0aW9uLXJvd3MtcGVyLXBhZ2UtbGFiZWwnOlxuICAgICAgY29udGV4dCA9PT0gJ2RhdGEtdGFibGU6cGFnaW5hdGlvbicsXG4gICAgJ21kYy1kYXRhLXRhYmxlX19oZWFkZXItY2VsbC1sYWJlbCc6XG4gICAgICBjb250ZXh0ID09PSAnZGF0YS10YWJsZTpzb3J0YWJsZS1oZWFkZXItY2VsbCcsXG4gIH0pfVxuICB7Li4uY29udGV4dCA9PT0gJ3NuYWNrYmFyJyA/IHsgJ2FyaWEtYXRvbWljJzogJ2ZhbHNlJyB9IDoge319XG4gIHt0YWJpbmRleH1cbiAgey4uLiQkcmVzdFByb3BzfT48c2xvdCAvPjwvc3ZlbHRlOmNvbXBvbmVudFxuPlxuXG48c2NyaXB0PlxuICBpbXBvcnQgeyBnZXRDb250ZXh0IH0gZnJvbSAnc3ZlbHRlJztcbiAgaW1wb3J0IHsgZ2V0X2N1cnJlbnRfY29tcG9uZW50IH0gZnJvbSAnc3ZlbHRlL2ludGVybmFsJztcbiAgaW1wb3J0IHsgZm9yd2FyZEV2ZW50c0J1aWxkZXIsIGNsYXNzTWFwLCB1c2VBY3Rpb25zIH0gZnJvbSAnLi9pbnRlcm5hbC5qcyc7XG4gIGltcG9ydCBTcGFuIGZyb20gJy4vU3Bhbi5zdmVsdGUnO1xuXG4gIGNvbnN0IGZvcndhcmRFdmVudHMgPSBmb3J3YXJkRXZlbnRzQnVpbGRlcihnZXRfY3VycmVudF9jb21wb25lbnQoKSk7XG5cbiAgZXhwb3J0IGxldCB1c2UgPSBbXTtcbiAgbGV0IGNsYXNzTmFtZSA9ICcnO1xuICBleHBvcnQgeyBjbGFzc05hbWUgYXMgY2xhc3MgfTtcblxuICBsZXQgZWxlbWVudDtcblxuICBleHBvcnQgbGV0IGNvbXBvbmVudCA9IFNwYW47XG5cbiAgY29uc3QgY29udGV4dCA9IGdldENvbnRleHQoJ1NNVUk6bGFiZWw6Y29udGV4dCcpO1xuICBjb25zdCB0YWJpbmRleCA9IGdldENvbnRleHQoJ1NNVUk6bGFiZWw6dGFiaW5kZXgnKTtcblxuICBleHBvcnQgZnVuY3Rpb24gZ2V0RWxlbWVudCgpIHtcbiAgICByZXR1cm4gZWxlbWVudC5nZXRFbGVtZW50KCk7XG4gIH1cbjwvc2NyaXB0PlxuIiwiPGkgYmluZDp0aGlzPXtlbGVtZW50fSB1c2U6dXNlQWN0aW9ucz17dXNlfSB1c2U6Zm9yd2FyZEV2ZW50cyB7Li4uJCRyZXN0UHJvcHN9XG4gID48c2xvdCAvPjwvaVxuPlxuXG48c2NyaXB0PlxuICBpbXBvcnQgeyBnZXRfY3VycmVudF9jb21wb25lbnQgfSBmcm9tICdzdmVsdGUvaW50ZXJuYWwnO1xuICBpbXBvcnQgeyBmb3J3YXJkRXZlbnRzQnVpbGRlciwgdXNlQWN0aW9ucyB9IGZyb20gJy4vaW50ZXJuYWwuanMnO1xuXG4gIGV4cG9ydCBsZXQgdXNlID0gW107XG5cbiAgY29uc3QgZm9yd2FyZEV2ZW50cyA9IGZvcndhcmRFdmVudHNCdWlsZGVyKGdldF9jdXJyZW50X2NvbXBvbmVudCgpKTtcblxuICBsZXQgZWxlbWVudCA9IG51bGw7XG5cbiAgZXhwb3J0IGZ1bmN0aW9uIGdldEVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbjwvc2NyaXB0PlxuIiwiPHN2ZyBiaW5kOnRoaXM9e2VsZW1lbnR9IHVzZTp1c2VBY3Rpb25zPXt1c2V9IHVzZTpmb3J3YXJkRXZlbnRzIHsuLi4kJHJlc3RQcm9wc31cbiAgPjxzbG90IC8+PC9zdmdcbj5cblxuPHNjcmlwdD5cbiAgaW1wb3J0IHsgZ2V0X2N1cnJlbnRfY29tcG9uZW50IH0gZnJvbSAnc3ZlbHRlL2ludGVybmFsJztcbiAgaW1wb3J0IHsgZm9yd2FyZEV2ZW50c0J1aWxkZXIsIHVzZUFjdGlvbnMgfSBmcm9tICcuL2ludGVybmFsLmpzJztcblxuICBleHBvcnQgbGV0IHVzZSA9IFtdO1xuXG4gIGNvbnN0IGZvcndhcmRFdmVudHMgPSBmb3J3YXJkRXZlbnRzQnVpbGRlcihnZXRfY3VycmVudF9jb21wb25lbnQoKSk7XG5cbiAgbGV0IGVsZW1lbnQgPSBudWxsO1xuXG4gIGV4cG9ydCBmdW5jdGlvbiBnZXRFbGVtZW50KCkge1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG48L3NjcmlwdD5cbiIsIjxzdmVsdGU6Y29tcG9uZW50XG4gIHRoaXM9e2NvbXBvbmVudH1cbiAgYmluZDp0aGlzPXtlbGVtZW50fVxuICB1c2U9e1tmb3J3YXJkRXZlbnRzLCAuLi51c2VdfVxuICBjbGFzcz17Y2xhc3NNYXAoe1xuICAgIFtjbGFzc05hbWVdOiB0cnVlLFxuICAgICdtZGMtYnV0dG9uX19pY29uJzogY29udGV4dCA9PT0gJ2J1dHRvbicsXG4gICAgJ21kYy1mYWJfX2ljb24nOiBjb250ZXh0ID09PSAnZmFiJyxcbiAgICAnbWRjLWljb24tYnV0dG9uX19pY29uJzogY29udGV4dCA9PT0gJ2ljb24tYnV0dG9uJyxcbiAgICAnbWRjLWljb24tYnV0dG9uX19pY29uLS1vbic6IGNvbnRleHQgPT09ICdpY29uLWJ1dHRvbicgJiYgb24sXG4gICAgJ21kYy10YWJfX2ljb24nOiBjb250ZXh0ID09PSAndGFiJyxcbiAgICAnbWRjLWJhbm5lcl9faWNvbic6IGNvbnRleHQgPT09ICdiYW5uZXInLFxuICAgICdtZGMtc2VnbWVudGVkLWJ1dHRvbl9faWNvbic6IGNvbnRleHQgPT09ICdzZWdtZW50ZWQtYnV0dG9uJyxcbiAgfSl9XG4gIGFyaWEtaGlkZGVuPVwidHJ1ZVwiXG4gIHsuLi5jb21wb25lbnQgPT09IFN2ZyA/IHsgZm9jdXNhYmxlOiAnZmFsc2UnLCB0YWJpbmRleDogJy0xJyB9IDoge319XG4gIHsuLi4kJHJlc3RQcm9wc30+PHNsb3QgLz48L3N2ZWx0ZTpjb21wb25lbnRcbj5cblxuPHNjcmlwdD5cbiAgaW1wb3J0IHsgZ2V0Q29udGV4dCB9IGZyb20gJ3N2ZWx0ZSc7XG4gIGltcG9ydCB7IGdldF9jdXJyZW50X2NvbXBvbmVudCB9IGZyb20gJ3N2ZWx0ZS9pbnRlcm5hbCc7XG4gIGltcG9ydCB7IGZvcndhcmRFdmVudHNCdWlsZGVyLCBjbGFzc01hcCB9IGZyb20gJy4vaW50ZXJuYWwuanMnO1xuICBpbXBvcnQgSSBmcm9tICcuL0kuc3ZlbHRlJztcbiAgaW1wb3J0IFN2ZyBmcm9tICcuL1N2Zy5zdmVsdGUnO1xuXG4gIGNvbnN0IGZvcndhcmRFdmVudHMgPSBmb3J3YXJkRXZlbnRzQnVpbGRlcihnZXRfY3VycmVudF9jb21wb25lbnQoKSk7XG5cbiAgZXhwb3J0IGxldCB1c2UgPSBbXTtcbiAgbGV0IGNsYXNzTmFtZSA9ICcnO1xuICBleHBvcnQgeyBjbGFzc05hbWUgYXMgY2xhc3MgfTtcbiAgZXhwb3J0IGxldCBvbiA9IGZhbHNlO1xuXG4gIGxldCBlbGVtZW50O1xuXG4gIGV4cG9ydCBsZXQgY29tcG9uZW50ID0gSTtcblxuICBjb25zdCBjb250ZXh0ID0gZ2V0Q29udGV4dCgnU01VSTppY29uOmNvbnRleHQnKTtcblxuICBleHBvcnQgZnVuY3Rpb24gZ2V0RWxlbWVudCgpIHtcbiAgICByZXR1cm4gZWxlbWVudC5nZXRFbGVtZW50KCk7XG4gIH1cbjwvc2NyaXB0PlxuIiwiPGRpdiBjbGFzcz1cImZsZXh5XCI+XG4gIDxkaXYgY2xhc3M9XCJtYXJnaW5zXCI+XG4gICAgPEZhYiBvbjpjbGljaz17KCkgPT4gY2xpY2tlZCsrfT5cbiAgICAgIDxJY29uIGNsYXNzPVwibWF0ZXJpYWwtaWNvbnNcIj5mYXZvcml0ZTwvSWNvbj5cbiAgICA8L0ZhYj5cbiAgPC9kaXY+XG48L2Rpdj5cblxuPHByZSBjbGFzcz1cInN0YXR1c1wiPkNsaWNrZWQ6IHtjbGlja2VkfTwvcHJlPlxuXG48c2NyaXB0PlxuICBpbXBvcnQgRmFiLCB7IEljb24gfSBmcm9tICdAc211aS9mYWInO1xuXG4gIGxldCBjbGlja2VkID0gMDtcbjwvc2NyaXB0PlxuIiwiPGRpdiBjbGFzcz1cImZsZXh5XCI+XG4gIDxkaXYgY2xhc3M9XCJtYXJnaW5zXCI+XG4gICAgPEZhYiBjb2xvcj1cInByaW1hcnlcIiBvbjpjbGljaz17KCkgPT4gY2xpY2tlZCsrfT5cbiAgICAgIDxJY29uIGNsYXNzPVwibWF0ZXJpYWwtaWNvbnNcIj5mYXZvcml0ZTwvSWNvbj5cbiAgICA8L0ZhYj5cbiAgPC9kaXY+XG48L2Rpdj5cblxuPHByZSBjbGFzcz1cInN0YXR1c1wiPkNsaWNrZWQ6IHtjbGlja2VkfTwvcHJlPlxuXG48c2NyaXB0PlxuICBpbXBvcnQgRmFiLCB7IEljb24gfSBmcm9tICdAc211aS9mYWInO1xuXG4gIGxldCBjbGlja2VkID0gMDtcbjwvc2NyaXB0PlxuIiwiPGRpdiBjbGFzcz1cImZsZXh5XCI+XG4gIDxkaXYgY2xhc3M9XCJtYXJnaW5zXCI+XG4gICAgPEZhYiBvbjpjbGljaz17KCkgPT4gY2xpY2tlZCsrfSB7ZXhpdGVkfT5cbiAgICAgIDxJY29uIGNsYXNzPVwibWF0ZXJpYWwtaWNvbnNcIj5mYXZvcml0ZTwvSWNvbj5cbiAgICA8L0ZhYj5cbiAgPC9kaXY+XG4gIDxkaXYgY2xhc3M9XCJtYXJnaW5zXCI+XG4gICAgPEZvcm1GaWVsZD5cbiAgICAgIDxDaGVja2JveCBiaW5kOmNoZWNrZWQ9e2V4aXRlZH0gLz5cbiAgICAgIDxzcGFuIHNsb3Q9XCJsYWJlbFwiPkV4aXRlZDwvc3Bhbj5cbiAgICA8L0Zvcm1GaWVsZD5cbiAgPC9kaXY+XG48L2Rpdj5cblxuPGRpdiBjbGFzcz1cImZsZXh5XCI+XG4gIDxkaXYgY2xhc3M9XCJtYXJnaW5zXCI+XG4gICAgPEZhYiBjb2xvcj1cInByaW1hcnlcIiBvbjpjbGljaz17KCkgPT4gY2xpY2tlZCsrfSBleGl0ZWQ9e2V4aXRlZFByaW1hcnl9PlxuICAgICAgPEljb24gY2xhc3M9XCJtYXRlcmlhbC1pY29uc1wiPmZhdm9yaXRlPC9JY29uPlxuICAgIDwvRmFiPlxuICA8L2Rpdj5cbiAgPGRpdiBjbGFzcz1cIm1hcmdpbnNcIj5cbiAgICA8Rm9ybUZpZWxkPlxuICAgICAgPENoZWNrYm94IGJpbmQ6Y2hlY2tlZD17ZXhpdGVkUHJpbWFyeX0gLz5cbiAgICAgIDxzcGFuIHNsb3Q9XCJsYWJlbFwiPkV4aXRlZDwvc3Bhbj5cbiAgICA8L0Zvcm1GaWVsZD5cbiAgPC9kaXY+XG48L2Rpdj5cblxuPHByZSBjbGFzcz1cInN0YXR1c1wiPkNsaWNrZWQ6IHtjbGlja2VkfTwvcHJlPlxuXG48c2NyaXB0PlxuICBpbXBvcnQgRmFiLCB7IExhYmVsLCBJY29uIH0gZnJvbSAnQHNtdWkvZmFiJztcbiAgaW1wb3J0IEZvcm1GaWVsZCBmcm9tICdAc211aS9mb3JtLWZpZWxkJztcbiAgaW1wb3J0IENoZWNrYm94IGZyb20gJ0BzbXVpL2NoZWNrYm94JztcblxuICBsZXQgY2xpY2tlZCA9IDA7XG4gIGxldCBleGl0ZWQgPSBmYWxzZTtcbiAgbGV0IGV4aXRlZFByaW1hcnkgPSBmYWxzZTtcbjwvc2NyaXB0PlxuIiwiPGRpdiBjbGFzcz1cImZsZXh5XCI+XG4gIDxkaXYgY2xhc3M9XCJtYXJnaW5zXCI+XG4gICAgPEZhYiBvbjpjbGljaz17KCkgPT4gY2xpY2tlZCsrfSBtaW5pPlxuICAgICAgPEljb24gY2xhc3M9XCJtYXRlcmlhbC1pY29uc1wiPmZhdm9yaXRlPC9JY29uPlxuICAgIDwvRmFiPlxuICA8L2Rpdj5cbiAgPGRpdiBjbGFzcz1cIm1hcmdpbnNcIj5cbiAgICA8RmFiIGNvbG9yPVwicHJpbWFyeVwiIG9uOmNsaWNrPXsoKSA9PiBjbGlja2VkKyt9IG1pbmk+XG4gICAgICA8SWNvbiBjbGFzcz1cIm1hdGVyaWFsLWljb25zXCI+ZmF2b3JpdGU8L0ljb24+XG4gICAgPC9GYWI+XG4gIDwvZGl2PlxuPC9kaXY+XG5cbjxwcmUgY2xhc3M9XCJzdGF0dXNcIj5DbGlja2VkOiB7Y2xpY2tlZH08L3ByZT5cblxuPHNjcmlwdD5cbiAgaW1wb3J0IEZhYiwgeyBJY29uIH0gZnJvbSAnQHNtdWkvZmFiJztcblxuICBsZXQgY2xpY2tlZCA9IDA7XG48L3NjcmlwdD5cbiIsIjxkaXYgY2xhc3M9XCJmbGV4eVwiPlxuICA8ZGl2IGNsYXNzPVwibWFyZ2luc1wiPlxuICAgIDxGYWIgb246Y2xpY2s9eygpID0+IGNsaWNrZWQrK30gZXh0ZW5kZWQ+XG4gICAgICA8SWNvbiBjbGFzcz1cIm1hdGVyaWFsLWljb25zXCI+ZmF2b3JpdGU8L0ljb24+XG4gICAgICA8TGFiZWw+RXh0ZW5kZWQ8L0xhYmVsPlxuICAgIDwvRmFiPlxuICA8L2Rpdj5cbiAgPGRpdiBjbGFzcz1cIm1hcmdpbnNcIj5cbiAgICA8RmFiIGNvbG9yPVwicHJpbWFyeVwiIG9uOmNsaWNrPXsoKSA9PiBjbGlja2VkKyt9IGV4dGVuZGVkPlxuICAgICAgPEljb24gY2xhc3M9XCJtYXRlcmlhbC1pY29uc1wiPmZhdm9yaXRlPC9JY29uPlxuICAgICAgPExhYmVsPkV4dGVuZGVkPC9MYWJlbD5cbiAgICA8L0ZhYj5cbiAgPC9kaXY+XG4gIDxkaXYgY2xhc3M9XCJtYXJnaW5zXCI+XG4gICAgPEZhYiBvbjpjbGljaz17KCkgPT4gY2xpY2tlZCsrfSBleHRlbmRlZD5cbiAgICAgIDxMYWJlbD5FeHRlbmRlZCBXL28gSWNvbjwvTGFiZWw+XG4gICAgPC9GYWI+XG4gIDwvZGl2PlxuICA8ZGl2IGNsYXNzPVwibWFyZ2luc1wiPlxuICAgIDxGYWIgY29sb3I9XCJwcmltYXJ5XCIgb246Y2xpY2s9eygpID0+IGNsaWNrZWQrK30gZXh0ZW5kZWQ+XG4gICAgICA8TGFiZWw+RXh0ZW5kZWQgVy9vIEljb248L0xhYmVsPlxuICAgIDwvRmFiPlxuICA8L2Rpdj5cbjwvZGl2PlxuXG48cHJlIGNsYXNzPVwic3RhdHVzXCI+Q2xpY2tlZDoge2NsaWNrZWR9PC9wcmU+XG5cbjxzY3JpcHQ+XG4gIGltcG9ydCBGYWIsIHsgTGFiZWwsIEljb24gfSBmcm9tICdAc211aS9mYWInO1xuXG4gIGxldCBjbGlja2VkID0gMDtcbjwvc2NyaXB0PlxuIiwiPGRpdiBjbGFzcz1cImZsZXh5XCI+XG4gIDxkaXYgY2xhc3M9XCJtYXJnaW5zXCI+XG4gICAgPEZhYiBvbjpjbGljaz17KCkgPT4gY2xpY2tlZCsrfSByaXBwbGU9e2ZhbHNlfT5cbiAgICAgIDxJY29uIGNsYXNzPVwibWF0ZXJpYWwtaWNvbnNcIj5mYXZvcml0ZTwvSWNvbj5cbiAgICA8L0ZhYj5cbiAgPC9kaXY+XG4gIDxkaXYgY2xhc3M9XCJtYXJnaW5zXCI+XG4gICAgPEZhYiBjb2xvcj1cInByaW1hcnlcIiBvbjpjbGljaz17KCkgPT4gY2xpY2tlZCsrfSByaXBwbGU9e2ZhbHNlfT5cbiAgICAgIDxJY29uIGNsYXNzPVwibWF0ZXJpYWwtaWNvbnNcIj5mYXZvcml0ZTwvSWNvbj5cbiAgICA8L0ZhYj5cbiAgPC9kaXY+XG4gIDxkaXYgY2xhc3M9XCJtYXJnaW5zXCI+XG4gICAgPEZhYiBvbjpjbGljaz17KCkgPT4gY2xpY2tlZCsrfSBleHRlbmRlZCByaXBwbGU9e2ZhbHNlfT5cbiAgICAgIDxJY29uIGNsYXNzPVwibWF0ZXJpYWwtaWNvbnNcIj5mYXZvcml0ZTwvSWNvbj5cbiAgICAgIDxMYWJlbD5FeHRlbmRlZDwvTGFiZWw+XG4gICAgPC9GYWI+XG4gIDwvZGl2PlxuICA8ZGl2IGNsYXNzPVwibWFyZ2luc1wiPlxuICAgIDxGYWIgY29sb3I9XCJwcmltYXJ5XCIgb246Y2xpY2s9eygpID0+IGNsaWNrZWQrK30gZXh0ZW5kZWQgcmlwcGxlPXtmYWxzZX0+XG4gICAgICA8SWNvbiBjbGFzcz1cIm1hdGVyaWFsLWljb25zXCI+ZmF2b3JpdGU8L0ljb24+XG4gICAgICA8TGFiZWw+RXh0ZW5kZWQ8L0xhYmVsPlxuICAgIDwvRmFiPlxuICA8L2Rpdj5cbjwvZGl2PlxuXG48cHJlIGNsYXNzPVwic3RhdHVzXCI+Q2xpY2tlZDoge2NsaWNrZWR9PC9wcmU+XG5cbjxzY3JpcHQ+XG4gIGltcG9ydCBGYWIsIHsgTGFiZWwsIEljb24gfSBmcm9tICdAc211aS9mYWInO1xuXG4gIGxldCBjbGlja2VkID0gMDtcbjwvc2NyaXB0PlxuIiwiPGRpdiBjbGFzcz1cImZsZXh5XCI+XG4gIDxkaXYgY2xhc3M9XCJtYXJnaW5zXCI+XG4gICAgPEZhYiBvbjpjbGljaz17KCkgPT4gY2xpY2tlZCsrfSBocmVmPVwiaHR0cDovL2V4YW1wbGUuY29tXCIgdGFyZ2V0PVwiX2JsYW5rXCI+XG4gICAgICA8SWNvbiBjbGFzcz1cIm1hdGVyaWFsLWljb25zXCI+ZmF2b3JpdGU8L0ljb24+XG4gICAgPC9GYWI+XG4gIDwvZGl2PlxuICA8ZGl2IGNsYXNzPVwibWFyZ2luc1wiPlxuICAgIDxGYWJcbiAgICAgIGNvbG9yPVwicHJpbWFyeVwiXG4gICAgICBvbjpjbGljaz17KCkgPT4gY2xpY2tlZCsrfVxuICAgICAgaHJlZj1cImh0dHA6Ly9leGFtcGxlLmNvbVwiXG4gICAgICB0YXJnZXQ9XCJfYmxhbmtcIlxuICAgID5cbiAgICAgIDxJY29uIGNsYXNzPVwibWF0ZXJpYWwtaWNvbnNcIj5mYXZvcml0ZTwvSWNvbj5cbiAgICA8L0ZhYj5cbiAgPC9kaXY+XG4gIDxkaXYgY2xhc3M9XCJtYXJnaW5zXCI+XG4gICAgPEZhYlxuICAgICAgb246Y2xpY2s9eygpID0+IGNsaWNrZWQrK31cbiAgICAgIGhyZWY9XCJodHRwOi8vZXhhbXBsZS5jb21cIlxuICAgICAgdGFyZ2V0PVwiX2JsYW5rXCJcbiAgICAgIGV4dGVuZGVkXG4gICAgPlxuICAgICAgPExhYmVsPkxpbms8L0xhYmVsPlxuICAgIDwvRmFiPlxuICA8L2Rpdj5cbiAgPGRpdiBjbGFzcz1cIm1hcmdpbnNcIj5cbiAgICA8RmFiXG4gICAgICBjb2xvcj1cInByaW1hcnlcIlxuICAgICAgb246Y2xpY2s9eygpID0+IGNsaWNrZWQrK31cbiAgICAgIGhyZWY9XCJodHRwOi8vZXhhbXBsZS5jb21cIlxuICAgICAgdGFyZ2V0PVwiX2JsYW5rXCJcbiAgICAgIGV4dGVuZGVkXG4gICAgPlxuICAgICAgPExhYmVsPkxpbms8L0xhYmVsPlxuICAgIDwvRmFiPlxuICA8L2Rpdj5cbjwvZGl2PlxuXG48cHJlIGNsYXNzPVwic3RhdHVzXCI+Q2xpY2tlZDoge2NsaWNrZWR9PC9wcmU+XG5cbjxzY3JpcHQ+XG4gIGltcG9ydCBGYWIsIHsgTGFiZWwsIEljb24gfSBmcm9tICdAc211aS9mYWInO1xuXG4gIGxldCBjbGlja2VkID0gMDtcbjwvc2NyaXB0PlxuIiwiPGRpdiBjbGFzcz1cImZsZXh5XCI+XG4gIDxkaXYgY2xhc3M9XCJtYXJnaW5zXCI+XG4gICAgPCEtLVxuICAgICAgSSdtIHVzaW5nIHZpZXdCb3g9XCIyIDIgMjAgMjBcIiBpbnN0ZWFkIG9mXG4gICAgICB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgYmVjYXVzZSB0aGUgbWRpUGx1cyBpY29uXG4gICAgICBpcyBwYXJ0aWN1bGFybHkgc21hbGwuIFRoaXMgZW1iaWdnZW5zIGl0LlxuICAgIC0tPlxuICAgIDxGYWIgb246Y2xpY2s9eygpID0+IGNsaWNrZWQrK30+XG4gICAgICA8SWNvbiBjb21wb25lbnQ9e1N2Z30gdmlld0JveD1cIjIgMiAyMCAyMFwiPlxuICAgICAgICA8cGF0aCBmaWxsPVwiY3VycmVudENvbG9yXCIgZD17bWRpUGx1c30gLz5cbiAgICAgIDwvSWNvbj5cbiAgICA8L0ZhYj5cbiAgPC9kaXY+XG48L2Rpdj5cblxuPHByZSBjbGFzcz1cInN0YXR1c1wiPkNsaWNrZWQ6IHtjbGlja2VkfTwvcHJlPlxuXG48c2NyaXB0PlxuICBpbXBvcnQgRmFiLCB7IEljb24gfSBmcm9tICdAc211aS9mYWInO1xuICBpbXBvcnQgU3ZnIGZyb20gJ0BzbXVpL2NvbW1vbi9Tdmcuc3ZlbHRlJztcbiAgaW1wb3J0IHsgbWRpUGx1cyB9IGZyb20gJ0BtZGkvanMnO1xuXG4gIGxldCBjbGlja2VkID0gMDtcbjwvc2NyaXB0PlxuXG48c3R5bGU+XG4gICogOmdsb2JhbChzdmc6Zm9jdXMpIHtcbiAgICBvdXRsaW5lOiAwO1xuICB9XG48L3N0eWxlPlxuIiwiPHN2ZWx0ZTpoZWFkPlxuICA8dGl0bGU+RmxvYXRpbmcgQWN0aW9uIEJ1dHRvbiAtIFNNVUk8L3RpdGxlPlxuPC9zdmVsdGU6aGVhZD5cblxuPHNlY3Rpb24+XG4gIDxoMj5GbG9hdGluZyBBY3Rpb24gQnV0dG9uPC9oMj5cblxuICA8cHJlIGNsYXNzPVwiZGVtby1zcGFjZWRcIj5ucG0gaSAtRCBAc211aS9mYWI8L3ByZT5cblxuICA8RGVtbyBjb21wb25lbnQ9e1NpbXBsZX0gZmlsZT1cImZhYi9fU2ltcGxlLnN2ZWx0ZVwiIC8+XG5cbiAgPERlbW8gY29tcG9uZW50PXtQcmltYXJ5Q29sb3J9IGZpbGU9XCJmYWIvX1ByaW1hcnlDb2xvci5zdmVsdGVcIj5cbiAgICBQcmltYXJ5IGNvbG9yXG4gIDwvRGVtbz5cblxuICA8RGVtbyBjb21wb25lbnQ9e0V4aXRlZH0gZmlsZT1cImZhYi9fRXhpdGVkLnN2ZWx0ZVwiPkV4aXRlZDwvRGVtbz5cblxuICA8RGVtbyBjb21wb25lbnQ9e01pbml9IGZpbGU9XCJmYWIvX01pbmkuc3ZlbHRlXCI+TWluaTwvRGVtbz5cblxuICA8RGVtbyBjb21wb25lbnQ9e0V4dGVuZGVkfSBmaWxlPVwiZmFiL19FeHRlbmRlZC5zdmVsdGVcIj5FeHRlbmRlZDwvRGVtbz5cblxuICA8RGVtbyBjb21wb25lbnQ9e05vUmlwcGxlfSBmaWxlPVwiZmFiL19Ob1JpcHBsZS5zdmVsdGVcIj5ObyBSaXBwbGU8L0RlbW8+XG5cbiAgPERlbW8gY29tcG9uZW50PXtMaW5rfSBmaWxlPVwiZmFiL19MaW5rLnN2ZWx0ZVwiPkxpbms8L0RlbW8+XG5cbiAgPERlbW8gY29tcG9uZW50PXtTdmd9IGZpbGU9XCJmYWIvX1N2Zy5zdmVsdGVcIj5Tdmc8L0RlbW8+XG48L3NlY3Rpb24+XG5cbjxzY3JpcHQ+XG4gIGltcG9ydCBEZW1vIGZyb20gJy4uLy4uLy4uL2NvbXBvbmVudHMvRGVtby5zdmVsdGUnO1xuICBpbXBvcnQgU2ltcGxlIGZyb20gJy4vX1NpbXBsZS5zdmVsdGUnO1xuICBpbXBvcnQgUHJpbWFyeUNvbG9yIGZyb20gJy4vX1ByaW1hcnlDb2xvci5zdmVsdGUnO1xuICBpbXBvcnQgRXhpdGVkIGZyb20gJy4vX0V4aXRlZC5zdmVsdGUnO1xuICBpbXBvcnQgTWluaSBmcm9tICcuL19NaW5pLnN2ZWx0ZSc7XG4gIGltcG9ydCBFeHRlbmRlZCBmcm9tICcuL19FeHRlbmRlZC5zdmVsdGUnO1xuICBpbXBvcnQgTm9SaXBwbGUgZnJvbSAnLi9fTm9SaXBwbGUuc3ZlbHRlJztcbiAgaW1wb3J0IExpbmsgZnJvbSAnLi9fTGluay5zdmVsdGUnO1xuICBpbXBvcnQgU3ZnIGZyb20gJy4vX1N2Zy5zdmVsdGUnO1xuPC9zY3JpcHQ+XG5cbjxzdHlsZT5cbiAgKiA6Z2xvYmFsKC5mbGV4eSkge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC13cmFwOiB3cmFwO1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gIH1cblxuICAqIDpnbG9iYWwoLm1hcmdpbnMpIHtcbiAgICBtYXJnaW46IDAgMC40ZW0gMC40ZW0gMDtcbiAgfVxuPC9zdHlsZT5cbiJdLCJuYW1lcyI6WyJTdmciXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O29DQUlNLEdBQVc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs4RUFGQyxHQUFHOzs7Ozs7Ozs7Ozs7OztpSEFFZixHQUFXO29JQUZDLEdBQUc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQVNSLEdBQUc7T0FFUixhQUFhLEdBQUcsb0JBQW9CLENBQUMscUJBQXFCO0tBRTVELE9BQU8sR0FBRyxJQUFJOztVQUVGLFVBQVU7U0FDakIsT0FBTzs7Ozs7R0FqQkwsT0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MkJDRVosR0FBYSxnQkFBSyxHQUFHOzs7VUFDcEIsUUFBUTttQkFDWixHQUFTLE1BQUcsSUFBSTtJQUNqQixtQkFBbUIsY0FBRSxHQUFPLFFBQUssUUFBUTtJQUN6QyxnQkFBZ0IsY0FBRSxHQUFPLFFBQUssS0FBSztJQUNuQyxxQkFBcUIsY0FBRSxHQUFPLFFBQUssS0FBSztJQUN4Qyx1QkFBdUIsY0FBRSxHQUFPLFFBQUssWUFBWTtJQUNqRCxxQkFBcUIsY0FBRSxHQUFPLFFBQUssVUFBVTtJQUM3QyxrQkFBa0IsY0FBRSxHQUFPLFFBQUssUUFBUTtJQUN4Qyw2QkFBNkIsY0FBRSxHQUFPLFFBQUssa0JBQWtCO0lBQzdELGdEQUFnRCxjQUM5QyxHQUFPLFFBQUssdUJBQXVCO0lBQ3JDLG1DQUFtQyxjQUNqQyxHQUFPLFFBQUssaUNBQWlDOzs7Y0FFN0MsR0FBTyxRQUFLLFVBQVU7TUFBSyxhQUFhLEVBQUUsT0FBTzs7O2tCQUVqRCxHQUFXOzs7a0NBbkJULEdBQVM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzhCQUVULEdBQWEsZ0JBQUssR0FBRzs7O2FBQ3BCLFFBQVE7c0JBQ1osR0FBUyxNQUFHLElBQUk7T0FDakIsbUJBQW1CLGNBQUUsR0FBTyxRQUFLLFFBQVE7T0FDekMsZ0JBQWdCLGNBQUUsR0FBTyxRQUFLLEtBQUs7T0FDbkMscUJBQXFCLGNBQUUsR0FBTyxRQUFLLEtBQUs7T0FDeEMsdUJBQXVCLGNBQUUsR0FBTyxRQUFLLFlBQVk7T0FDakQscUJBQXFCLGNBQUUsR0FBTyxRQUFLLFVBQVU7T0FDN0Msa0JBQWtCLGNBQUUsR0FBTyxRQUFLLFFBQVE7T0FDeEMsNkJBQTZCLGNBQUUsR0FBTyxRQUFLLGtCQUFrQjtPQUM3RCxnREFBZ0QsY0FDOUMsR0FBTyxRQUFLLHVCQUF1QjtPQUNyQyxtQ0FBbUMsY0FDakMsR0FBTyxRQUFLLGlDQUFpQzs7OzZEQUU3QyxHQUFPLFFBQUssVUFBVTtTQUFLLGFBQWEsRUFBRSxPQUFPOzs7c0VBRWpELEdBQVc7Ozs7Ozs7O3NEQW5CVCxHQUFTOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0E0QlQsYUFBYSxHQUFHLG9CQUFvQixDQUFDLHFCQUFxQjtPQUVyRCxHQUFHO2NBQ1YsU0FBUyxHQUFHLEVBQUU7S0FHZCxPQUFPO09BRUEsU0FBUyxHQUFHLElBQUk7T0FFckIsT0FBTyxHQUFHLFVBQVUsQ0FBQyxvQkFBb0I7T0FDekMsUUFBUSxHQUFHLFVBQVUsQ0FBQyxxQkFBcUI7O1VBRWpDLFVBQVU7U0FDakIsT0FBTyxDQUFDLFVBQVU7Ozs7O0dBekNoQixPQUFPOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2lDQ0Y4QyxHQUFXOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MkVBQXRDLEdBQUc7Ozs7Ozs7Ozs7Ozs7O3dHQUF3QixHQUFXO29JQUF0QyxHQUFHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FRN0IsR0FBRztPQUVSLGFBQWEsR0FBRyxvQkFBb0IsQ0FBQyxxQkFBcUI7S0FFNUQsT0FBTyxHQUFHLElBQUk7O1VBRUYsVUFBVTtTQUNqQixPQUFPOzs7OztHQWZKLE9BQU87Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzttQ0NBK0MsR0FBVzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzZFQUF0QyxHQUFHOzs7Ozs7Ozs7Ozs7OztrSEFBd0IsR0FBVztvSUFBdEMsR0FBRzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BUS9CLEdBQUc7T0FFUixhQUFhLEdBQUcsb0JBQW9CLENBQUMscUJBQXFCO0tBRTVELE9BQU8sR0FBRyxJQUFJOztVQUVGLFVBQVU7U0FDakIsT0FBTzs7Ozs7R0FmRixPQUFPOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsyQkNHZixHQUFhLGdCQUFLLEdBQUc7OztVQUNwQixRQUFRO21CQUNaLEdBQVMsTUFBRyxJQUFJO0lBQ2pCLGtCQUFrQixjQUFFLEdBQU8sUUFBSyxRQUFRO0lBQ3hDLGVBQWUsY0FBRSxHQUFPLFFBQUssS0FBSztJQUNsQyx1QkFBdUIsY0FBRSxHQUFPLFFBQUssYUFBYTtJQUNsRCwyQkFBMkIsY0FBRSxHQUFPLFFBQUssYUFBYSxXQUFJLEdBQUU7SUFDNUQsZUFBZSxjQUFFLEdBQU8sUUFBSyxLQUFLO0lBQ2xDLGtCQUFrQixjQUFFLEdBQU8sUUFBSyxRQUFRO0lBQ3hDLDRCQUE0QixjQUFFLEdBQU8sUUFBSyxrQkFBa0I7Ozs7Z0JBRzFELEdBQVMsUUFBSyxHQUFHO01BQUssU0FBUyxFQUFFLE9BQU8sRUFBRSxRQUFRLEVBQUUsSUFBSTs7a0JBQ3hELEdBQVc7OztrQ0FmVCxHQUFTOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs4QkFFVCxHQUFhLGdCQUFLLEdBQUc7OzthQUNwQixRQUFRO3NCQUNaLEdBQVMsTUFBRyxJQUFJO09BQ2pCLGtCQUFrQixjQUFFLEdBQU8sUUFBSyxRQUFRO09BQ3hDLGVBQWUsY0FBRSxHQUFPLFFBQUssS0FBSztPQUNsQyx1QkFBdUIsY0FBRSxHQUFPLFFBQUssYUFBYTtPQUNsRCwyQkFBMkIsY0FBRSxHQUFPLFFBQUssYUFBYSxXQUFJLEdBQUU7T0FDNUQsZUFBZSxjQUFFLEdBQU8sUUFBSyxLQUFLO09BQ2xDLGtCQUFrQixjQUFFLEdBQU8sUUFBSyxRQUFRO09BQ3hDLDRCQUE0QixjQUFFLEdBQU8sUUFBSyxrQkFBa0I7Ozs7cUVBRzFELEdBQVMsUUFBSyxHQUFHO1NBQUssU0FBUyxFQUFFLE9BQU8sRUFBRSxRQUFRLEVBQUUsSUFBSTs7c0VBQ3hELEdBQVc7Ozs7Ozs7O3NEQWZULEdBQVM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQXlCVCxhQUFhLEdBQUcsb0JBQW9CLENBQUMscUJBQXFCO09BRXJELEdBQUc7Y0FDVixTQUFTLEdBQUcsRUFBRTtPQUVQLEVBQUUsR0FBRyxLQUFLO0tBRWpCLE9BQU87T0FFQSxTQUFTLEdBQUcsQ0FBQztPQUVsQixPQUFPLEdBQUcsVUFBVSxDQUFDLG1CQUFtQjs7VUFFOUIsVUFBVTtTQUNqQixPQUFPLENBQUMsVUFBVTs7Ozs7R0F0Q2hCLE9BQU87Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7eUJDTVUsR0FBTzs7Ozs7Ozs7Ozs7Ozs7OzBDQUFQLEdBQU87Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt1RUFBUCxHQUFPOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0FLL0IsT0FBTyxHQUFHLENBQUM7Ozs7Ozs7NkNBWFEsT0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7eUJDTUYsR0FBTzs7Ozs7Ozs7Ozs7Ozs7OzBDQUFQLEdBQU87Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt1RUFBUCxHQUFPOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0FLL0IsT0FBTyxHQUFHLENBQUM7Ozs7Ozs7NkNBWHdCLE9BQU87Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztnQkNNbEIsR0FBTTtzQ0FBTixHQUFNOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzBDQUFOLEdBQU07Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt1QkFjTixHQUFhOzZDQUFiLEdBQWE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7aURBQWIsR0FBYTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs4QkFOaUIsR0FBYTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7eUJBWTNDLEdBQU87Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzswQ0FBUCxHQUFPOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7NEVBWnVCLEdBQWE7Ozs7Ozs7Ozs7Ozs7O3VFQVkzQyxHQUFPOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQU8vQixPQUFPLEdBQUcsQ0FBQztLQUNYLE1BQU0sR0FBRyxLQUFLO0tBQ2QsYUFBYSxHQUFHLEtBQUs7Ozs7Ozs7NkNBbkNGLE9BQU87OztFQU1GLE1BQU07Ozs7K0NBUUssT0FBTzs7O0VBTWxCLGFBQWE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3lCQ1RiLEdBQU87Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzBDQUFQLEdBQU87Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt1RUFBUCxHQUFPOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0FLL0IsT0FBTyxHQUFHLENBQUM7Ozs7Ozs7NkNBaEJRLE9BQU87K0NBS1MsT0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7eUJDa0JsQixHQUFPOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MENBQVAsR0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3VFQUFQLEdBQU87Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQUsvQixPQUFPLEdBQUcsQ0FBQzs7Ozs7Ozs2Q0E1QlEsT0FBTzsrQ0FNUyxPQUFPOytDQU12QixPQUFPOytDQUtTLE9BQU87Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztZQ2pCSixLQUFLOzs7Ozs7Ozs7Ozs7WUFLVyxLQUFLOzs7Ozs7Ozs7Ozs7WUFLWixLQUFLOzs7Ozs7Ozs7Ozs7O1lBTVcsS0FBSzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7eUJBTzVDLEdBQU87Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzswQ0FBUCxHQUFPOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7dUVBQVAsR0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tBSy9CLE9BQU8sR0FBRyxDQUFDOzs7Ozs7OzZDQTVCUSxPQUFPOytDQUtTLE9BQU87K0NBS3ZCLE9BQU87K0NBTVMsT0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7eUJDcUJsQixHQUFPOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MENBQVAsR0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3VFQUFQLEdBQU87Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQUsvQixPQUFPLEdBQUcsQ0FBQzs7Ozs7Ozs2Q0ExQ1EsT0FBTzsrQ0FPVixPQUFPOytDQVNQLE9BQU87K0NBV1AsT0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7dUJDcEJRLE9BQU87Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7ZUFEckJBLEtBQUc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt5QkFPSSxHQUFPOzs7Ozs7Ozs7Ozs7Ozs7MENBQVAsR0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3VFQUFQLEdBQU87Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQU8vQixPQUFPLEdBQUcsQ0FBQzs7Ozs7Ozs2Q0FmUSxPQUFPOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztlQ0ViLE1BQU07Ozs7Ozs7O2VBRU4sWUFBWTs7Ozs7Ozs7OztlQUlaLE1BQU07Ozs7Ozs7Ozs7ZUFFTixJQUFJOzs7Ozs7Ozs7O2VBRUosUUFBUTs7Ozs7Ozs7OztlQUVSLFFBQVE7Ozs7Ozs7Ozs7ZUFFUixJQUFJOzs7Ozs7Ozs7O2VBRUpBLEtBQUc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsifQ==
