import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, a7 as create_slot, $ as assign, W as compute_rest_props, v as validate_slots, av as compute_slots, Y as get_current_component, Z as setContext, a0 as exclude_internal_props, p as element, x as claim_element, y as children, u as detach_dev, E as attr_dev, D as add_location, F as insert_dev, a8 as update_slot, J as transition_in, K as transition_out, o as space, w as claim_space, a9 as set_attributes, G as append_dev, aa as action_destroyer, a4 as group_outros, a5 as check_outros, a2 as get_spread_update, ab as is_function, ac as run_all, a6 as binding_callbacks, X as getContext, q as create_component, a1 as empty, A as claim_component, H as mount_component, a3 as get_spread_object, M as destroy_component, t as text, z as claim_text, ak as bind, B as set_style, ag as validate_each_argument, aC as validate_each_keys, al as add_flush_callback, aD as update_keyed_each, aE as outro_and_destroy_block, aw as set_data_dev, O as noop, as as IconButton, r as query_selector_all } from './client.ec94238b.js';
import { D as Demo } from './Demo.9c515360.js';
import { c as classMap, p as prefixFilter, e as exclude, f as forwardEventsBuilder, u as useActions, D as DataTable, H as Head, B as Body, R as Row, C as Cell } from './Cell.e79ca75d.js';
import { L as LinearProgress } from './LinearProgress.2a923d82.js';
import { B as Button_1 } from './Button.d66ce348.js';
import { C as Checkbox } from './Checkbox.52871e38.js';
import { S as Select, O as Option } from './Option.2399e112.js';
import { C as CommonLabel$1 } from './CommonLabel.e3297b41.js';

/* packages/data-table/Pagination.svelte generated by Svelte v3.37.0 */

const file$5 = "packages/data-table/Pagination.svelte";
const get_total_slot_changes = dirty => ({});
const get_total_slot_context = ctx => ({});
const get_rowsPerPage_slot_changes = dirty => ({});
const get_rowsPerPage_slot_context = ctx => ({});

// (19:4) {#if $$slots.rowsPerPage}
function create_if_block_1(ctx) {
	let div;
	let current;
	const rowsPerPage_slot_template = /*#slots*/ ctx[10].rowsPerPage;
	const rowsPerPage_slot = create_slot(rowsPerPage_slot_template, ctx, /*$$scope*/ ctx[9], get_rowsPerPage_slot_context);

	const block = {
		c: function create() {
			div = element("div");
			if (rowsPerPage_slot) rowsPerPage_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (rowsPerPage_slot) rowsPerPage_slot.l(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "mdc-data-table__pagination-rows-per-page");
			add_location(div, file$5, 19, 6, 444);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (rowsPerPage_slot) {
				rowsPerPage_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (rowsPerPage_slot) {
				if (rowsPerPage_slot.p && dirty & /*$$scope*/ 512) {
					update_slot(rowsPerPage_slot, rowsPerPage_slot_template, ctx, /*$$scope*/ ctx[9], dirty, get_rowsPerPage_slot_changes, get_rowsPerPage_slot_context);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(rowsPerPage_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(rowsPerPage_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (rowsPerPage_slot) rowsPerPage_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(19:4) {#if $$slots.rowsPerPage}",
		ctx
	});

	return block;
}

// (26:6) {#if $$slots.total}
function create_if_block(ctx) {
	let div;
	let current;
	const total_slot_template = /*#slots*/ ctx[10].total;
	const total_slot = create_slot(total_slot_template, ctx, /*$$scope*/ ctx[9], get_total_slot_context);

	const block = {
		c: function create() {
			div = element("div");
			if (total_slot) total_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (total_slot) total_slot.l(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "mdc-data-table__pagination-total");
			add_location(div, file$5, 26, 8, 649);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (total_slot) {
				total_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (total_slot) {
				if (total_slot.p && dirty & /*$$scope*/ 512) {
					update_slot(total_slot, total_slot_template, ctx, /*$$scope*/ ctx[9], dirty, get_total_slot_changes, get_total_slot_context);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(total_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(total_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (total_slot) total_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(26:6) {#if $$slots.total}",
		ctx
	});

	return block;
}

function create_fragment$9(ctx) {
	let div2;
	let div1;
	let t0;
	let div0;
	let t1;
	let div1_class_value;
	let useActions_action;
	let div2_class_value;
	let useActions_action_1;
	let current;
	let mounted;
	let dispose;
	let if_block0 = /*$$slots*/ ctx[7].rowsPerPage && create_if_block_1(ctx);
	let if_block1 = /*$$slots*/ ctx[7].total && create_if_block(ctx);
	const default_slot_template = /*#slots*/ ctx[10].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], null);

	let div1_levels = [
		{
			class: div1_class_value = classMap({
				[/*trailing$class*/ ctx[3]]: true,
				"mdc-data-table__pagination-trailing": true
			})
		},
		prefixFilter(/*$$restProps*/ ctx[6], "trailing$")
	];

	let div1_data = {};

	for (let i = 0; i < div1_levels.length; i += 1) {
		div1_data = assign(div1_data, div1_levels[i]);
	}

	let div2_levels = [
		{
			class: div2_class_value = classMap({
				[/*className*/ ctx[1]]: true,
				"mdc-data-table__pagination": true
			})
		},
		exclude(/*$$restProps*/ ctx[6], ["trailing$"])
	];

	let div2_data = {};

	for (let i = 0; i < div2_levels.length; i += 1) {
		div2_data = assign(div2_data, div2_levels[i]);
	}

	const block = {
		c: function create() {
			div2 = element("div");
			div1 = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			div0 = element("div");
			if (if_block1) if_block1.c();
			t1 = space();
			if (default_slot) default_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			div2 = claim_element(nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			div1 = claim_element(div2_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			if (if_block0) if_block0.l(div1_nodes);
			t0 = claim_space(div1_nodes);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			if (if_block1) if_block1.l(div0_nodes);
			t1 = claim_space(div0_nodes);
			if (default_slot) default_slot.l(div0_nodes);
			div0_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			div2_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "class", "mdc-data-table__pagination-navigation");
			add_location(div0, file$5, 24, 4, 563);
			set_attributes(div1, div1_data);
			add_location(div1, file$5, 10, 2, 206);
			set_attributes(div2, div2_data);
			add_location(div2, file$5, 0, 0, 0);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div2, anchor);
			append_dev(div2, div1);
			if (if_block0) if_block0.m(div1, null);
			append_dev(div1, t0);
			append_dev(div1, div0);
			if (if_block1) if_block1.m(div0, null);
			append_dev(div0, t1);

			if (default_slot) {
				default_slot.m(div0, null);
			}

			/*div2_binding*/ ctx[11](div2);
			current = true;

			if (!mounted) {
				dispose = [
					action_destroyer(useActions_action = useActions.call(null, div1, /*trailing$use*/ ctx[2])),
					action_destroyer(useActions_action_1 = useActions.call(null, div2, /*use*/ ctx[0])),
					action_destroyer(/*forwardEvents*/ ctx[5].call(null, div2))
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (/*$$slots*/ ctx[7].rowsPerPage) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*$$slots*/ 128) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_1(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div1, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*$$slots*/ ctx[7].total) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*$$slots*/ 128) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div0, t1);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 512) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[9], dirty, null, null);
				}
			}

			set_attributes(div1, div1_data = get_spread_update(div1_levels, [
				(!current || dirty & /*trailing$class*/ 8 && div1_class_value !== (div1_class_value = classMap({
					[/*trailing$class*/ ctx[3]]: true,
					"mdc-data-table__pagination-trailing": true
				}))) && { class: div1_class_value },
				dirty & /*$$restProps*/ 64 && prefixFilter(/*$$restProps*/ ctx[6], "trailing$")
			]));

			if (useActions_action && is_function(useActions_action.update) && dirty & /*trailing$use*/ 4) useActions_action.update.call(null, /*trailing$use*/ ctx[2]);

			set_attributes(div2, div2_data = get_spread_update(div2_levels, [
				(!current || dirty & /*className*/ 2 && div2_class_value !== (div2_class_value = classMap({
					[/*className*/ ctx[1]]: true,
					"mdc-data-table__pagination": true
				}))) && { class: div2_class_value },
				dirty & /*$$restProps*/ 64 && exclude(/*$$restProps*/ ctx[6], ["trailing$"])
			]));

			if (useActions_action_1 && is_function(useActions_action_1.update) && dirty & /*use*/ 1) useActions_action_1.update.call(null, /*use*/ ctx[0]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div2);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (default_slot) default_slot.d(detaching);
			/*div2_binding*/ ctx[11](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$9.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$9($$self, $$props, $$invalidate) {
	const omit_props_names = ["use","class","trailing$use","trailing$class","getElement"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Pagination", slots, ['rowsPerPage','total','default']);
	const $$slots = compute_slots(slots);
	const forwardEvents = forwardEventsBuilder(get_current_component());
	let { use = [] } = $$props;
	let { class: className = "" } = $$props;
	let { trailing$use = [] } = $$props;
	let { trailing$class = "" } = $$props;
	let element;
	setContext("SMUI:label:context", "data-table:pagination");
	setContext("SMUI:select:context", "data-table:pagination");
	setContext("SMUI:icon-button:context", "data-table:pagination");

	function getElement() {
		return element;
	}

	function div2_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			element = $$value;
			$$invalidate(4, element);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("use" in $$new_props) $$invalidate(0, use = $$new_props.use);
		if ("class" in $$new_props) $$invalidate(1, className = $$new_props.class);
		if ("trailing$use" in $$new_props) $$invalidate(2, trailing$use = $$new_props.trailing$use);
		if ("trailing$class" in $$new_props) $$invalidate(3, trailing$class = $$new_props.trailing$class);
		if ("$$scope" in $$new_props) $$invalidate(9, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		setContext,
		get_current_component,
		forwardEventsBuilder,
		classMap,
		exclude,
		prefixFilter,
		useActions,
		forwardEvents,
		use,
		className,
		trailing$use,
		trailing$class,
		element,
		getElement
	});

	$$self.$inject_state = $$new_props => {
		if ("use" in $$props) $$invalidate(0, use = $$new_props.use);
		if ("className" in $$props) $$invalidate(1, className = $$new_props.className);
		if ("trailing$use" in $$props) $$invalidate(2, trailing$use = $$new_props.trailing$use);
		if ("trailing$class" in $$props) $$invalidate(3, trailing$class = $$new_props.trailing$class);
		if ("element" in $$props) $$invalidate(4, element = $$new_props.element);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		use,
		className,
		trailing$use,
		trailing$class,
		element,
		forwardEvents,
		$$restProps,
		$$slots,
		getElement,
		$$scope,
		slots,
		div2_binding
	];
}

class Pagination extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$9, create_fragment$9, safe_not_equal, {
			use: 0,
			class: 1,
			trailing$use: 2,
			trailing$class: 3,
			getElement: 8
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Pagination",
			options,
			id: create_fragment$9.name
		});
	}

	get use() {
		throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set use(value) {
		throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get trailing$use() {
		throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set trailing$use(value) {
		throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get trailing$class() {
		throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set trailing$class(value) {
		throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get getElement() {
		return this.$$.ctx[8];
	}

	set getElement(value) {
		throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* packages/data-table/node_modules/@smui/common/Span.svelte generated by Svelte v3.37.0 */
const file$4 = "packages/data-table/node_modules/@smui/common/Span.svelte";

function create_fragment$8(ctx) {
	let span;
	let useActions_action;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[6].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);
	let span_levels = [/*$$restProps*/ ctx[3]];
	let span_data = {};

	for (let i = 0; i < span_levels.length; i += 1) {
		span_data = assign(span_data, span_levels[i]);
	}

	const block = {
		c: function create() {
			span = element("span");
			if (default_slot) default_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", {});
			var span_nodes = children(span);
			if (default_slot) default_slot.l(span_nodes);
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_attributes(span, span_data);
			add_location(span, file$4, 0, 0, 0);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);

			if (default_slot) {
				default_slot.m(span, null);
			}

			/*span_binding*/ ctx[7](span);
			current = true;

			if (!mounted) {
				dispose = [
					action_destroyer(useActions_action = useActions.call(null, span, /*use*/ ctx[0])),
					action_destroyer(/*forwardEvents*/ ctx[2].call(null, span))
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 32) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[5], dirty, null, null);
				}
			}

			set_attributes(span, span_data = get_spread_update(span_levels, [dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3]]));
			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			if (default_slot) default_slot.d(detaching);
			/*span_binding*/ ctx[7](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$8.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$8($$self, $$props, $$invalidate) {
	const omit_props_names = ["use","getElement"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Span", slots, ['default']);
	let { use = [] } = $$props;
	const forwardEvents = forwardEventsBuilder(get_current_component());
	let element = null;

	function getElement() {
		return element;
	}

	function span_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			element = $$value;
			$$invalidate(1, element);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("use" in $$new_props) $$invalidate(0, use = $$new_props.use);
		if ("$$scope" in $$new_props) $$invalidate(5, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		get_current_component,
		forwardEventsBuilder,
		useActions,
		use,
		forwardEvents,
		element,
		getElement
	});

	$$self.$inject_state = $$new_props => {
		if ("use" in $$props) $$invalidate(0, use = $$new_props.use);
		if ("element" in $$props) $$invalidate(1, element = $$new_props.element);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		use,
		element,
		forwardEvents,
		$$restProps,
		getElement,
		$$scope,
		slots,
		span_binding
	];
}

class Span extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$8, create_fragment$8, safe_not_equal, { use: 0, getElement: 4 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Span",
			options,
			id: create_fragment$8.name
		});
	}

	get use() {
		throw new Error("<Span>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set use(value) {
		throw new Error("<Span>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get getElement() {
		return this.$$.ctx[4];
	}

	set getElement(value) {
		throw new Error("<Span>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* packages/data-table/node_modules/@smui/common/CommonLabel.svelte generated by Svelte v3.37.0 */

// (1:0) <svelte:component   this={component}   bind:this={element}   use={[forwardEvents, ...use]}   class={classMap({     [className]: true,     'mdc-button__label': context === 'button',     'mdc-fab__label': context === 'fab',     'mdc-tab__text-label': context === 'tab',     'mdc-image-list__label': context === 'image-list',     'mdc-snackbar__label': context === 'snackbar',     'mdc-banner__text': context === 'banner',     'mdc-segmented-button__label': context === 'segmented-button',     'mdc-data-table__pagination-rows-per-page-label':       context === 'data-table:pagination',     'mdc-data-table__header-cell-label':       context === 'data-table:sortable-header-cell',   })}   {...context === 'snackbar' ? { 'aria-atomic': 'false' } : {}}   {tabindex}   {...$$restProps}>
function create_default_slot$6(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[9].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		l: function claim(nodes) {
			if (default_slot) default_slot.l(nodes);
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 2048) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[11], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$6.name,
		type: "slot",
		source: "(1:0) <svelte:component   this={component}   bind:this={element}   use={[forwardEvents, ...use]}   class={classMap({     [className]: true,     'mdc-button__label': context === 'button',     'mdc-fab__label': context === 'fab',     'mdc-tab__text-label': context === 'tab',     'mdc-image-list__label': context === 'image-list',     'mdc-snackbar__label': context === 'snackbar',     'mdc-banner__text': context === 'banner',     'mdc-segmented-button__label': context === 'segmented-button',     'mdc-data-table__pagination-rows-per-page-label':       context === 'data-table:pagination',     'mdc-data-table__header-cell-label':       context === 'data-table:sortable-header-cell',   })}   {...context === 'snackbar' ? { 'aria-atomic': 'false' } : {}}   {tabindex}   {...$$restProps}>",
		ctx
	});

	return block;
}

function create_fragment$7(ctx) {
	let switch_instance;
	let switch_instance_anchor;
	let current;

	const switch_instance_spread_levels = [
		{
			use: [/*forwardEvents*/ ctx[4], .../*use*/ ctx[0]]
		},
		{
			class: classMap({
				[/*className*/ ctx[1]]: true,
				"mdc-button__label": /*context*/ ctx[5] === "button",
				"mdc-fab__label": /*context*/ ctx[5] === "fab",
				"mdc-tab__text-label": /*context*/ ctx[5] === "tab",
				"mdc-image-list__label": /*context*/ ctx[5] === "image-list",
				"mdc-snackbar__label": /*context*/ ctx[5] === "snackbar",
				"mdc-banner__text": /*context*/ ctx[5] === "banner",
				"mdc-segmented-button__label": /*context*/ ctx[5] === "segmented-button",
				"mdc-data-table__pagination-rows-per-page-label": /*context*/ ctx[5] === "data-table:pagination",
				"mdc-data-table__header-cell-label": /*context*/ ctx[5] === "data-table:sortable-header-cell"
			})
		},
		/*context*/ ctx[5] === "snackbar"
		? { "aria-atomic": "false" }
		: {},
		{ tabindex: /*tabindex*/ ctx[6] },
		/*$$restProps*/ ctx[7]
	];

	var switch_value = /*component*/ ctx[2];

	function switch_props(ctx) {
		let switch_instance_props = {
			$$slots: { default: [create_default_slot$6] },
			$$scope: { ctx }
		};

		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
		}

		return {
			props: switch_instance_props,
			$$inline: true
		};
	}

	if (switch_value) {
		switch_instance = new switch_value(switch_props(ctx));
		/*switch_instance_binding*/ ctx[10](switch_instance);
	}

	const block = {
		c: function create() {
			if (switch_instance) create_component(switch_instance.$$.fragment);
			switch_instance_anchor = empty();
		},
		l: function claim(nodes) {
			if (switch_instance) claim_component(switch_instance.$$.fragment, nodes);
			switch_instance_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (switch_instance) {
				mount_component(switch_instance, target, anchor);
			}

			insert_dev(target, switch_instance_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const switch_instance_changes = (dirty & /*forwardEvents, use, classMap, className, context, tabindex, $$restProps*/ 243)
			? get_spread_update(switch_instance_spread_levels, [
					dirty & /*forwardEvents, use*/ 17 && {
						use: [/*forwardEvents*/ ctx[4], .../*use*/ ctx[0]]
					},
					dirty & /*classMap, className, context*/ 34 && {
						class: classMap({
							[/*className*/ ctx[1]]: true,
							"mdc-button__label": /*context*/ ctx[5] === "button",
							"mdc-fab__label": /*context*/ ctx[5] === "fab",
							"mdc-tab__text-label": /*context*/ ctx[5] === "tab",
							"mdc-image-list__label": /*context*/ ctx[5] === "image-list",
							"mdc-snackbar__label": /*context*/ ctx[5] === "snackbar",
							"mdc-banner__text": /*context*/ ctx[5] === "banner",
							"mdc-segmented-button__label": /*context*/ ctx[5] === "segmented-button",
							"mdc-data-table__pagination-rows-per-page-label": /*context*/ ctx[5] === "data-table:pagination",
							"mdc-data-table__header-cell-label": /*context*/ ctx[5] === "data-table:sortable-header-cell"
						})
					},
					dirty & /*context*/ 32 && get_spread_object(/*context*/ ctx[5] === "snackbar"
					? { "aria-atomic": "false" }
					: {}),
					dirty & /*tabindex*/ 64 && { tabindex: /*tabindex*/ ctx[6] },
					dirty & /*$$restProps*/ 128 && get_spread_object(/*$$restProps*/ ctx[7])
				])
			: {};

			if (dirty & /*$$scope*/ 2048) {
				switch_instance_changes.$$scope = { dirty, ctx };
			}

			if (switch_value !== (switch_value = /*component*/ ctx[2])) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props(ctx));
					/*switch_instance_binding*/ ctx[10](switch_instance);
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}
		},
		i: function intro(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			/*switch_instance_binding*/ ctx[10](null);
			if (detaching) detach_dev(switch_instance_anchor);
			if (switch_instance) destroy_component(switch_instance, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$7.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$7($$self, $$props, $$invalidate) {
	const omit_props_names = ["use","class","component","getElement"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("CommonLabel", slots, ['default']);
	const forwardEvents = forwardEventsBuilder(get_current_component());
	let { use = [] } = $$props;
	let { class: className = "" } = $$props;
	let element;
	let { component = Span } = $$props;
	const context = getContext("SMUI:label:context");
	const tabindex = getContext("SMUI:label:tabindex");

	function getElement() {
		return element.getElement();
	}

	function switch_instance_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			element = $$value;
			$$invalidate(3, element);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("use" in $$new_props) $$invalidate(0, use = $$new_props.use);
		if ("class" in $$new_props) $$invalidate(1, className = $$new_props.class);
		if ("component" in $$new_props) $$invalidate(2, component = $$new_props.component);
		if ("$$scope" in $$new_props) $$invalidate(11, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		getContext,
		get_current_component,
		forwardEventsBuilder,
		classMap,
		useActions,
		Span,
		forwardEvents,
		use,
		className,
		element,
		component,
		context,
		tabindex,
		getElement
	});

	$$self.$inject_state = $$new_props => {
		if ("use" in $$props) $$invalidate(0, use = $$new_props.use);
		if ("className" in $$props) $$invalidate(1, className = $$new_props.className);
		if ("element" in $$props) $$invalidate(3, element = $$new_props.element);
		if ("component" in $$props) $$invalidate(2, component = $$new_props.component);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		use,
		className,
		component,
		element,
		forwardEvents,
		context,
		tabindex,
		$$restProps,
		getElement,
		slots,
		switch_instance_binding,
		$$scope
	];
}

class CommonLabel extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$7, create_fragment$7, safe_not_equal, {
			use: 0,
			class: 1,
			component: 2,
			getElement: 8
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "CommonLabel",
			options,
			id: create_fragment$7.name
		});
	}

	get use() {
		throw new Error("<CommonLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set use(value) {
		throw new Error("<CommonLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error("<CommonLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<CommonLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get component() {
		throw new Error("<CommonLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set component(value) {
		throw new Error("<CommonLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get getElement() {
		return this.$$.ctx[8];
	}

	set getElement(value) {
		throw new Error("<CommonLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/demo/data-table/_Simple.svelte generated by Svelte v3.37.0 */

// (4:6) <Cell>
function create_default_slot_22$2(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Name");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Name");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_22$2.name,
		type: "slot",
		source: "(4:6) <Cell>",
		ctx
	});

	return block;
}

// (5:6) <Cell>
function create_default_slot_21$2(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Favorite Color");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Favorite Color");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_21$2.name,
		type: "slot",
		source: "(5:6) <Cell>",
		ctx
	});

	return block;
}

// (6:6) <Cell numeric>
function create_default_slot_20$2(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Favorite Number");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Favorite Number");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_20$2.name,
		type: "slot",
		source: "(6:6) <Cell numeric>",
		ctx
	});

	return block;
}

// (3:4) <Row>
function create_default_slot_19$2(ctx) {
	let cell0;
	let t0;
	let cell1;
	let t1;
	let cell2;
	let current;

	cell0 = new Cell({
			props: {
				$$slots: { default: [create_default_slot_22$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	cell1 = new Cell({
			props: {
				$$slots: { default: [create_default_slot_21$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	cell2 = new Cell({
			props: {
				numeric: true,
				$$slots: { default: [create_default_slot_20$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(cell0.$$.fragment);
			t0 = space();
			create_component(cell1.$$.fragment);
			t1 = space();
			create_component(cell2.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(cell0.$$.fragment, nodes);
			t0 = claim_space(nodes);
			claim_component(cell1.$$.fragment, nodes);
			t1 = claim_space(nodes);
			claim_component(cell2.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(cell0, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(cell1, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(cell2, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const cell0_changes = {};

			if (dirty & /*$$scope*/ 1) {
				cell0_changes.$$scope = { dirty, ctx };
			}

			cell0.$set(cell0_changes);
			const cell1_changes = {};

			if (dirty & /*$$scope*/ 1) {
				cell1_changes.$$scope = { dirty, ctx };
			}

			cell1.$set(cell1_changes);
			const cell2_changes = {};

			if (dirty & /*$$scope*/ 1) {
				cell2_changes.$$scope = { dirty, ctx };
			}

			cell2.$set(cell2_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(cell0.$$.fragment, local);
			transition_in(cell1.$$.fragment, local);
			transition_in(cell2.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(cell0.$$.fragment, local);
			transition_out(cell1.$$.fragment, local);
			transition_out(cell2.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(cell0, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(cell1, detaching);
			if (detaching) detach_dev(t1);
			destroy_component(cell2, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_19$2.name,
		type: "slot",
		source: "(3:4) <Row>",
		ctx
	});

	return block;
}

// (2:2) <Head>
function create_default_slot_18$2(ctx) {
	let row;
	let current;

	row = new Row({
			props: {
				$$slots: { default: [create_default_slot_19$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(row.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(row.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(row, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const row_changes = {};

			if (dirty & /*$$scope*/ 1) {
				row_changes.$$scope = { dirty, ctx };
			}

			row.$set(row_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(row.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(row.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(row, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_18$2.name,
		type: "slot",
		source: "(2:2) <Head>",
		ctx
	});

	return block;
}

// (11:6) <Cell>
function create_default_slot_17$2(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Steve");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Steve");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_17$2.name,
		type: "slot",
		source: "(11:6) <Cell>",
		ctx
	});

	return block;
}

// (12:6) <Cell>
function create_default_slot_16$2(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Red");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Red");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_16$2.name,
		type: "slot",
		source: "(12:6) <Cell>",
		ctx
	});

	return block;
}

// (13:6) <Cell numeric>
function create_default_slot_15$2(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("45");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "45");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_15$2.name,
		type: "slot",
		source: "(13:6) <Cell numeric>",
		ctx
	});

	return block;
}

// (10:4) <Row>
function create_default_slot_14$2(ctx) {
	let cell0;
	let t0;
	let cell1;
	let t1;
	let cell2;
	let current;

	cell0 = new Cell({
			props: {
				$$slots: { default: [create_default_slot_17$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	cell1 = new Cell({
			props: {
				$$slots: { default: [create_default_slot_16$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	cell2 = new Cell({
			props: {
				numeric: true,
				$$slots: { default: [create_default_slot_15$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(cell0.$$.fragment);
			t0 = space();
			create_component(cell1.$$.fragment);
			t1 = space();
			create_component(cell2.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(cell0.$$.fragment, nodes);
			t0 = claim_space(nodes);
			claim_component(cell1.$$.fragment, nodes);
			t1 = claim_space(nodes);
			claim_component(cell2.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(cell0, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(cell1, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(cell2, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const cell0_changes = {};

			if (dirty & /*$$scope*/ 1) {
				cell0_changes.$$scope = { dirty, ctx };
			}

			cell0.$set(cell0_changes);
			const cell1_changes = {};

			if (dirty & /*$$scope*/ 1) {
				cell1_changes.$$scope = { dirty, ctx };
			}

			cell1.$set(cell1_changes);
			const cell2_changes = {};

			if (dirty & /*$$scope*/ 1) {
				cell2_changes.$$scope = { dirty, ctx };
			}

			cell2.$set(cell2_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(cell0.$$.fragment, local);
			transition_in(cell1.$$.fragment, local);
			transition_in(cell2.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(cell0.$$.fragment, local);
			transition_out(cell1.$$.fragment, local);
			transition_out(cell2.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(cell0, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(cell1, detaching);
			if (detaching) detach_dev(t1);
			destroy_component(cell2, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_14$2.name,
		type: "slot",
		source: "(10:4) <Row>",
		ctx
	});

	return block;
}

// (16:6) <Cell>
function create_default_slot_13$3(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Sharon");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Sharon");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_13$3.name,
		type: "slot",
		source: "(16:6) <Cell>",
		ctx
	});

	return block;
}

// (17:6) <Cell>
function create_default_slot_12$4(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Purple");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Purple");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_12$4.name,
		type: "slot",
		source: "(17:6) <Cell>",
		ctx
	});

	return block;
}

// (18:6) <Cell numeric>
function create_default_slot_11$4(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("5");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "5");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_11$4.name,
		type: "slot",
		source: "(18:6) <Cell numeric>",
		ctx
	});

	return block;
}

// (15:4) <Row>
function create_default_slot_10$4(ctx) {
	let cell0;
	let t0;
	let cell1;
	let t1;
	let cell2;
	let current;

	cell0 = new Cell({
			props: {
				$$slots: { default: [create_default_slot_13$3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	cell1 = new Cell({
			props: {
				$$slots: { default: [create_default_slot_12$4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	cell2 = new Cell({
			props: {
				numeric: true,
				$$slots: { default: [create_default_slot_11$4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(cell0.$$.fragment);
			t0 = space();
			create_component(cell1.$$.fragment);
			t1 = space();
			create_component(cell2.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(cell0.$$.fragment, nodes);
			t0 = claim_space(nodes);
			claim_component(cell1.$$.fragment, nodes);
			t1 = claim_space(nodes);
			claim_component(cell2.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(cell0, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(cell1, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(cell2, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const cell0_changes = {};

			if (dirty & /*$$scope*/ 1) {
				cell0_changes.$$scope = { dirty, ctx };
			}

			cell0.$set(cell0_changes);
			const cell1_changes = {};

			if (dirty & /*$$scope*/ 1) {
				cell1_changes.$$scope = { dirty, ctx };
			}

			cell1.$set(cell1_changes);
			const cell2_changes = {};

			if (dirty & /*$$scope*/ 1) {
				cell2_changes.$$scope = { dirty, ctx };
			}

			cell2.$set(cell2_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(cell0.$$.fragment, local);
			transition_in(cell1.$$.fragment, local);
			transition_in(cell2.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(cell0.$$.fragment, local);
			transition_out(cell1.$$.fragment, local);
			transition_out(cell2.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(cell0, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(cell1, detaching);
			if (detaching) detach_dev(t1);
			destroy_component(cell2, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_10$4.name,
		type: "slot",
		source: "(15:4) <Row>",
		ctx
	});

	return block;
}

// (21:6) <Cell>
function create_default_slot_9$4(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Rodney");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Rodney");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_9$4.name,
		type: "slot",
		source: "(21:6) <Cell>",
		ctx
	});

	return block;
}

// (22:6) <Cell>
function create_default_slot_8$4(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Orange");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Orange");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_8$4.name,
		type: "slot",
		source: "(22:6) <Cell>",
		ctx
	});

	return block;
}

// (23:6) <Cell numeric>
function create_default_slot_7$4(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("32");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "32");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_7$4.name,
		type: "slot",
		source: "(23:6) <Cell numeric>",
		ctx
	});

	return block;
}

// (20:4) <Row>
function create_default_slot_6$4(ctx) {
	let cell0;
	let t0;
	let cell1;
	let t1;
	let cell2;
	let current;

	cell0 = new Cell({
			props: {
				$$slots: { default: [create_default_slot_9$4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	cell1 = new Cell({
			props: {
				$$slots: { default: [create_default_slot_8$4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	cell2 = new Cell({
			props: {
				numeric: true,
				$$slots: { default: [create_default_slot_7$4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(cell0.$$.fragment);
			t0 = space();
			create_component(cell1.$$.fragment);
			t1 = space();
			create_component(cell2.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(cell0.$$.fragment, nodes);
			t0 = claim_space(nodes);
			claim_component(cell1.$$.fragment, nodes);
			t1 = claim_space(nodes);
			claim_component(cell2.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(cell0, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(cell1, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(cell2, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const cell0_changes = {};

			if (dirty & /*$$scope*/ 1) {
				cell0_changes.$$scope = { dirty, ctx };
			}

			cell0.$set(cell0_changes);
			const cell1_changes = {};

			if (dirty & /*$$scope*/ 1) {
				cell1_changes.$$scope = { dirty, ctx };
			}

			cell1.$set(cell1_changes);
			const cell2_changes = {};

			if (dirty & /*$$scope*/ 1) {
				cell2_changes.$$scope = { dirty, ctx };
			}

			cell2.$set(cell2_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(cell0.$$.fragment, local);
			transition_in(cell1.$$.fragment, local);
			transition_in(cell2.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(cell0.$$.fragment, local);
			transition_out(cell1.$$.fragment, local);
			transition_out(cell2.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(cell0, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(cell1, detaching);
			if (detaching) detach_dev(t1);
			destroy_component(cell2, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_6$4.name,
		type: "slot",
		source: "(20:4) <Row>",
		ctx
	});

	return block;
}

// (26:6) <Cell>
function create_default_slot_5$4(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Mack");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Mack");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_5$4.name,
		type: "slot",
		source: "(26:6) <Cell>",
		ctx
	});

	return block;
}

// (27:6) <Cell>
function create_default_slot_4$5(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Blue");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Blue");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_4$5.name,
		type: "slot",
		source: "(27:6) <Cell>",
		ctx
	});

	return block;
}

// (28:6) <Cell numeric>
function create_default_slot_3$5(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("12");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "12");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3$5.name,
		type: "slot",
		source: "(28:6) <Cell numeric>",
		ctx
	});

	return block;
}

// (25:4) <Row>
function create_default_slot_2$5(ctx) {
	let cell0;
	let t0;
	let cell1;
	let t1;
	let cell2;
	let current;

	cell0 = new Cell({
			props: {
				$$slots: { default: [create_default_slot_5$4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	cell1 = new Cell({
			props: {
				$$slots: { default: [create_default_slot_4$5] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	cell2 = new Cell({
			props: {
				numeric: true,
				$$slots: { default: [create_default_slot_3$5] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(cell0.$$.fragment);
			t0 = space();
			create_component(cell1.$$.fragment);
			t1 = space();
			create_component(cell2.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(cell0.$$.fragment, nodes);
			t0 = claim_space(nodes);
			claim_component(cell1.$$.fragment, nodes);
			t1 = claim_space(nodes);
			claim_component(cell2.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(cell0, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(cell1, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(cell2, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const cell0_changes = {};

			if (dirty & /*$$scope*/ 1) {
				cell0_changes.$$scope = { dirty, ctx };
			}

			cell0.$set(cell0_changes);
			const cell1_changes = {};

			if (dirty & /*$$scope*/ 1) {
				cell1_changes.$$scope = { dirty, ctx };
			}

			cell1.$set(cell1_changes);
			const cell2_changes = {};

			if (dirty & /*$$scope*/ 1) {
				cell2_changes.$$scope = { dirty, ctx };
			}

			cell2.$set(cell2_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(cell0.$$.fragment, local);
			transition_in(cell1.$$.fragment, local);
			transition_in(cell2.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(cell0.$$.fragment, local);
			transition_out(cell1.$$.fragment, local);
			transition_out(cell2.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(cell0, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(cell1, detaching);
			if (detaching) detach_dev(t1);
			destroy_component(cell2, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2$5.name,
		type: "slot",
		source: "(25:4) <Row>",
		ctx
	});

	return block;
}

// (9:2) <Body>
function create_default_slot_1$5(ctx) {
	let row0;
	let t0;
	let row1;
	let t1;
	let row2;
	let t2;
	let row3;
	let current;

	row0 = new Row({
			props: {
				$$slots: { default: [create_default_slot_14$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	row1 = new Row({
			props: {
				$$slots: { default: [create_default_slot_10$4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	row2 = new Row({
			props: {
				$$slots: { default: [create_default_slot_6$4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	row3 = new Row({
			props: {
				$$slots: { default: [create_default_slot_2$5] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(row0.$$.fragment);
			t0 = space();
			create_component(row1.$$.fragment);
			t1 = space();
			create_component(row2.$$.fragment);
			t2 = space();
			create_component(row3.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(row0.$$.fragment, nodes);
			t0 = claim_space(nodes);
			claim_component(row1.$$.fragment, nodes);
			t1 = claim_space(nodes);
			claim_component(row2.$$.fragment, nodes);
			t2 = claim_space(nodes);
			claim_component(row3.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(row0, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(row1, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(row2, target, anchor);
			insert_dev(target, t2, anchor);
			mount_component(row3, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const row0_changes = {};

			if (dirty & /*$$scope*/ 1) {
				row0_changes.$$scope = { dirty, ctx };
			}

			row0.$set(row0_changes);
			const row1_changes = {};

			if (dirty & /*$$scope*/ 1) {
				row1_changes.$$scope = { dirty, ctx };
			}

			row1.$set(row1_changes);
			const row2_changes = {};

			if (dirty & /*$$scope*/ 1) {
				row2_changes.$$scope = { dirty, ctx };
			}

			row2.$set(row2_changes);
			const row3_changes = {};

			if (dirty & /*$$scope*/ 1) {
				row3_changes.$$scope = { dirty, ctx };
			}

			row3.$set(row3_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(row0.$$.fragment, local);
			transition_in(row1.$$.fragment, local);
			transition_in(row2.$$.fragment, local);
			transition_in(row3.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(row0.$$.fragment, local);
			transition_out(row1.$$.fragment, local);
			transition_out(row2.$$.fragment, local);
			transition_out(row3.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(row0, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(row1, detaching);
			if (detaching) detach_dev(t1);
			destroy_component(row2, detaching);
			if (detaching) detach_dev(t2);
			destroy_component(row3, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$5.name,
		type: "slot",
		source: "(9:2) <Body>",
		ctx
	});

	return block;
}

// (1:0) <DataTable table$aria-label="People list" style="max-width: 100%;">
function create_default_slot$5(ctx) {
	let head;
	let t;
	let body;
	let current;

	head = new Head({
			props: {
				$$slots: { default: [create_default_slot_18$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	body = new Body({
			props: {
				$$slots: { default: [create_default_slot_1$5] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(head.$$.fragment);
			t = space();
			create_component(body.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(head.$$.fragment, nodes);
			t = claim_space(nodes);
			claim_component(body.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(head, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(body, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const head_changes = {};

			if (dirty & /*$$scope*/ 1) {
				head_changes.$$scope = { dirty, ctx };
			}

			head.$set(head_changes);
			const body_changes = {};

			if (dirty & /*$$scope*/ 1) {
				body_changes.$$scope = { dirty, ctx };
			}

			body.$set(body_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(head.$$.fragment, local);
			transition_in(body.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(head.$$.fragment, local);
			transition_out(body.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(head, detaching);
			if (detaching) detach_dev(t);
			destroy_component(body, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$5.name,
		type: "slot",
		source: "(1:0) <DataTable table$aria-label=\\\"People list\\\" style=\\\"max-width: 100%;\\\">",
		ctx
	});

	return block;
}

function create_fragment$6(ctx) {
	let datatable;
	let current;

	datatable = new DataTable({
			props: {
				"table$aria-label": "People list",
				style: "max-width: 100%;",
				$$slots: { default: [create_default_slot$5] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(datatable.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(datatable.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(datatable, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const datatable_changes = {};

			if (dirty & /*$$scope*/ 1) {
				datatable_changes.$$scope = { dirty, ctx };
			}

			datatable.$set(datatable_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(datatable.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(datatable.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(datatable, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$6.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$6($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Simple", slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Simple> was created with unknown prop '${key}'`);
	});

	$$self.$capture_state = () => ({ DataTable, Head, Body, Row, Cell });
	return [];
}

class Simple extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$6, create_fragment$6, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Simple",
			options,
			id: create_fragment$6.name
		});
	}
}

/* src/routes/demo/data-table/_ProgressIndicator.svelte generated by Svelte v3.37.0 */
const file$3 = "src/routes/demo/data-table/_ProgressIndicator.svelte";

function get_each_context$3(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[5] = list[i];
	return child_ctx;
}

// (2:2) <Button on:click={() => loadThings(true)}>
function create_default_slot_13$2(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Do Pretend Loading");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Do Pretend Loading");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_13$2.name,
		type: "slot",
		source: "(2:2) <Button on:click={() => loadThings(true)}>",
		ctx
	});

	return block;
}

// (8:6) <Cell numeric>
function create_default_slot_12$3(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("ID");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "ID");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_12$3.name,
		type: "slot",
		source: "(8:6) <Cell numeric>",
		ctx
	});

	return block;
}

// (9:6) <Cell style="width: 100%;">
function create_default_slot_11$3(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Name");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Name");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_11$3.name,
		type: "slot",
		source: "(9:6) <Cell style=\\\"width: 100%;\\\">",
		ctx
	});

	return block;
}

// (10:6) <Cell>
function create_default_slot_10$3(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Username");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Username");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_10$3.name,
		type: "slot",
		source: "(10:6) <Cell>",
		ctx
	});

	return block;
}

// (11:6) <Cell>
function create_default_slot_9$3(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Email");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Email");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_9$3.name,
		type: "slot",
		source: "(11:6) <Cell>",
		ctx
	});

	return block;
}

// (7:4) <Row>
function create_default_slot_8$3(ctx) {
	let cell0;
	let t0;
	let cell1;
	let t1;
	let cell2;
	let t2;
	let cell3;
	let current;

	cell0 = new Cell({
			props: {
				numeric: true,
				$$slots: { default: [create_default_slot_12$3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	cell1 = new Cell({
			props: {
				style: "width: 100%;",
				$$slots: { default: [create_default_slot_11$3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	cell2 = new Cell({
			props: {
				$$slots: { default: [create_default_slot_10$3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	cell3 = new Cell({
			props: {
				$$slots: { default: [create_default_slot_9$3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(cell0.$$.fragment);
			t0 = space();
			create_component(cell1.$$.fragment);
			t1 = space();
			create_component(cell2.$$.fragment);
			t2 = space();
			create_component(cell3.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(cell0.$$.fragment, nodes);
			t0 = claim_space(nodes);
			claim_component(cell1.$$.fragment, nodes);
			t1 = claim_space(nodes);
			claim_component(cell2.$$.fragment, nodes);
			t2 = claim_space(nodes);
			claim_component(cell3.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(cell0, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(cell1, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(cell2, target, anchor);
			insert_dev(target, t2, anchor);
			mount_component(cell3, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const cell0_changes = {};

			if (dirty & /*$$scope*/ 256) {
				cell0_changes.$$scope = { dirty, ctx };
			}

			cell0.$set(cell0_changes);
			const cell1_changes = {};

			if (dirty & /*$$scope*/ 256) {
				cell1_changes.$$scope = { dirty, ctx };
			}

			cell1.$set(cell1_changes);
			const cell2_changes = {};

			if (dirty & /*$$scope*/ 256) {
				cell2_changes.$$scope = { dirty, ctx };
			}

			cell2.$set(cell2_changes);
			const cell3_changes = {};

			if (dirty & /*$$scope*/ 256) {
				cell3_changes.$$scope = { dirty, ctx };
			}

			cell3.$set(cell3_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(cell0.$$.fragment, local);
			transition_in(cell1.$$.fragment, local);
			transition_in(cell2.$$.fragment, local);
			transition_in(cell3.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(cell0.$$.fragment, local);
			transition_out(cell1.$$.fragment, local);
			transition_out(cell2.$$.fragment, local);
			transition_out(cell3.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(cell0, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(cell1, detaching);
			if (detaching) detach_dev(t1);
			destroy_component(cell2, detaching);
			if (detaching) detach_dev(t2);
			destroy_component(cell3, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_8$3.name,
		type: "slot",
		source: "(7:4) <Row>",
		ctx
	});

	return block;
}

// (6:2) <Head>
function create_default_slot_7$3(ctx) {
	let row;
	let current;

	row = new Row({
			props: {
				$$slots: { default: [create_default_slot_8$3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(row.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(row.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(row, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const row_changes = {};

			if (dirty & /*$$scope*/ 256) {
				row_changes.$$scope = { dirty, ctx };
			}

			row.$set(row_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(row.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(row.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(row, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_7$3.name,
		type: "slot",
		source: "(6:2) <Head>",
		ctx
	});

	return block;
}

// (17:8) <Cell numeric>
function create_default_slot_6$3(ctx) {
	let t_value = /*item*/ ctx[5].id + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		l: function claim(nodes) {
			t = claim_text(nodes, t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*items*/ 1 && t_value !== (t_value = /*item*/ ctx[5].id + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_6$3.name,
		type: "slot",
		source: "(17:8) <Cell numeric>",
		ctx
	});

	return block;
}

// (18:8) <Cell>
function create_default_slot_5$3(ctx) {
	let t_value = /*item*/ ctx[5].name + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		l: function claim(nodes) {
			t = claim_text(nodes, t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*items*/ 1 && t_value !== (t_value = /*item*/ ctx[5].name + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_5$3.name,
		type: "slot",
		source: "(18:8) <Cell>",
		ctx
	});

	return block;
}

// (19:8) <Cell>
function create_default_slot_4$4(ctx) {
	let t_value = /*item*/ ctx[5].username + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		l: function claim(nodes) {
			t = claim_text(nodes, t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*items*/ 1 && t_value !== (t_value = /*item*/ ctx[5].username + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_4$4.name,
		type: "slot",
		source: "(19:8) <Cell>",
		ctx
	});

	return block;
}

// (20:8) <Cell>
function create_default_slot_3$4(ctx) {
	let t_value = /*item*/ ctx[5].email + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		l: function claim(nodes) {
			t = claim_text(nodes, t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*items*/ 1 && t_value !== (t_value = /*item*/ ctx[5].email + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3$4.name,
		type: "slot",
		source: "(20:8) <Cell>",
		ctx
	});

	return block;
}

// (16:6) <Row>
function create_default_slot_2$4(ctx) {
	let cell0;
	let t0;
	let cell1;
	let t1;
	let cell2;
	let t2;
	let cell3;
	let t3;
	let current;

	cell0 = new Cell({
			props: {
				numeric: true,
				$$slots: { default: [create_default_slot_6$3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	cell1 = new Cell({
			props: {
				$$slots: { default: [create_default_slot_5$3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	cell2 = new Cell({
			props: {
				$$slots: { default: [create_default_slot_4$4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	cell3 = new Cell({
			props: {
				$$slots: { default: [create_default_slot_3$4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(cell0.$$.fragment);
			t0 = space();
			create_component(cell1.$$.fragment);
			t1 = space();
			create_component(cell2.$$.fragment);
			t2 = space();
			create_component(cell3.$$.fragment);
			t3 = space();
		},
		l: function claim(nodes) {
			claim_component(cell0.$$.fragment, nodes);
			t0 = claim_space(nodes);
			claim_component(cell1.$$.fragment, nodes);
			t1 = claim_space(nodes);
			claim_component(cell2.$$.fragment, nodes);
			t2 = claim_space(nodes);
			claim_component(cell3.$$.fragment, nodes);
			t3 = claim_space(nodes);
		},
		m: function mount(target, anchor) {
			mount_component(cell0, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(cell1, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(cell2, target, anchor);
			insert_dev(target, t2, anchor);
			mount_component(cell3, target, anchor);
			insert_dev(target, t3, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const cell0_changes = {};

			if (dirty & /*$$scope, items*/ 257) {
				cell0_changes.$$scope = { dirty, ctx };
			}

			cell0.$set(cell0_changes);
			const cell1_changes = {};

			if (dirty & /*$$scope, items*/ 257) {
				cell1_changes.$$scope = { dirty, ctx };
			}

			cell1.$set(cell1_changes);
			const cell2_changes = {};

			if (dirty & /*$$scope, items*/ 257) {
				cell2_changes.$$scope = { dirty, ctx };
			}

			cell2.$set(cell2_changes);
			const cell3_changes = {};

			if (dirty & /*$$scope, items*/ 257) {
				cell3_changes.$$scope = { dirty, ctx };
			}

			cell3.$set(cell3_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(cell0.$$.fragment, local);
			transition_in(cell1.$$.fragment, local);
			transition_in(cell2.$$.fragment, local);
			transition_in(cell3.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(cell0.$$.fragment, local);
			transition_out(cell1.$$.fragment, local);
			transition_out(cell2.$$.fragment, local);
			transition_out(cell3.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(cell0, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(cell1, detaching);
			if (detaching) detach_dev(t1);
			destroy_component(cell2, detaching);
			if (detaching) detach_dev(t2);
			destroy_component(cell3, detaching);
			if (detaching) detach_dev(t3);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2$4.name,
		type: "slot",
		source: "(16:6) <Row>",
		ctx
	});

	return block;
}

// (15:4) {#each items as item (item.id)}
function create_each_block$3(key_1, ctx) {
	let first;
	let row;
	let current;

	row = new Row({
			props: {
				$$slots: { default: [create_default_slot_2$4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		key: key_1,
		first: null,
		c: function create() {
			first = empty();
			create_component(row.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			first = empty();
			claim_component(row.$$.fragment, nodes);
			this.h();
		},
		h: function hydrate() {
			this.first = first;
		},
		m: function mount(target, anchor) {
			insert_dev(target, first, anchor);
			mount_component(row, target, anchor);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			const row_changes = {};

			if (dirty & /*$$scope, items*/ 257) {
				row_changes.$$scope = { dirty, ctx };
			}

			row.$set(row_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(row.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(row.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(first);
			destroy_component(row, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$3.name,
		type: "each",
		source: "(15:4) {#each items as item (item.id)}",
		ctx
	});

	return block;
}

// (14:2) <Body>
function create_default_slot_1$4(ctx) {
	let each_blocks = [];
	let each_1_lookup = new Map();
	let each_1_anchor;
	let current;
	let each_value = /*items*/ ctx[0];
	validate_each_argument(each_value);
	const get_key = ctx => /*item*/ ctx[5].id;
	validate_each_keys(ctx, each_value, get_each_context$3, get_key);

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context$3(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block$3(key, child_ctx));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (dirty & /*items*/ 1) {
				each_value = /*items*/ ctx[0];
				validate_each_argument(each_value);
				group_outros();
				validate_each_keys(ctx, each_value, get_each_context$3, get_key);
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$3, each_1_anchor, get_each_context$3);
				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d(detaching);
			}

			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$4.name,
		type: "slot",
		source: "(14:2) <Body>",
		ctx
	});

	return block;
}

// (5:0) <DataTable table$aria-label="User list" style="width: 100%;">
function create_default_slot$4(ctx) {
	let head;
	let t;
	let body;
	let current;

	head = new Head({
			props: {
				$$slots: { default: [create_default_slot_7$3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	body = new Body({
			props: {
				$$slots: { default: [create_default_slot_1$4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(head.$$.fragment);
			t = space();
			create_component(body.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(head.$$.fragment, nodes);
			t = claim_space(nodes);
			claim_component(body.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(head, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(body, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const head_changes = {};

			if (dirty & /*$$scope*/ 256) {
				head_changes.$$scope = { dirty, ctx };
			}

			head.$set(head_changes);
			const body_changes = {};

			if (dirty & /*$$scope, items*/ 257) {
				body_changes.$$scope = { dirty, ctx };
			}

			body.$set(body_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(head.$$.fragment, local);
			transition_in(body.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(head.$$.fragment, local);
			transition_out(body.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(head, detaching);
			if (detaching) detach_dev(t);
			destroy_component(body, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$4.name,
		type: "slot",
		source: "(5:0) <DataTable table$aria-label=\\\"User list\\\" style=\\\"width: 100%;\\\">",
		ctx
	});

	return block;
}

// (25:2) 
function create_progress_slot(ctx) {
	let linearprogress;
	let updating_closed;
	let current;

	function linearprogress_closed_binding(value) {
		/*linearprogress_closed_binding*/ ctx[4](value);
	}

	let linearprogress_props = {
		indeterminate: true,
		"aria-label": "Data is being loaded...",
		slot: "progress"
	};

	if (/*loaded*/ ctx[1] !== void 0) {
		linearprogress_props.closed = /*loaded*/ ctx[1];
	}

	linearprogress = new LinearProgress({
			props: linearprogress_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(linearprogress, "closed", linearprogress_closed_binding));

	const block = {
		c: function create() {
			create_component(linearprogress.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(linearprogress.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(linearprogress, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const linearprogress_changes = {};

			if (!updating_closed && dirty & /*loaded*/ 2) {
				updating_closed = true;
				linearprogress_changes.closed = /*loaded*/ ctx[1];
				add_flush_callback(() => updating_closed = false);
			}

			linearprogress.$set(linearprogress_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(linearprogress.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(linearprogress.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(linearprogress, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_progress_slot.name,
		type: "slot",
		source: "(25:2) ",
		ctx
	});

	return block;
}

function create_fragment$5(ctx) {
	let div;
	let button;
	let t;
	let datatable;
	let current;

	button = new Button_1({
			props: {
				$$slots: { default: [create_default_slot_13$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button.$on("click", /*click_handler*/ ctx[3]);

	datatable = new DataTable({
			props: {
				"table$aria-label": "User list",
				style: "width: 100%;",
				$$slots: {
					progress: [create_progress_slot],
					default: [create_default_slot$4]
				},
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			div = element("div");
			create_component(button.$$.fragment);
			t = space();
			create_component(datatable.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { style: true });
			var div_nodes = children(div);
			claim_component(button.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			t = claim_space(nodes);
			claim_component(datatable.$$.fragment, nodes);
			this.h();
		},
		h: function hydrate() {
			set_style(div, "margin-bottom", "1em");
			add_location(div, file$3, 0, 0, 0);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(button, div, null);
			insert_dev(target, t, anchor);
			mount_component(datatable, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const button_changes = {};

			if (dirty & /*$$scope*/ 256) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
			const datatable_changes = {};

			if (dirty & /*$$scope, loaded, items*/ 259) {
				datatable_changes.$$scope = { dirty, ctx };
			}

			datatable.$set(datatable_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			transition_in(datatable.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button.$$.fragment, local);
			transition_out(datatable.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(button);
			if (detaching) detach_dev(t);
			destroy_component(datatable, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$5.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$5($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("ProgressIndicator", slots, []);
	let items = [];
	let loaded = false;
	loadThings(false);

	function loadThings(wait) {
		if (typeof fetch !== "undefined") {
			$$invalidate(1, loaded = false);

			fetch("https://gist.githubusercontent.com/hperrin/e24a4ebd9afdf2a8c283338ae5160a62/raw/dcbf8e6382db49b0dcab70b22f56b1cc444f26d4/users.json").then(response => response.json()).then(json => setTimeout(
				() => {
					$$invalidate(0, items = json);
					$$invalidate(1, loaded = true);
				},
				// Simulate a long load time.
				wait ? 2000 : 0
			));
		}
	}

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ProgressIndicator> was created with unknown prop '${key}'`);
	});

	const click_handler = () => loadThings(true);

	function linearprogress_closed_binding(value) {
		loaded = value;
		$$invalidate(1, loaded);
	}

	$$self.$capture_state = () => ({
		DataTable,
		Head,
		Body,
		Row,
		Cell,
		LinearProgress,
		Button: Button_1,
		items,
		loaded,
		loadThings
	});

	$$self.$inject_state = $$props => {
		if ("items" in $$props) $$invalidate(0, items = $$props.items);
		if ("loaded" in $$props) $$invalidate(1, loaded = $$props.loaded);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [items, loaded, loadThings, click_handler, linearprogress_closed_binding];
}

class ProgressIndicator extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$5, create_fragment$5, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ProgressIndicator",
			options,
			id: create_fragment$5.name
		});
	}
}

/* src/routes/demo/data-table/_StickyHeader.svelte generated by Svelte v3.37.0 */

const file$2 = "src/routes/demo/data-table/_StickyHeader.svelte";

function create_fragment$4(ctx) {
	let iframe;
	let iframe_src_value;
	let t0;
	let a;
	let t1;

	const block = {
		c: function create() {
			iframe = element("iframe");
			t0 = space();
			a = element("a");
			t1 = text("helper needed for sapper export");
			this.h();
		},
		l: function claim(nodes) {
			iframe = claim_element(nodes, "IFRAME", { class: true, src: true, title: true });
			children(iframe).forEach(detach_dev);
			t0 = claim_space(nodes);
			a = claim_element(nodes, "A", { style: true, href: true });
			var a_nodes = children(a);
			t1 = claim_text(a_nodes, "helper needed for sapper export");
			a_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(iframe, "class", "data-table-iframe svelte-17yw4hl");
			if (iframe.src !== (iframe_src_value = "/demo/data-table/iframe")) attr_dev(iframe, "src", iframe_src_value);
			attr_dev(iframe, "title", "standard");
			add_location(iframe, file$2, 1, 0, 57);
			set_style(a, "display", "none");
			attr_dev(a, "href", "/demo/data-table/iframe");
			add_location(a, file$2, 6, 0, 147);
		},
		m: function mount(target, anchor) {
			insert_dev(target, iframe, anchor);
			insert_dev(target, t0, anchor);
			insert_dev(target, a, anchor);
			append_dev(a, t1);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(iframe);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(a);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("StickyHeader", slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<StickyHeader> was created with unknown prop '${key}'`);
	});

	return [];
}

class StickyHeader extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4, create_fragment$4, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "StickyHeader",
			options,
			id: create_fragment$4.name
		});
	}
}

/* src/routes/demo/data-table/_RowSelection.svelte generated by Svelte v3.37.0 */
const file$1 = "src/routes/demo/data-table/_RowSelection.svelte";

function get_each_context$2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[4] = list[i];
	return child_ctx;
}

// (4:6) <Cell checkbox>
function create_default_slot_12$2(ctx) {
	let checkbox;
	let current;
	checkbox = new Checkbox({ $$inline: true });

	const block = {
		c: function create() {
			create_component(checkbox.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(checkbox.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(checkbox, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(checkbox.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(checkbox.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(checkbox, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_12$2.name,
		type: "slot",
		source: "(4:6) <Cell checkbox>",
		ctx
	});

	return block;
}

// (7:6) <Cell>
function create_default_slot_11$2(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Name");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Name");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_11$2.name,
		type: "slot",
		source: "(7:6) <Cell>",
		ctx
	});

	return block;
}

// (8:6) <Cell>
function create_default_slot_10$2(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Description");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Description");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_10$2.name,
		type: "slot",
		source: "(8:6) <Cell>",
		ctx
	});

	return block;
}

// (9:6) <Cell numeric>
function create_default_slot_9$2(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Price");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Price");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_9$2.name,
		type: "slot",
		source: "(9:6) <Cell numeric>",
		ctx
	});

	return block;
}

// (3:4) <Row>
function create_default_slot_8$2(ctx) {
	let cell0;
	let t0;
	let cell1;
	let t1;
	let cell2;
	let t2;
	let cell3;
	let current;

	cell0 = new Cell({
			props: {
				checkbox: true,
				$$slots: { default: [create_default_slot_12$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	cell1 = new Cell({
			props: {
				$$slots: { default: [create_default_slot_11$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	cell2 = new Cell({
			props: {
				$$slots: { default: [create_default_slot_10$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	cell3 = new Cell({
			props: {
				numeric: true,
				$$slots: { default: [create_default_slot_9$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(cell0.$$.fragment);
			t0 = space();
			create_component(cell1.$$.fragment);
			t1 = space();
			create_component(cell2.$$.fragment);
			t2 = space();
			create_component(cell3.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(cell0.$$.fragment, nodes);
			t0 = claim_space(nodes);
			claim_component(cell1.$$.fragment, nodes);
			t1 = claim_space(nodes);
			claim_component(cell2.$$.fragment, nodes);
			t2 = claim_space(nodes);
			claim_component(cell3.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(cell0, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(cell1, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(cell2, target, anchor);
			insert_dev(target, t2, anchor);
			mount_component(cell3, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const cell0_changes = {};

			if (dirty & /*$$scope*/ 128) {
				cell0_changes.$$scope = { dirty, ctx };
			}

			cell0.$set(cell0_changes);
			const cell1_changes = {};

			if (dirty & /*$$scope*/ 128) {
				cell1_changes.$$scope = { dirty, ctx };
			}

			cell1.$set(cell1_changes);
			const cell2_changes = {};

			if (dirty & /*$$scope*/ 128) {
				cell2_changes.$$scope = { dirty, ctx };
			}

			cell2.$set(cell2_changes);
			const cell3_changes = {};

			if (dirty & /*$$scope*/ 128) {
				cell3_changes.$$scope = { dirty, ctx };
			}

			cell3.$set(cell3_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(cell0.$$.fragment, local);
			transition_in(cell1.$$.fragment, local);
			transition_in(cell2.$$.fragment, local);
			transition_in(cell3.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(cell0.$$.fragment, local);
			transition_out(cell1.$$.fragment, local);
			transition_out(cell2.$$.fragment, local);
			transition_out(cell3.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(cell0, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(cell1, detaching);
			if (detaching) detach_dev(t1);
			destroy_component(cell2, detaching);
			if (detaching) detach_dev(t2);
			destroy_component(cell3, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_8$2.name,
		type: "slot",
		source: "(3:4) <Row>",
		ctx
	});

	return block;
}

// (2:2) <Head>
function create_default_slot_7$2(ctx) {
	let row;
	let current;

	row = new Row({
			props: {
				$$slots: { default: [create_default_slot_8$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(row.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(row.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(row, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const row_changes = {};

			if (dirty & /*$$scope*/ 128) {
				row_changes.$$scope = { dirty, ctx };
			}

			row.$set(row_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(row.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(row.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(row, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_7$2.name,
		type: "slot",
		source: "(2:2) <Head>",
		ctx
	});

	return block;
}

// (15:8) <Cell checkbox>
function create_default_slot_6$2(ctx) {
	let checkbox;
	let updating_group;
	let current;

	function checkbox_group_binding(value) {
		/*checkbox_group_binding*/ ctx[3](value);
	}

	let checkbox_props = {
		value: /*option*/ ctx[4],
		valueKey: /*option*/ ctx[4].name
	};

	if (/*selected*/ ctx[0] !== void 0) {
		checkbox_props.group = /*selected*/ ctx[0];
	}

	checkbox = new Checkbox({ props: checkbox_props, $$inline: true });
	binding_callbacks.push(() => bind(checkbox, "group", checkbox_group_binding));

	const block = {
		c: function create() {
			create_component(checkbox.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(checkbox.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(checkbox, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const checkbox_changes = {};

			if (!updating_group && dirty & /*selected*/ 1) {
				updating_group = true;
				checkbox_changes.group = /*selected*/ ctx[0];
				add_flush_callback(() => updating_group = false);
			}

			checkbox.$set(checkbox_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(checkbox.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(checkbox.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(checkbox, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_6$2.name,
		type: "slot",
		source: "(15:8) <Cell checkbox>",
		ctx
	});

	return block;
}

// (22:8) <Cell>
function create_default_slot_5$2(ctx) {
	let t_value = /*option*/ ctx[4].name + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		l: function claim(nodes) {
			t = claim_text(nodes, t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_5$2.name,
		type: "slot",
		source: "(22:8) <Cell>",
		ctx
	});

	return block;
}

// (23:8) <Cell>
function create_default_slot_4$3(ctx) {
	let t_value = /*option*/ ctx[4].description + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		l: function claim(nodes) {
			t = claim_text(nodes, t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_4$3.name,
		type: "slot",
		source: "(23:8) <Cell>",
		ctx
	});

	return block;
}

// (24:8) <Cell numeric>
function create_default_slot_3$3(ctx) {
	let t_value = /*option*/ ctx[4].price + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		l: function claim(nodes) {
			t = claim_text(nodes, t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3$3.name,
		type: "slot",
		source: "(24:8) <Cell numeric>",
		ctx
	});

	return block;
}

// (14:6) <Row>
function create_default_slot_2$3(ctx) {
	let cell0;
	let t0;
	let cell1;
	let t1;
	let cell2;
	let t2;
	let cell3;
	let t3;
	let current;

	cell0 = new Cell({
			props: {
				checkbox: true,
				$$slots: { default: [create_default_slot_6$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	cell1 = new Cell({
			props: {
				$$slots: { default: [create_default_slot_5$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	cell2 = new Cell({
			props: {
				$$slots: { default: [create_default_slot_4$3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	cell3 = new Cell({
			props: {
				numeric: true,
				$$slots: { default: [create_default_slot_3$3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(cell0.$$.fragment);
			t0 = space();
			create_component(cell1.$$.fragment);
			t1 = space();
			create_component(cell2.$$.fragment);
			t2 = space();
			create_component(cell3.$$.fragment);
			t3 = space();
		},
		l: function claim(nodes) {
			claim_component(cell0.$$.fragment, nodes);
			t0 = claim_space(nodes);
			claim_component(cell1.$$.fragment, nodes);
			t1 = claim_space(nodes);
			claim_component(cell2.$$.fragment, nodes);
			t2 = claim_space(nodes);
			claim_component(cell3.$$.fragment, nodes);
			t3 = claim_space(nodes);
		},
		m: function mount(target, anchor) {
			mount_component(cell0, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(cell1, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(cell2, target, anchor);
			insert_dev(target, t2, anchor);
			mount_component(cell3, target, anchor);
			insert_dev(target, t3, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const cell0_changes = {};

			if (dirty & /*$$scope, selected*/ 129) {
				cell0_changes.$$scope = { dirty, ctx };
			}

			cell0.$set(cell0_changes);
			const cell1_changes = {};

			if (dirty & /*$$scope*/ 128) {
				cell1_changes.$$scope = { dirty, ctx };
			}

			cell1.$set(cell1_changes);
			const cell2_changes = {};

			if (dirty & /*$$scope*/ 128) {
				cell2_changes.$$scope = { dirty, ctx };
			}

			cell2.$set(cell2_changes);
			const cell3_changes = {};

			if (dirty & /*$$scope*/ 128) {
				cell3_changes.$$scope = { dirty, ctx };
			}

			cell3.$set(cell3_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(cell0.$$.fragment, local);
			transition_in(cell1.$$.fragment, local);
			transition_in(cell2.$$.fragment, local);
			transition_in(cell3.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(cell0.$$.fragment, local);
			transition_out(cell1.$$.fragment, local);
			transition_out(cell2.$$.fragment, local);
			transition_out(cell3.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(cell0, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(cell1, detaching);
			if (detaching) detach_dev(t1);
			destroy_component(cell2, detaching);
			if (detaching) detach_dev(t2);
			destroy_component(cell3, detaching);
			if (detaching) detach_dev(t3);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2$3.name,
		type: "slot",
		source: "(14:6) <Row>",
		ctx
	});

	return block;
}

// (13:4) {#each options as option (option.name)}
function create_each_block$2(key_1, ctx) {
	let first;
	let row;
	let current;

	row = new Row({
			props: {
				$$slots: { default: [create_default_slot_2$3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		key: key_1,
		first: null,
		c: function create() {
			first = empty();
			create_component(row.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			first = empty();
			claim_component(row.$$.fragment, nodes);
			this.h();
		},
		h: function hydrate() {
			this.first = first;
		},
		m: function mount(target, anchor) {
			insert_dev(target, first, anchor);
			mount_component(row, target, anchor);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			const row_changes = {};

			if (dirty & /*$$scope, selected*/ 129) {
				row_changes.$$scope = { dirty, ctx };
			}

			row.$set(row_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(row.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(row.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(first);
			destroy_component(row, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$2.name,
		type: "each",
		source: "(13:4) {#each options as option (option.name)}",
		ctx
	});

	return block;
}

// (12:2) <Body>
function create_default_slot_1$3(ctx) {
	let each_blocks = [];
	let each_1_lookup = new Map();
	let each_1_anchor;
	let current;
	let each_value = /*options*/ ctx[2];
	validate_each_argument(each_value);
	const get_key = ctx => /*option*/ ctx[4].name;
	validate_each_keys(ctx, each_value, get_each_context$2, get_key);

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context$2(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block$2(key, child_ctx));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (dirty & /*options, selected*/ 5) {
				each_value = /*options*/ ctx[2];
				validate_each_argument(each_value);
				group_outros();
				validate_each_keys(ctx, each_value, get_each_context$2, get_key);
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$2, each_1_anchor, get_each_context$2);
				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d(detaching);
			}

			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$3.name,
		type: "slot",
		source: "(12:2) <Body>",
		ctx
	});

	return block;
}

// (1:0) <DataTable style="max-width: 100%;">
function create_default_slot$3(ctx) {
	let head;
	let t;
	let body;
	let current;

	head = new Head({
			props: {
				$$slots: { default: [create_default_slot_7$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	body = new Body({
			props: {
				$$slots: { default: [create_default_slot_1$3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(head.$$.fragment);
			t = space();
			create_component(body.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(head.$$.fragment, nodes);
			t = claim_space(nodes);
			claim_component(body.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(head, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(body, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const head_changes = {};

			if (dirty & /*$$scope*/ 128) {
				head_changes.$$scope = { dirty, ctx };
			}

			head.$set(head_changes);
			const body_changes = {};

			if (dirty & /*$$scope, selected*/ 129) {
				body_changes.$$scope = { dirty, ctx };
			}

			body.$set(body_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(head.$$.fragment, local);
			transition_in(body.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(head.$$.fragment, local);
			transition_out(body.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(head, detaching);
			if (detaching) detach_dev(t);
			destroy_component(body, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$3.name,
		type: "slot",
		source: "(1:0) <DataTable style=\\\"max-width: 100%;\\\">",
		ctx
	});

	return block;
}

function create_fragment$3(ctx) {
	let datatable;
	let t0;
	let pre0;
	let t1;
	let t2_value = /*selected*/ ctx[0].map(func).join(", ") + "";
	let t2;
	let t3;
	let pre1;
	let t4;
	let t5;
	let current;

	datatable = new DataTable({
			props: {
				style: "max-width: 100%;",
				$$slots: { default: [create_default_slot$3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(datatable.$$.fragment);
			t0 = space();
			pre0 = element("pre");
			t1 = text("Selected: ");
			t2 = text(t2_value);
			t3 = space();
			pre1 = element("pre");
			t4 = text("Total: ");
			t5 = text(/*selectedPrice*/ ctx[1]);
			this.h();
		},
		l: function claim(nodes) {
			claim_component(datatable.$$.fragment, nodes);
			t0 = claim_space(nodes);
			pre0 = claim_element(nodes, "PRE", { class: true });
			var pre0_nodes = children(pre0);
			t1 = claim_text(pre0_nodes, "Selected: ");
			t2 = claim_text(pre0_nodes, t2_value);
			pre0_nodes.forEach(detach_dev);
			t3 = claim_space(nodes);
			pre1 = claim_element(nodes, "PRE", { class: true });
			var pre1_nodes = children(pre1);
			t4 = claim_text(pre1_nodes, "Total: ");
			t5 = claim_text(pre1_nodes, /*selectedPrice*/ ctx[1]);
			pre1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(pre0, "class", "status");
			add_location(pre0, file$1, 29, 0, 626);
			attr_dev(pre1, "class", "status");
			add_location(pre1, file$1, 31, 0, 713);
		},
		m: function mount(target, anchor) {
			mount_component(datatable, target, anchor);
			insert_dev(target, t0, anchor);
			insert_dev(target, pre0, anchor);
			append_dev(pre0, t1);
			append_dev(pre0, t2);
			insert_dev(target, t3, anchor);
			insert_dev(target, pre1, anchor);
			append_dev(pre1, t4);
			append_dev(pre1, t5);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const datatable_changes = {};

			if (dirty & /*$$scope, selected*/ 129) {
				datatable_changes.$$scope = { dirty, ctx };
			}

			datatable.$set(datatable_changes);
			if ((!current || dirty & /*selected*/ 1) && t2_value !== (t2_value = /*selected*/ ctx[0].map(func).join(", ") + "")) set_data_dev(t2, t2_value);
			if (!current || dirty & /*selectedPrice*/ 2) set_data_dev(t5, /*selectedPrice*/ ctx[1]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(datatable.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(datatable.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(datatable, detaching);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(pre0);
			if (detaching) detach_dev(t3);
			if (detaching) detach_dev(pre1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

const func = option => option.name;

function instance$3($$self, $$props, $$invalidate) {
	let selectedPrice;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("RowSelection", slots, []);

	let options = [
		{
			name: "Broom",
			description: "A wooden handled broom.",
			price: 15
		},
		{
			name: "Dust Pan",
			description: "A plastic dust pan.",
			price: 8
		},
		{
			name: "Mop",
			description: "A strong, durable mop.",
			price: 18
		},
		{
			name: "Horse",
			description: "She's got some miles on her.",
			price: 83
		},
		{
			name: "Bucket",
			description: "A metal bucket.",
			price: 13
		}
	];

	let selected = [options[2]];
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<RowSelection> was created with unknown prop '${key}'`);
	});

	function checkbox_group_binding(value) {
		selected = value;
		$$invalidate(0, selected);
	}

	$$self.$capture_state = () => ({
		DataTable,
		Head,
		Body,
		Row,
		Cell,
		Checkbox,
		options,
		selected,
		selectedPrice
	});

	$$self.$inject_state = $$props => {
		if ("options" in $$props) $$invalidate(2, options = $$props.options);
		if ("selected" in $$props) $$invalidate(0, selected = $$props.selected);
		if ("selectedPrice" in $$props) $$invalidate(1, selectedPrice = $$props.selectedPrice);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*selected*/ 1) {
			$$invalidate(1, selectedPrice = selected.reduce((total, option) => option.price + total, 0));
		}
	};

	return [selected, selectedPrice, options, checkbox_group_binding];
}

class RowSelection extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3, create_fragment$3, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "RowSelection",
			options,
			id: create_fragment$3.name
		});
	}
}

/* src/routes/demo/data-table/_Pagination.svelte generated by Svelte v3.37.0 */

function get_each_context$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[12] = list[i];
	return child_ctx;
}

// (4:6) <Cell numeric>
function create_default_slot_22$1(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("ID");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "ID");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_22$1.name,
		type: "slot",
		source: "(4:6) <Cell numeric>",
		ctx
	});

	return block;
}

// (5:6) <Cell style="width: 100%;">
function create_default_slot_21$1(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Title");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Title");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_21$1.name,
		type: "slot",
		source: "(5:6) <Cell style=\\\"width: 100%;\\\">",
		ctx
	});

	return block;
}

// (6:6) <Cell>
function create_default_slot_20$1(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Completed");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Completed");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_20$1.name,
		type: "slot",
		source: "(6:6) <Cell>",
		ctx
	});

	return block;
}

// (7:6) <Cell numeric>
function create_default_slot_19$1(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("User ID");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "User ID");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_19$1.name,
		type: "slot",
		source: "(7:6) <Cell numeric>",
		ctx
	});

	return block;
}

// (3:4) <Row>
function create_default_slot_18$1(ctx) {
	let cell0;
	let t0;
	let cell1;
	let t1;
	let cell2;
	let t2;
	let cell3;
	let current;

	cell0 = new Cell({
			props: {
				numeric: true,
				$$slots: { default: [create_default_slot_22$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	cell1 = new Cell({
			props: {
				style: "width: 100%;",
				$$slots: { default: [create_default_slot_21$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	cell2 = new Cell({
			props: {
				$$slots: { default: [create_default_slot_20$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	cell3 = new Cell({
			props: {
				numeric: true,
				$$slots: { default: [create_default_slot_19$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(cell0.$$.fragment);
			t0 = space();
			create_component(cell1.$$.fragment);
			t1 = space();
			create_component(cell2.$$.fragment);
			t2 = space();
			create_component(cell3.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(cell0.$$.fragment, nodes);
			t0 = claim_space(nodes);
			claim_component(cell1.$$.fragment, nodes);
			t1 = claim_space(nodes);
			claim_component(cell2.$$.fragment, nodes);
			t2 = claim_space(nodes);
			claim_component(cell3.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(cell0, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(cell1, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(cell2, target, anchor);
			insert_dev(target, t2, anchor);
			mount_component(cell3, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const cell0_changes = {};

			if (dirty & /*$$scope*/ 32768) {
				cell0_changes.$$scope = { dirty, ctx };
			}

			cell0.$set(cell0_changes);
			const cell1_changes = {};

			if (dirty & /*$$scope*/ 32768) {
				cell1_changes.$$scope = { dirty, ctx };
			}

			cell1.$set(cell1_changes);
			const cell2_changes = {};

			if (dirty & /*$$scope*/ 32768) {
				cell2_changes.$$scope = { dirty, ctx };
			}

			cell2.$set(cell2_changes);
			const cell3_changes = {};

			if (dirty & /*$$scope*/ 32768) {
				cell3_changes.$$scope = { dirty, ctx };
			}

			cell3.$set(cell3_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(cell0.$$.fragment, local);
			transition_in(cell1.$$.fragment, local);
			transition_in(cell2.$$.fragment, local);
			transition_in(cell3.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(cell0.$$.fragment, local);
			transition_out(cell1.$$.fragment, local);
			transition_out(cell2.$$.fragment, local);
			transition_out(cell3.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(cell0, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(cell1, detaching);
			if (detaching) detach_dev(t1);
			destroy_component(cell2, detaching);
			if (detaching) detach_dev(t2);
			destroy_component(cell3, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_18$1.name,
		type: "slot",
		source: "(3:4) <Row>",
		ctx
	});

	return block;
}

// (2:2) <Head>
function create_default_slot_17$1(ctx) {
	let row;
	let current;

	row = new Row({
			props: {
				$$slots: { default: [create_default_slot_18$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(row.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(row.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(row, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const row_changes = {};

			if (dirty & /*$$scope*/ 32768) {
				row_changes.$$scope = { dirty, ctx };
			}

			row.$set(row_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(row.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(row.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(row, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_17$1.name,
		type: "slot",
		source: "(2:2) <Head>",
		ctx
	});

	return block;
}

// (13:8) <Cell numeric>
function create_default_slot_16$1(ctx) {
	let t_value = /*item*/ ctx[12].id + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		l: function claim(nodes) {
			t = claim_text(nodes, t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*slice*/ 64 && t_value !== (t_value = /*item*/ ctx[12].id + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_16$1.name,
		type: "slot",
		source: "(13:8) <Cell numeric>",
		ctx
	});

	return block;
}

// (14:8) <Cell>
function create_default_slot_15$1(ctx) {
	let t_value = /*item*/ ctx[12].title + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		l: function claim(nodes) {
			t = claim_text(nodes, t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*slice*/ 64 && t_value !== (t_value = /*item*/ ctx[12].title + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_15$1.name,
		type: "slot",
		source: "(14:8) <Cell>",
		ctx
	});

	return block;
}

// (15:8) <Cell>
function create_default_slot_14$1(ctx) {
	let t_value = (/*item*/ ctx[12].completed ? "Yes" : "No") + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		l: function claim(nodes) {
			t = claim_text(nodes, t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*slice*/ 64 && t_value !== (t_value = (/*item*/ ctx[12].completed ? "Yes" : "No") + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_14$1.name,
		type: "slot",
		source: "(15:8) <Cell>",
		ctx
	});

	return block;
}

// (16:8) <Cell numeric>
function create_default_slot_13$1(ctx) {
	let t_value = /*item*/ ctx[12].userId + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		l: function claim(nodes) {
			t = claim_text(nodes, t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*slice*/ 64 && t_value !== (t_value = /*item*/ ctx[12].userId + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_13$1.name,
		type: "slot",
		source: "(16:8) <Cell numeric>",
		ctx
	});

	return block;
}

// (12:6) <Row>
function create_default_slot_12$1(ctx) {
	let cell0;
	let t0;
	let cell1;
	let t1;
	let cell2;
	let t2;
	let cell3;
	let t3;
	let current;

	cell0 = new Cell({
			props: {
				numeric: true,
				$$slots: { default: [create_default_slot_16$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	cell1 = new Cell({
			props: {
				$$slots: { default: [create_default_slot_15$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	cell2 = new Cell({
			props: {
				$$slots: { default: [create_default_slot_14$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	cell3 = new Cell({
			props: {
				numeric: true,
				$$slots: { default: [create_default_slot_13$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(cell0.$$.fragment);
			t0 = space();
			create_component(cell1.$$.fragment);
			t1 = space();
			create_component(cell2.$$.fragment);
			t2 = space();
			create_component(cell3.$$.fragment);
			t3 = space();
		},
		l: function claim(nodes) {
			claim_component(cell0.$$.fragment, nodes);
			t0 = claim_space(nodes);
			claim_component(cell1.$$.fragment, nodes);
			t1 = claim_space(nodes);
			claim_component(cell2.$$.fragment, nodes);
			t2 = claim_space(nodes);
			claim_component(cell3.$$.fragment, nodes);
			t3 = claim_space(nodes);
		},
		m: function mount(target, anchor) {
			mount_component(cell0, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(cell1, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(cell2, target, anchor);
			insert_dev(target, t2, anchor);
			mount_component(cell3, target, anchor);
			insert_dev(target, t3, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const cell0_changes = {};

			if (dirty & /*$$scope, slice*/ 32832) {
				cell0_changes.$$scope = { dirty, ctx };
			}

			cell0.$set(cell0_changes);
			const cell1_changes = {};

			if (dirty & /*$$scope, slice*/ 32832) {
				cell1_changes.$$scope = { dirty, ctx };
			}

			cell1.$set(cell1_changes);
			const cell2_changes = {};

			if (dirty & /*$$scope, slice*/ 32832) {
				cell2_changes.$$scope = { dirty, ctx };
			}

			cell2.$set(cell2_changes);
			const cell3_changes = {};

			if (dirty & /*$$scope, slice*/ 32832) {
				cell3_changes.$$scope = { dirty, ctx };
			}

			cell3.$set(cell3_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(cell0.$$.fragment, local);
			transition_in(cell1.$$.fragment, local);
			transition_in(cell2.$$.fragment, local);
			transition_in(cell3.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(cell0.$$.fragment, local);
			transition_out(cell1.$$.fragment, local);
			transition_out(cell2.$$.fragment, local);
			transition_out(cell3.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(cell0, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(cell1, detaching);
			if (detaching) detach_dev(t1);
			destroy_component(cell2, detaching);
			if (detaching) detach_dev(t2);
			destroy_component(cell3, detaching);
			if (detaching) detach_dev(t3);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_12$1.name,
		type: "slot",
		source: "(12:6) <Row>",
		ctx
	});

	return block;
}

// (11:4) {#each slice as item (item.id)}
function create_each_block$1(key_1, ctx) {
	let first;
	let row;
	let current;

	row = new Row({
			props: {
				$$slots: { default: [create_default_slot_12$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		key: key_1,
		first: null,
		c: function create() {
			first = empty();
			create_component(row.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			first = empty();
			claim_component(row.$$.fragment, nodes);
			this.h();
		},
		h: function hydrate() {
			this.first = first;
		},
		m: function mount(target, anchor) {
			insert_dev(target, first, anchor);
			mount_component(row, target, anchor);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			const row_changes = {};

			if (dirty & /*$$scope, slice*/ 32832) {
				row_changes.$$scope = { dirty, ctx };
			}

			row.$set(row_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(row.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(row.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(first);
			destroy_component(row, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$1.name,
		type: "each",
		source: "(11:4) {#each slice as item (item.id)}",
		ctx
	});

	return block;
}

// (10:2) <Body>
function create_default_slot_11$1(ctx) {
	let each_blocks = [];
	let each_1_lookup = new Map();
	let each_1_anchor;
	let current;
	let each_value = /*slice*/ ctx[6];
	validate_each_argument(each_value);
	const get_key = ctx => /*item*/ ctx[12].id;
	validate_each_keys(ctx, each_value, get_each_context$1, get_key);

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context$1(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block$1(key, child_ctx));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (dirty & /*slice*/ 64) {
				each_value = /*slice*/ ctx[6];
				validate_each_argument(each_value);
				group_outros();
				validate_each_keys(ctx, each_value, get_each_context$1, get_key);
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$1, each_1_anchor, get_each_context$1);
				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d(detaching);
			}

			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_11$1.name,
		type: "slot",
		source: "(10:2) <Body>",
		ctx
	});

	return block;
}

// (1:0) <DataTable table$aria-label="Todo list" style="width: 100%;">
function create_default_slot_10$1(ctx) {
	let head;
	let t;
	let body;
	let current;

	head = new Head({
			props: {
				$$slots: { default: [create_default_slot_17$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	body = new Body({
			props: {
				$$slots: { default: [create_default_slot_11$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(head.$$.fragment);
			t = space();
			create_component(body.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(head.$$.fragment, nodes);
			t = claim_space(nodes);
			claim_component(body.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(head, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(body, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const head_changes = {};

			if (dirty & /*$$scope*/ 32768) {
				head_changes.$$scope = { dirty, ctx };
			}

			head.$set(head_changes);
			const body_changes = {};

			if (dirty & /*$$scope, slice*/ 32832) {
				body_changes.$$scope = { dirty, ctx };
			}

			body.$set(body_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(head.$$.fragment, local);
			transition_in(body.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(head.$$.fragment, local);
			transition_out(body.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(head, detaching);
			if (detaching) detach_dev(t);
			destroy_component(body, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_10$1.name,
		type: "slot",
		source: "(1:0) <DataTable table$aria-label=\\\"Todo list\\\" style=\\\"width: 100%;\\\">",
		ctx
	});

	return block;
}

// (34:4) <IconButton       class="material-icons"       action="first-page"       title="First page"       on:click={() => (currentPage = 0)}       disabled={currentPage === 0}>
function create_default_slot_9$1(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("first_page");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "first_page");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_9$1.name,
		type: "slot",
		source: "(34:4) <IconButton       class=\\\"material-icons\\\"       action=\\\"first-page\\\"       title=\\\"First page\\\"       on:click={() => (currentPage = 0)}       disabled={currentPage === 0}>",
		ctx
	});

	return block;
}

// (41:4) <IconButton       class="material-icons"       action="prev-page"       title="Prev page"       on:click={() => currentPage--}       disabled={currentPage === 0}>
function create_default_slot_8$1(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("chevron_left");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "chevron_left");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_8$1.name,
		type: "slot",
		source: "(41:4) <IconButton       class=\\\"material-icons\\\"       action=\\\"prev-page\\\"       title=\\\"Prev page\\\"       on:click={() => currentPage--}       disabled={currentPage === 0}>",
		ctx
	});

	return block;
}

// (48:4) <IconButton       class="material-icons"       action="next-page"       title="Next page"       on:click={() => currentPage++}       disabled={currentPage === lastPage}>
function create_default_slot_7$1(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("chevron_right");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "chevron_right");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_7$1.name,
		type: "slot",
		source: "(48:4) <IconButton       class=\\\"material-icons\\\"       action=\\\"next-page\\\"       title=\\\"Next page\\\"       on:click={() => currentPage++}       disabled={currentPage === lastPage}>",
		ctx
	});

	return block;
}

// (55:4) <IconButton       class="material-icons"       action="last-page"       title="Last page"       on:click={() => (currentPage = lastPage)}       disabled={currentPage === lastPage}>
function create_default_slot_6$1(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("last_page");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "last_page");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_6$1.name,
		type: "slot",
		source: "(55:4) <IconButton       class=\\\"material-icons\\\"       action=\\\"last-page\\\"       title=\\\"Last page\\\"       on:click={() => (currentPage = lastPage)}       disabled={currentPage === lastPage}>",
		ctx
	});

	return block;
}

// (21:2) <Pagination slot="paginate">
function create_default_slot_5$1(ctx) {
	let iconbutton0;
	let t0;
	let iconbutton1;
	let t1;
	let iconbutton2;
	let t2;
	let iconbutton3;
	let current;

	iconbutton0 = new IconButton({
			props: {
				class: "material-icons",
				action: "first-page",
				title: "First page",
				disabled: /*currentPage*/ ctx[1] === 0,
				$$slots: { default: [create_default_slot_9$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	iconbutton0.$on("click", /*click_handler*/ ctx[8]);

	iconbutton1 = new IconButton({
			props: {
				class: "material-icons",
				action: "prev-page",
				title: "Prev page",
				disabled: /*currentPage*/ ctx[1] === 0,
				$$slots: { default: [create_default_slot_8$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	iconbutton1.$on("click", /*click_handler_1*/ ctx[9]);

	iconbutton2 = new IconButton({
			props: {
				class: "material-icons",
				action: "next-page",
				title: "Next page",
				disabled: /*currentPage*/ ctx[1] === /*lastPage*/ ctx[5],
				$$slots: { default: [create_default_slot_7$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	iconbutton2.$on("click", /*click_handler_2*/ ctx[10]);

	iconbutton3 = new IconButton({
			props: {
				class: "material-icons",
				action: "last-page",
				title: "Last page",
				disabled: /*currentPage*/ ctx[1] === /*lastPage*/ ctx[5],
				$$slots: { default: [create_default_slot_6$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	iconbutton3.$on("click", /*click_handler_3*/ ctx[11]);

	const block = {
		c: function create() {
			create_component(iconbutton0.$$.fragment);
			t0 = space();
			create_component(iconbutton1.$$.fragment);
			t1 = space();
			create_component(iconbutton2.$$.fragment);
			t2 = space();
			create_component(iconbutton3.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(iconbutton0.$$.fragment, nodes);
			t0 = claim_space(nodes);
			claim_component(iconbutton1.$$.fragment, nodes);
			t1 = claim_space(nodes);
			claim_component(iconbutton2.$$.fragment, nodes);
			t2 = claim_space(nodes);
			claim_component(iconbutton3.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(iconbutton0, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(iconbutton1, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(iconbutton2, target, anchor);
			insert_dev(target, t2, anchor);
			mount_component(iconbutton3, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const iconbutton0_changes = {};
			if (dirty & /*currentPage*/ 2) iconbutton0_changes.disabled = /*currentPage*/ ctx[1] === 0;

			if (dirty & /*$$scope*/ 32768) {
				iconbutton0_changes.$$scope = { dirty, ctx };
			}

			iconbutton0.$set(iconbutton0_changes);
			const iconbutton1_changes = {};
			if (dirty & /*currentPage*/ 2) iconbutton1_changes.disabled = /*currentPage*/ ctx[1] === 0;

			if (dirty & /*$$scope*/ 32768) {
				iconbutton1_changes.$$scope = { dirty, ctx };
			}

			iconbutton1.$set(iconbutton1_changes);
			const iconbutton2_changes = {};
			if (dirty & /*currentPage, lastPage*/ 34) iconbutton2_changes.disabled = /*currentPage*/ ctx[1] === /*lastPage*/ ctx[5];

			if (dirty & /*$$scope*/ 32768) {
				iconbutton2_changes.$$scope = { dirty, ctx };
			}

			iconbutton2.$set(iconbutton2_changes);
			const iconbutton3_changes = {};
			if (dirty & /*currentPage, lastPage*/ 34) iconbutton3_changes.disabled = /*currentPage*/ ctx[1] === /*lastPage*/ ctx[5];

			if (dirty & /*$$scope*/ 32768) {
				iconbutton3_changes.$$scope = { dirty, ctx };
			}

			iconbutton3.$set(iconbutton3_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(iconbutton0.$$.fragment, local);
			transition_in(iconbutton1.$$.fragment, local);
			transition_in(iconbutton2.$$.fragment, local);
			transition_in(iconbutton3.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(iconbutton0.$$.fragment, local);
			transition_out(iconbutton1.$$.fragment, local);
			transition_out(iconbutton2.$$.fragment, local);
			transition_out(iconbutton3.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(iconbutton0, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(iconbutton1, detaching);
			if (detaching) detach_dev(t1);
			destroy_component(iconbutton2, detaching);
			if (detaching) detach_dev(t2);
			destroy_component(iconbutton3, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_5$1.name,
		type: "slot",
		source: "(21:2) <Pagination slot=\\\"paginate\\\">",
		ctx
	});

	return block;
}

// (23:6) <Label>
function create_default_slot_4$2(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Rows Per Page");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Rows Per Page");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_4$2.name,
		type: "slot",
		source: "(23:6) <Label>",
		ctx
	});

	return block;
}

// (25:8) <Option value={10}>
function create_default_slot_3$2(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("10");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "10");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3$2.name,
		type: "slot",
		source: "(25:8) <Option value={10}>",
		ctx
	});

	return block;
}

// (26:8) <Option value={25}>
function create_default_slot_2$2(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("25");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "25");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2$2.name,
		type: "slot",
		source: "(26:8) <Option value={25}>",
		ctx
	});

	return block;
}

// (27:8) <Option value={100}>
function create_default_slot_1$2(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("100");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "100");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$2.name,
		type: "slot",
		source: "(27:8) <Option value={100}>",
		ctx
	});

	return block;
}

// (24:6) <Select variant="outlined" bind:value={rowsPerPage} noLabel>
function create_default_slot$2(ctx) {
	let option0;
	let t0;
	let option1;
	let t1;
	let option2;
	let current;

	option0 = new Option({
			props: {
				value: 10,
				$$slots: { default: [create_default_slot_3$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	option1 = new Option({
			props: {
				value: 25,
				$$slots: { default: [create_default_slot_2$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	option2 = new Option({
			props: {
				value: 100,
				$$slots: { default: [create_default_slot_1$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(option0.$$.fragment);
			t0 = space();
			create_component(option1.$$.fragment);
			t1 = space();
			create_component(option2.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(option0.$$.fragment, nodes);
			t0 = claim_space(nodes);
			claim_component(option1.$$.fragment, nodes);
			t1 = claim_space(nodes);
			claim_component(option2.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(option0, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(option1, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(option2, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const option0_changes = {};

			if (dirty & /*$$scope*/ 32768) {
				option0_changes.$$scope = { dirty, ctx };
			}

			option0.$set(option0_changes);
			const option1_changes = {};

			if (dirty & /*$$scope*/ 32768) {
				option1_changes.$$scope = { dirty, ctx };
			}

			option1.$set(option1_changes);
			const option2_changes = {};

			if (dirty & /*$$scope*/ 32768) {
				option2_changes.$$scope = { dirty, ctx };
			}

			option2.$set(option2_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(option0.$$.fragment, local);
			transition_in(option1.$$.fragment, local);
			transition_in(option2.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(option0.$$.fragment, local);
			transition_out(option1.$$.fragment, local);
			transition_out(option2.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(option0, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(option1, detaching);
			if (detaching) detach_dev(t1);
			destroy_component(option2, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$2.name,
		type: "slot",
		source: "(24:6) <Select variant=\\\"outlined\\\" bind:value={rowsPerPage} noLabel>",
		ctx
	});

	return block;
}

// (22:4) <svelte:fragment slot="rowsPerPage">
function create_rowsPerPage_slot(ctx) {
	let label;
	let t;
	let select;
	let updating_value;
	let current;

	label = new CommonLabel$1({
			props: {
				$$slots: { default: [create_default_slot_4$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	function select_value_binding(value) {
		/*select_value_binding*/ ctx[7](value);
	}

	let select_props = {
		variant: "outlined",
		noLabel: true,
		$$slots: { default: [create_default_slot$2] },
		$$scope: { ctx }
	};

	if (/*rowsPerPage*/ ctx[0] !== void 0) {
		select_props.value = /*rowsPerPage*/ ctx[0];
	}

	select = new Select({ props: select_props, $$inline: true });
	binding_callbacks.push(() => bind(select, "value", select_value_binding));

	const block = {
		c: function create() {
			create_component(label.$$.fragment);
			t = space();
			create_component(select.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(label.$$.fragment, nodes);
			t = claim_space(nodes);
			claim_component(select.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(label, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(select, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const label_changes = {};

			if (dirty & /*$$scope*/ 32768) {
				label_changes.$$scope = { dirty, ctx };
			}

			label.$set(label_changes);
			const select_changes = {};

			if (dirty & /*$$scope*/ 32768) {
				select_changes.$$scope = { dirty, ctx };
			}

			if (!updating_value && dirty & /*rowsPerPage*/ 1) {
				updating_value = true;
				select_changes.value = /*rowsPerPage*/ ctx[0];
				add_flush_callback(() => updating_value = false);
			}

			select.$set(select_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(label.$$.fragment, local);
			transition_in(select.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(label.$$.fragment, local);
			transition_out(select.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(label, detaching);
			if (detaching) detach_dev(t);
			destroy_component(select, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_rowsPerPage_slot.name,
		type: "slot",
		source: "(22:4) <svelte:fragment slot=\\\"rowsPerPage\\\">",
		ctx
	});

	return block;
}

// (30:4) <svelte:fragment slot="total">
function create_total_slot(ctx) {
	let t0_value = /*start*/ ctx[3] + 1 + "";
	let t0;
	let t1;
	let t2;
	let t3;
	let t4_value = /*items*/ ctx[2].length + "";
	let t4;

	const block = {
		c: function create() {
			t0 = text(t0_value);
			t1 = text("-");
			t2 = text(/*end*/ ctx[4]);
			t3 = text(" of ");
			t4 = text(t4_value);
		},
		l: function claim(nodes) {
			t0 = claim_text(nodes, t0_value);
			t1 = claim_text(nodes, "-");
			t2 = claim_text(nodes, /*end*/ ctx[4]);
			t3 = claim_text(nodes, " of ");
			t4 = claim_text(nodes, t4_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			insert_dev(target, t1, anchor);
			insert_dev(target, t2, anchor);
			insert_dev(target, t3, anchor);
			insert_dev(target, t4, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*start*/ 8 && t0_value !== (t0_value = /*start*/ ctx[3] + 1 + "")) set_data_dev(t0, t0_value);
			if (dirty & /*end*/ 16) set_data_dev(t2, /*end*/ ctx[4]);
			if (dirty & /*items*/ 4 && t4_value !== (t4_value = /*items*/ ctx[2].length + "")) set_data_dev(t4, t4_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(t2);
			if (detaching) detach_dev(t3);
			if (detaching) detach_dev(t4);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_total_slot.name,
		type: "slot",
		source: "(30:4) <svelte:fragment slot=\\\"total\\\">",
		ctx
	});

	return block;
}

// (21:2) 
function create_paginate_slot(ctx) {
	let pagination;
	let current;

	pagination = new Pagination({
			props: {
				slot: "paginate",
				$$slots: {
					total: [create_total_slot],
					rowsPerPage: [create_rowsPerPage_slot],
					default: [create_default_slot_5$1]
				},
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(pagination.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(pagination.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(pagination, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const pagination_changes = {};

			if (dirty & /*$$scope, items, end, start, rowsPerPage, currentPage, lastPage*/ 32831) {
				pagination_changes.$$scope = { dirty, ctx };
			}

			pagination.$set(pagination_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(pagination.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(pagination.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(pagination, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_paginate_slot.name,
		type: "slot",
		source: "(21:2) ",
		ctx
	});

	return block;
}

function create_fragment$2(ctx) {
	let datatable;
	let current;

	datatable = new DataTable({
			props: {
				"table$aria-label": "Todo list",
				style: "width: 100%;",
				$$slots: {
					paginate: [create_paginate_slot],
					default: [create_default_slot_10$1]
				},
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(datatable.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(datatable.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(datatable, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const datatable_changes = {};

			if (dirty & /*$$scope, items, end, start, rowsPerPage, currentPage, lastPage, slice*/ 32895) {
				datatable_changes.$$scope = { dirty, ctx };
			}

			datatable.$set(datatable_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(datatable.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(datatable.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(datatable, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2($$self, $$props, $$invalidate) {
	let start;
	let end;
	let slice;
	let lastPage;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Pagination", slots, []);
	let rowsPerPage = 10;
	let currentPage = 0;
	let items = [];

	if (typeof fetch !== "undefined") {
		// Slice a few off the end to show how the
		// last page looks when it's not full.
		fetch("https://gist.githubusercontent.com/hperrin/e24a4ebd9afdf2a8c283338ae5160a62/raw/dcbf8e6382db49b0dcab70b22f56b1cc444f26d4/todos.json").then(response => response.json()).then(json => $$invalidate(2, items = json.slice(0, 197)));
	}

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Pagination> was created with unknown prop '${key}'`);
	});

	function select_value_binding(value) {
		rowsPerPage = value;
		$$invalidate(0, rowsPerPage);
	}

	const click_handler = () => $$invalidate(1, currentPage = 0);
	const click_handler_1 = () => $$invalidate(1, currentPage--, currentPage);
	const click_handler_2 = () => $$invalidate(1, currentPage++, currentPage);
	const click_handler_3 = () => $$invalidate(1, currentPage = lastPage);

	$$self.$capture_state = () => ({
		DataTable,
		Head,
		Body,
		Row,
		Cell,
		Pagination,
		Select,
		Option,
		IconButton,
		Label: CommonLabel$1,
		rowsPerPage,
		currentPage,
		items,
		start,
		end,
		slice,
		lastPage
	});

	$$self.$inject_state = $$props => {
		if ("rowsPerPage" in $$props) $$invalidate(0, rowsPerPage = $$props.rowsPerPage);
		if ("currentPage" in $$props) $$invalidate(1, currentPage = $$props.currentPage);
		if ("items" in $$props) $$invalidate(2, items = $$props.items);
		if ("start" in $$props) $$invalidate(3, start = $$props.start);
		if ("end" in $$props) $$invalidate(4, end = $$props.end);
		if ("slice" in $$props) $$invalidate(6, slice = $$props.slice);
		if ("lastPage" in $$props) $$invalidate(5, lastPage = $$props.lastPage);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*items, rowsPerPage*/ 5) {
			$$invalidate(5, lastPage = Math.max(Math.ceil(items.length / rowsPerPage) - 1, 0));
		}

		if ($$self.$$.dirty & /*currentPage, lastPage*/ 34) {
			if (currentPage > lastPage) {
				$$invalidate(1, currentPage = lastPage);
			}
		}

		if ($$self.$$.dirty & /*currentPage, rowsPerPage*/ 3) {
			$$invalidate(3, start = currentPage * rowsPerPage);
		}

		if ($$self.$$.dirty & /*start, rowsPerPage, items*/ 13) {
			$$invalidate(4, end = Math.min(start + rowsPerPage, items.length));
		}

		if ($$self.$$.dirty & /*items, start, end*/ 28) {
			$$invalidate(6, slice = items.slice(start, end));
		}
	};

	return [
		rowsPerPage,
		currentPage,
		items,
		start,
		end,
		lastPage,
		slice,
		select_value_binding,
		click_handler,
		click_handler_1,
		click_handler_2,
		click_handler_3
	];
}

class Pagination_1 extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2, create_fragment$2, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Pagination_1",
			options,
			id: create_fragment$2.name
		});
	}
}

/* src/routes/demo/data-table/_Sortable.svelte generated by Svelte v3.37.0 */

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[6] = list[i];
	return child_ctx;
}

// (23:8) <IconButton class="material-icons">
function create_default_slot_22(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("arrow_upward");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "arrow_upward");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_22.name,
		type: "slot",
		source: "(23:8) <IconButton class=\\\"material-icons\\\">",
		ctx
	});

	return block;
}

// (24:8) <Label>
function create_default_slot_21(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("ID");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "ID");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_21.name,
		type: "slot",
		source: "(24:8) <Label>",
		ctx
	});

	return block;
}

// (21:6) <Cell numeric columnId="id">
function create_default_slot_20(ctx) {
	let iconbutton;
	let t;
	let label;
	let current;

	iconbutton = new IconButton({
			props: {
				class: "material-icons",
				$$slots: { default: [create_default_slot_22] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	label = new CommonLabel({
			props: {
				$$slots: { default: [create_default_slot_21] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(iconbutton.$$.fragment);
			t = space();
			create_component(label.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(iconbutton.$$.fragment, nodes);
			t = claim_space(nodes);
			claim_component(label.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(iconbutton, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(label, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const iconbutton_changes = {};

			if (dirty & /*$$scope*/ 512) {
				iconbutton_changes.$$scope = { dirty, ctx };
			}

			iconbutton.$set(iconbutton_changes);
			const label_changes = {};

			if (dirty & /*$$scope*/ 512) {
				label_changes.$$scope = { dirty, ctx };
			}

			label.$set(label_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(iconbutton.$$.fragment, local);
			transition_in(label.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(iconbutton.$$.fragment, local);
			transition_out(label.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(iconbutton, detaching);
			if (detaching) detach_dev(t);
			destroy_component(label, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_20.name,
		type: "slot",
		source: "(21:6) <Cell numeric columnId=\\\"id\\\">",
		ctx
	});

	return block;
}

// (27:8) <Label>
function create_default_slot_19(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Name");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Name");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_19.name,
		type: "slot",
		source: "(27:8) <Label>",
		ctx
	});

	return block;
}

// (29:8) <IconButton class="material-icons">
function create_default_slot_18(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("arrow_upward");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "arrow_upward");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_18.name,
		type: "slot",
		source: "(29:8) <IconButton class=\\\"material-icons\\\">",
		ctx
	});

	return block;
}

// (26:6) <Cell columnId="name" style="width: 100%;">
function create_default_slot_17(ctx) {
	let label;
	let t;
	let iconbutton;
	let current;

	label = new CommonLabel({
			props: {
				$$slots: { default: [create_default_slot_19] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	iconbutton = new IconButton({
			props: {
				class: "material-icons",
				$$slots: { default: [create_default_slot_18] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(label.$$.fragment);
			t = space();
			create_component(iconbutton.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(label.$$.fragment, nodes);
			t = claim_space(nodes);
			claim_component(iconbutton.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(label, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(iconbutton, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const label_changes = {};

			if (dirty & /*$$scope*/ 512) {
				label_changes.$$scope = { dirty, ctx };
			}

			label.$set(label_changes);
			const iconbutton_changes = {};

			if (dirty & /*$$scope*/ 512) {
				iconbutton_changes.$$scope = { dirty, ctx };
			}

			iconbutton.$set(iconbutton_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(label.$$.fragment, local);
			transition_in(iconbutton.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(label.$$.fragment, local);
			transition_out(iconbutton.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(label, detaching);
			if (detaching) detach_dev(t);
			destroy_component(iconbutton, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_17.name,
		type: "slot",
		source: "(26:6) <Cell columnId=\\\"name\\\" style=\\\"width: 100%;\\\">",
		ctx
	});

	return block;
}

// (32:8) <Label>
function create_default_slot_16(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Username");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Username");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_16.name,
		type: "slot",
		source: "(32:8) <Label>",
		ctx
	});

	return block;
}

// (33:8) <IconButton class="material-icons">
function create_default_slot_15(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("arrow_upward");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "arrow_upward");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_15.name,
		type: "slot",
		source: "(33:8) <IconButton class=\\\"material-icons\\\">",
		ctx
	});

	return block;
}

// (31:6) <Cell columnId="username">
function create_default_slot_14(ctx) {
	let label;
	let t;
	let iconbutton;
	let current;

	label = new CommonLabel({
			props: {
				$$slots: { default: [create_default_slot_16] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	iconbutton = new IconButton({
			props: {
				class: "material-icons",
				$$slots: { default: [create_default_slot_15] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(label.$$.fragment);
			t = space();
			create_component(iconbutton.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(label.$$.fragment, nodes);
			t = claim_space(nodes);
			claim_component(iconbutton.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(label, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(iconbutton, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const label_changes = {};

			if (dirty & /*$$scope*/ 512) {
				label_changes.$$scope = { dirty, ctx };
			}

			label.$set(label_changes);
			const iconbutton_changes = {};

			if (dirty & /*$$scope*/ 512) {
				iconbutton_changes.$$scope = { dirty, ctx };
			}

			iconbutton.$set(iconbutton_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(label.$$.fragment, local);
			transition_in(iconbutton.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(label.$$.fragment, local);
			transition_out(iconbutton.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(label, detaching);
			if (detaching) detach_dev(t);
			destroy_component(iconbutton, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_14.name,
		type: "slot",
		source: "(31:6) <Cell columnId=\\\"username\\\">",
		ctx
	});

	return block;
}

// (36:8) <Label>
function create_default_slot_13(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Email");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Email");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_13.name,
		type: "slot",
		source: "(36:8) <Label>",
		ctx
	});

	return block;
}

// (37:8) <IconButton class="material-icons">
function create_default_slot_12(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("arrow_upward");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "arrow_upward");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_12.name,
		type: "slot",
		source: "(37:8) <IconButton class=\\\"material-icons\\\">",
		ctx
	});

	return block;
}

// (35:6) <Cell columnId="email" l>
function create_default_slot_11(ctx) {
	let label;
	let t;
	let iconbutton;
	let current;

	label = new CommonLabel({
			props: {
				$$slots: { default: [create_default_slot_13] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	iconbutton = new IconButton({
			props: {
				class: "material-icons",
				$$slots: { default: [create_default_slot_12] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(label.$$.fragment);
			t = space();
			create_component(iconbutton.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(label.$$.fragment, nodes);
			t = claim_space(nodes);
			claim_component(iconbutton.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(label, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(iconbutton, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const label_changes = {};

			if (dirty & /*$$scope*/ 512) {
				label_changes.$$scope = { dirty, ctx };
			}

			label.$set(label_changes);
			const iconbutton_changes = {};

			if (dirty & /*$$scope*/ 512) {
				iconbutton_changes.$$scope = { dirty, ctx };
			}

			iconbutton.$set(iconbutton_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(label.$$.fragment, local);
			transition_in(iconbutton.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(label.$$.fragment, local);
			transition_out(iconbutton.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(label, detaching);
			if (detaching) detach_dev(t);
			destroy_component(iconbutton, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_11.name,
		type: "slot",
		source: "(35:6) <Cell columnId=\\\"email\\\" l>",
		ctx
	});

	return block;
}

// (40:6) <Cell sortable={false}>
function create_default_slot_10(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Website");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Website");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_10.name,
		type: "slot",
		source: "(40:6) <Cell sortable={false}>",
		ctx
	});

	return block;
}

// (10:4) <Row>
function create_default_slot_9(ctx) {
	let cell0;
	let t0;
	let cell1;
	let t1;
	let cell2;
	let t2;
	let cell3;
	let t3;
	let cell4;
	let current;

	cell0 = new Cell({
			props: {
				numeric: true,
				columnId: "id",
				$$slots: { default: [create_default_slot_20] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	cell1 = new Cell({
			props: {
				columnId: "name",
				style: "width: 100%;",
				$$slots: { default: [create_default_slot_17] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	cell2 = new Cell({
			props: {
				columnId: "username",
				$$slots: { default: [create_default_slot_14] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	cell3 = new Cell({
			props: {
				columnId: "email",
				l: true,
				$$slots: { default: [create_default_slot_11] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	cell4 = new Cell({
			props: {
				sortable: false,
				$$slots: { default: [create_default_slot_10] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(cell0.$$.fragment);
			t0 = space();
			create_component(cell1.$$.fragment);
			t1 = space();
			create_component(cell2.$$.fragment);
			t2 = space();
			create_component(cell3.$$.fragment);
			t3 = space();
			create_component(cell4.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(cell0.$$.fragment, nodes);
			t0 = claim_space(nodes);
			claim_component(cell1.$$.fragment, nodes);
			t1 = claim_space(nodes);
			claim_component(cell2.$$.fragment, nodes);
			t2 = claim_space(nodes);
			claim_component(cell3.$$.fragment, nodes);
			t3 = claim_space(nodes);
			claim_component(cell4.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(cell0, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(cell1, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(cell2, target, anchor);
			insert_dev(target, t2, anchor);
			mount_component(cell3, target, anchor);
			insert_dev(target, t3, anchor);
			mount_component(cell4, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const cell0_changes = {};

			if (dirty & /*$$scope*/ 512) {
				cell0_changes.$$scope = { dirty, ctx };
			}

			cell0.$set(cell0_changes);
			const cell1_changes = {};

			if (dirty & /*$$scope*/ 512) {
				cell1_changes.$$scope = { dirty, ctx };
			}

			cell1.$set(cell1_changes);
			const cell2_changes = {};

			if (dirty & /*$$scope*/ 512) {
				cell2_changes.$$scope = { dirty, ctx };
			}

			cell2.$set(cell2_changes);
			const cell3_changes = {};

			if (dirty & /*$$scope*/ 512) {
				cell3_changes.$$scope = { dirty, ctx };
			}

			cell3.$set(cell3_changes);
			const cell4_changes = {};

			if (dirty & /*$$scope*/ 512) {
				cell4_changes.$$scope = { dirty, ctx };
			}

			cell4.$set(cell4_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(cell0.$$.fragment, local);
			transition_in(cell1.$$.fragment, local);
			transition_in(cell2.$$.fragment, local);
			transition_in(cell3.$$.fragment, local);
			transition_in(cell4.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(cell0.$$.fragment, local);
			transition_out(cell1.$$.fragment, local);
			transition_out(cell2.$$.fragment, local);
			transition_out(cell3.$$.fragment, local);
			transition_out(cell4.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(cell0, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(cell1, detaching);
			if (detaching) detach_dev(t1);
			destroy_component(cell2, detaching);
			if (detaching) detach_dev(t2);
			destroy_component(cell3, detaching);
			if (detaching) detach_dev(t3);
			destroy_component(cell4, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_9.name,
		type: "slot",
		source: "(10:4) <Row>",
		ctx
	});

	return block;
}

// (9:2) <Head>
function create_default_slot_8(ctx) {
	let row;
	let current;

	row = new Row({
			props: {
				$$slots: { default: [create_default_slot_9] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(row.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(row.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(row, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const row_changes = {};

			if (dirty & /*$$scope*/ 512) {
				row_changes.$$scope = { dirty, ctx };
			}

			row.$set(row_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(row.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(row.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(row, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_8.name,
		type: "slot",
		source: "(9:2) <Head>",
		ctx
	});

	return block;
}

// (46:8) <Cell numeric>
function create_default_slot_7(ctx) {
	let t_value = /*item*/ ctx[6].id + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		l: function claim(nodes) {
			t = claim_text(nodes, t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*items*/ 1 && t_value !== (t_value = /*item*/ ctx[6].id + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_7.name,
		type: "slot",
		source: "(46:8) <Cell numeric>",
		ctx
	});

	return block;
}

// (47:8) <Cell>
function create_default_slot_6(ctx) {
	let t_value = /*item*/ ctx[6].name + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		l: function claim(nodes) {
			t = claim_text(nodes, t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*items*/ 1 && t_value !== (t_value = /*item*/ ctx[6].name + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_6.name,
		type: "slot",
		source: "(47:8) <Cell>",
		ctx
	});

	return block;
}

// (48:8) <Cell>
function create_default_slot_5(ctx) {
	let t_value = /*item*/ ctx[6].username + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		l: function claim(nodes) {
			t = claim_text(nodes, t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*items*/ 1 && t_value !== (t_value = /*item*/ ctx[6].username + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_5.name,
		type: "slot",
		source: "(48:8) <Cell>",
		ctx
	});

	return block;
}

// (49:8) <Cell>
function create_default_slot_4$1(ctx) {
	let t_value = /*item*/ ctx[6].email + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		l: function claim(nodes) {
			t = claim_text(nodes, t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*items*/ 1 && t_value !== (t_value = /*item*/ ctx[6].email + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_4$1.name,
		type: "slot",
		source: "(49:8) <Cell>",
		ctx
	});

	return block;
}

// (50:8) <Cell>
function create_default_slot_3$1(ctx) {
	let t_value = /*item*/ ctx[6].website + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		l: function claim(nodes) {
			t = claim_text(nodes, t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*items*/ 1 && t_value !== (t_value = /*item*/ ctx[6].website + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3$1.name,
		type: "slot",
		source: "(50:8) <Cell>",
		ctx
	});

	return block;
}

// (45:6) <Row>
function create_default_slot_2$1(ctx) {
	let cell0;
	let t0;
	let cell1;
	let t1;
	let cell2;
	let t2;
	let cell3;
	let t3;
	let cell4;
	let t4;
	let current;

	cell0 = new Cell({
			props: {
				numeric: true,
				$$slots: { default: [create_default_slot_7] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	cell1 = new Cell({
			props: {
				$$slots: { default: [create_default_slot_6] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	cell2 = new Cell({
			props: {
				$$slots: { default: [create_default_slot_5] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	cell3 = new Cell({
			props: {
				$$slots: { default: [create_default_slot_4$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	cell4 = new Cell({
			props: {
				$$slots: { default: [create_default_slot_3$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(cell0.$$.fragment);
			t0 = space();
			create_component(cell1.$$.fragment);
			t1 = space();
			create_component(cell2.$$.fragment);
			t2 = space();
			create_component(cell3.$$.fragment);
			t3 = space();
			create_component(cell4.$$.fragment);
			t4 = space();
		},
		l: function claim(nodes) {
			claim_component(cell0.$$.fragment, nodes);
			t0 = claim_space(nodes);
			claim_component(cell1.$$.fragment, nodes);
			t1 = claim_space(nodes);
			claim_component(cell2.$$.fragment, nodes);
			t2 = claim_space(nodes);
			claim_component(cell3.$$.fragment, nodes);
			t3 = claim_space(nodes);
			claim_component(cell4.$$.fragment, nodes);
			t4 = claim_space(nodes);
		},
		m: function mount(target, anchor) {
			mount_component(cell0, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(cell1, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(cell2, target, anchor);
			insert_dev(target, t2, anchor);
			mount_component(cell3, target, anchor);
			insert_dev(target, t3, anchor);
			mount_component(cell4, target, anchor);
			insert_dev(target, t4, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const cell0_changes = {};

			if (dirty & /*$$scope, items*/ 513) {
				cell0_changes.$$scope = { dirty, ctx };
			}

			cell0.$set(cell0_changes);
			const cell1_changes = {};

			if (dirty & /*$$scope, items*/ 513) {
				cell1_changes.$$scope = { dirty, ctx };
			}

			cell1.$set(cell1_changes);
			const cell2_changes = {};

			if (dirty & /*$$scope, items*/ 513) {
				cell2_changes.$$scope = { dirty, ctx };
			}

			cell2.$set(cell2_changes);
			const cell3_changes = {};

			if (dirty & /*$$scope, items*/ 513) {
				cell3_changes.$$scope = { dirty, ctx };
			}

			cell3.$set(cell3_changes);
			const cell4_changes = {};

			if (dirty & /*$$scope, items*/ 513) {
				cell4_changes.$$scope = { dirty, ctx };
			}

			cell4.$set(cell4_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(cell0.$$.fragment, local);
			transition_in(cell1.$$.fragment, local);
			transition_in(cell2.$$.fragment, local);
			transition_in(cell3.$$.fragment, local);
			transition_in(cell4.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(cell0.$$.fragment, local);
			transition_out(cell1.$$.fragment, local);
			transition_out(cell2.$$.fragment, local);
			transition_out(cell3.$$.fragment, local);
			transition_out(cell4.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(cell0, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(cell1, detaching);
			if (detaching) detach_dev(t1);
			destroy_component(cell2, detaching);
			if (detaching) detach_dev(t2);
			destroy_component(cell3, detaching);
			if (detaching) detach_dev(t3);
			destroy_component(cell4, detaching);
			if (detaching) detach_dev(t4);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2$1.name,
		type: "slot",
		source: "(45:6) <Row>",
		ctx
	});

	return block;
}

// (44:4) {#each items as item (item.id)}
function create_each_block(key_1, ctx) {
	let first;
	let row;
	let current;

	row = new Row({
			props: {
				$$slots: { default: [create_default_slot_2$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		key: key_1,
		first: null,
		c: function create() {
			first = empty();
			create_component(row.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			first = empty();
			claim_component(row.$$.fragment, nodes);
			this.h();
		},
		h: function hydrate() {
			this.first = first;
		},
		m: function mount(target, anchor) {
			insert_dev(target, first, anchor);
			mount_component(row, target, anchor);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			const row_changes = {};

			if (dirty & /*$$scope, items*/ 513) {
				row_changes.$$scope = { dirty, ctx };
			}

			row.$set(row_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(row.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(row.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(first);
			destroy_component(row, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(44:4) {#each items as item (item.id)}",
		ctx
	});

	return block;
}

// (43:2) <Body>
function create_default_slot_1$1(ctx) {
	let each_blocks = [];
	let each_1_lookup = new Map();
	let each_1_anchor;
	let current;
	let each_value = /*items*/ ctx[0];
	validate_each_argument(each_value);
	const get_key = ctx => /*item*/ ctx[6].id;
	validate_each_keys(ctx, each_value, get_each_context, get_key);

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (dirty & /*items*/ 1) {
				each_value = /*items*/ ctx[0];
				validate_each_argument(each_value);
				group_outros();
				validate_each_keys(ctx, each_value, get_each_context, get_key);
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block, each_1_anchor, get_each_context);
				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d(detaching);
			}

			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$1.name,
		type: "slot",
		source: "(43:2) <Body>",
		ctx
	});

	return block;
}

// (1:0) <DataTable   sortable   bind:sort   bind:sortDirection   on:MDCDataTable:sorted={handleSort}   table$aria-label="User list"   style="width: 100%;" >
function create_default_slot$1(ctx) {
	let head;
	let t;
	let body;
	let current;

	head = new Head({
			props: {
				$$slots: { default: [create_default_slot_8] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	body = new Body({
			props: {
				$$slots: { default: [create_default_slot_1$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(head.$$.fragment);
			t = space();
			create_component(body.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(head.$$.fragment, nodes);
			t = claim_space(nodes);
			claim_component(body.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(head, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(body, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const head_changes = {};

			if (dirty & /*$$scope*/ 512) {
				head_changes.$$scope = { dirty, ctx };
			}

			head.$set(head_changes);
			const body_changes = {};

			if (dirty & /*$$scope, items*/ 513) {
				body_changes.$$scope = { dirty, ctx };
			}

			body.$set(body_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(head.$$.fragment, local);
			transition_in(body.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(head.$$.fragment, local);
			transition_out(body.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(head, detaching);
			if (detaching) detach_dev(t);
			destroy_component(body, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$1.name,
		type: "slot",
		source: "(1:0) <DataTable   sortable   bind:sort   bind:sortDirection   on:MDCDataTable:sorted={handleSort}   table$aria-label=\\\"User list\\\"   style=\\\"width: 100%;\\\" >",
		ctx
	});

	return block;
}

function create_fragment$1(ctx) {
	let datatable;
	let updating_sort;
	let updating_sortDirection;
	let current;

	function datatable_sort_binding(value) {
		/*datatable_sort_binding*/ ctx[4](value);
	}

	function datatable_sortDirection_binding(value) {
		/*datatable_sortDirection_binding*/ ctx[5](value);
	}

	let datatable_props = {
		sortable: true,
		"table$aria-label": "User list",
		style: "width: 100%;",
		$$slots: { default: [create_default_slot$1] },
		$$scope: { ctx }
	};

	if (/*sort*/ ctx[1] !== void 0) {
		datatable_props.sort = /*sort*/ ctx[1];
	}

	if (/*sortDirection*/ ctx[2] !== void 0) {
		datatable_props.sortDirection = /*sortDirection*/ ctx[2];
	}

	datatable = new DataTable({ props: datatable_props, $$inline: true });
	binding_callbacks.push(() => bind(datatable, "sort", datatable_sort_binding));
	binding_callbacks.push(() => bind(datatable, "sortDirection", datatable_sortDirection_binding));
	datatable.$on("MDCDataTable:sorted", /*handleSort*/ ctx[3]);

	const block = {
		c: function create() {
			create_component(datatable.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(datatable.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(datatable, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const datatable_changes = {};

			if (dirty & /*$$scope, items*/ 513) {
				datatable_changes.$$scope = { dirty, ctx };
			}

			if (!updating_sort && dirty & /*sort*/ 2) {
				updating_sort = true;
				datatable_changes.sort = /*sort*/ ctx[1];
				add_flush_callback(() => updating_sort = false);
			}

			if (!updating_sortDirection && dirty & /*sortDirection*/ 4) {
				updating_sortDirection = true;
				datatable_changes.sortDirection = /*sortDirection*/ ctx[2];
				add_flush_callback(() => updating_sortDirection = false);
			}

			datatable.$set(datatable_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(datatable.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(datatable.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(datatable, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Sortable", slots, []);
	let items = [];
	let sort = "id";
	let sortDirection = "ascending";

	if (typeof fetch !== "undefined") {
		fetch("https://gist.githubusercontent.com/hperrin/e24a4ebd9afdf2a8c283338ae5160a62/raw/dcbf8e6382db49b0dcab70b22f56b1cc444f26d4/users.json").then(response => response.json()).then(json => $$invalidate(0, items = json));
	}

	function handleSort() {
		items.sort((a, b) => {
			const [aVal, bVal] = [a[sort], b[sort]][sortDirection === "ascending" ? "slice" : "reverse"]();

			if (typeof aVal === "string") {
				return aVal.localeCompare(bVal);
			}

			return aVal - bVal;
		});

		$$invalidate(0, items);
	}

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Sortable> was created with unknown prop '${key}'`);
	});

	function datatable_sort_binding(value) {
		sort = value;
		$$invalidate(1, sort);
	}

	function datatable_sortDirection_binding(value) {
		sortDirection = value;
		$$invalidate(2, sortDirection);
	}

	$$self.$capture_state = () => ({
		DataTable,
		Head,
		Body,
		Row,
		Cell,
		Label: CommonLabel,
		IconButton,
		items,
		sort,
		sortDirection,
		handleSort
	});

	$$self.$inject_state = $$props => {
		if ("items" in $$props) $$invalidate(0, items = $$props.items);
		if ("sort" in $$props) $$invalidate(1, sort = $$props.sort);
		if ("sortDirection" in $$props) $$invalidate(2, sortDirection = $$props.sortDirection);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		items,
		sort,
		sortDirection,
		handleSort,
		datatable_sort_binding,
		datatable_sortDirection_binding
	];
}

class Sortable extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$1, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Sortable",
			options,
			id: create_fragment$1.name
		});
	}
}

/* src/routes/demo/data-table/index.svelte generated by Svelte v3.37.0 */
const file = "src/routes/demo/data-table/index.svelte";

// (12:2) <Demo     component={ProgressIndicator}     file="data-table/_ProgressIndicator.svelte"   >
function create_default_slot_4(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Progress indicator");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Progress indicator");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_4.name,
		type: "slot",
		source: "(12:2) <Demo     component={ProgressIndicator}     file=\\\"data-table/_ProgressIndicator.svelte\\\"   >",
		ctx
	});

	return block;
}

// (19:2) <Demo component={StickyHeader} file="data-table/iframe.svelte">
function create_default_slot_3(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Sticky header");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Sticky header");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3.name,
		type: "slot",
		source: "(19:2) <Demo component={StickyHeader} file=\\\"data-table/iframe.svelte\\\">",
		ctx
	});

	return block;
}

// (21:4) <svelte:fragment slot="subtitle">
function create_subtitle_slot(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("This is displayed in an iframe and the source viewer shows the iframe\n      source. Sticky headers don't work if any ancestor element has the\n      \"overflow\" style set to \"hidden\", \"scroll\", or \"auto\".");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "This is displayed in an iframe and the source viewer shows the iframe\n      source. Sticky headers don't work if any ancestor element has the\n      \"overflow\" style set to \"hidden\", \"scroll\", or \"auto\".");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_subtitle_slot.name,
		type: "slot",
		source: "(21:4) <svelte:fragment slot=\\\"subtitle\\\">",
		ctx
	});

	return block;
}

// (28:2) <Demo component={RowSelection} file="data-table/_RowSelection.svelte">
function create_default_slot_2(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Row selection");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Row selection");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2.name,
		type: "slot",
		source: "(28:2) <Demo component={RowSelection} file=\\\"data-table/_RowSelection.svelte\\\">",
		ctx
	});

	return block;
}

// (32:2) <Demo component={Pagination} file="data-table/_Pagination.svelte">
function create_default_slot_1(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Pagination");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Pagination");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1.name,
		type: "slot",
		source: "(32:2) <Demo component={Pagination} file=\\\"data-table/_Pagination.svelte\\\">",
		ctx
	});

	return block;
}

// (36:2) <Demo component={Sortable} file="data-table/_Sortable.svelte">
function create_default_slot(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Sortable");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Sortable");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(36:2) <Demo component={Sortable} file=\\\"data-table/_Sortable.svelte\\\">",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let t0;
	let section;
	let h2;
	let t1;
	let t2;
	let pre;
	let t3;
	let t4;
	let demo0;
	let t5;
	let demo1;
	let t6;
	let demo2;
	let t7;
	let demo3;
	let t8;
	let demo4;
	let t9;
	let demo5;
	let current;

	demo0 = new Demo({
			props: {
				component: Simple,
				file: "data-table/_Simple.svelte"
			},
			$$inline: true
		});

	demo1 = new Demo({
			props: {
				component: ProgressIndicator,
				file: "data-table/_ProgressIndicator.svelte",
				$$slots: { default: [create_default_slot_4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	demo2 = new Demo({
			props: {
				component: StickyHeader,
				file: "data-table/iframe.svelte",
				$$slots: {
					subtitle: [create_subtitle_slot],
					default: [create_default_slot_3]
				},
				$$scope: { ctx }
			},
			$$inline: true
		});

	demo3 = new Demo({
			props: {
				component: RowSelection,
				file: "data-table/_RowSelection.svelte",
				$$slots: { default: [create_default_slot_2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	demo4 = new Demo({
			props: {
				component: Pagination_1,
				file: "data-table/_Pagination.svelte",
				$$slots: { default: [create_default_slot_1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	demo5 = new Demo({
			props: {
				component: Sortable,
				file: "data-table/_Sortable.svelte",
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			t0 = space();
			section = element("section");
			h2 = element("h2");
			t1 = text("Data Table");
			t2 = space();
			pre = element("pre");
			t3 = text("npm i -D @smui/data-table");
			t4 = space();
			create_component(demo0.$$.fragment);
			t5 = space();
			create_component(demo1.$$.fragment);
			t6 = space();
			create_component(demo2.$$.fragment);
			t7 = space();
			create_component(demo3.$$.fragment);
			t8 = space();
			create_component(demo4.$$.fragment);
			t9 = space();
			create_component(demo5.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			const head_nodes = query_selector_all("[data-svelte=\"svelte-7ugrg2\"]", document.head);
			head_nodes.forEach(detach_dev);
			t0 = claim_space(nodes);
			section = claim_element(nodes, "SECTION", {});
			var section_nodes = children(section);
			h2 = claim_element(section_nodes, "H2", {});
			var h2_nodes = children(h2);
			t1 = claim_text(h2_nodes, "Data Table");
			h2_nodes.forEach(detach_dev);
			t2 = claim_space(section_nodes);
			pre = claim_element(section_nodes, "PRE", { class: true });
			var pre_nodes = children(pre);
			t3 = claim_text(pre_nodes, "npm i -D @smui/data-table");
			pre_nodes.forEach(detach_dev);
			t4 = claim_space(section_nodes);
			claim_component(demo0.$$.fragment, section_nodes);
			t5 = claim_space(section_nodes);
			claim_component(demo1.$$.fragment, section_nodes);
			t6 = claim_space(section_nodes);
			claim_component(demo2.$$.fragment, section_nodes);
			t7 = claim_space(section_nodes);
			claim_component(demo3.$$.fragment, section_nodes);
			t8 = claim_space(section_nodes);
			claim_component(demo4.$$.fragment, section_nodes);
			t9 = claim_space(section_nodes);
			claim_component(demo5.$$.fragment, section_nodes);
			section_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			document.title = "Data Table - SMUI";
			add_location(h2, file, 5, 2, 77);
			attr_dev(pre, "class", "demo-spaced");
			add_location(pre, file, 7, 2, 100);
			add_location(section, file, 4, 0, 65);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			insert_dev(target, section, anchor);
			append_dev(section, h2);
			append_dev(h2, t1);
			append_dev(section, t2);
			append_dev(section, pre);
			append_dev(pre, t3);
			append_dev(section, t4);
			mount_component(demo0, section, null);
			append_dev(section, t5);
			mount_component(demo1, section, null);
			append_dev(section, t6);
			mount_component(demo2, section, null);
			append_dev(section, t7);
			mount_component(demo3, section, null);
			append_dev(section, t8);
			mount_component(demo4, section, null);
			append_dev(section, t9);
			mount_component(demo5, section, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const demo1_changes = {};

			if (dirty & /*$$scope*/ 1) {
				demo1_changes.$$scope = { dirty, ctx };
			}

			demo1.$set(demo1_changes);
			const demo2_changes = {};

			if (dirty & /*$$scope*/ 1) {
				demo2_changes.$$scope = { dirty, ctx };
			}

			demo2.$set(demo2_changes);
			const demo3_changes = {};

			if (dirty & /*$$scope*/ 1) {
				demo3_changes.$$scope = { dirty, ctx };
			}

			demo3.$set(demo3_changes);
			const demo4_changes = {};

			if (dirty & /*$$scope*/ 1) {
				demo4_changes.$$scope = { dirty, ctx };
			}

			demo4.$set(demo4_changes);
			const demo5_changes = {};

			if (dirty & /*$$scope*/ 1) {
				demo5_changes.$$scope = { dirty, ctx };
			}

			demo5.$set(demo5_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(demo0.$$.fragment, local);
			transition_in(demo1.$$.fragment, local);
			transition_in(demo2.$$.fragment, local);
			transition_in(demo3.$$.fragment, local);
			transition_in(demo4.$$.fragment, local);
			transition_in(demo5.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(demo0.$$.fragment, local);
			transition_out(demo1.$$.fragment, local);
			transition_out(demo2.$$.fragment, local);
			transition_out(demo3.$$.fragment, local);
			transition_out(demo4.$$.fragment, local);
			transition_out(demo5.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(section);
			destroy_component(demo0);
			destroy_component(demo1);
			destroy_component(demo2);
			destroy_component(demo3);
			destroy_component(demo4);
			destroy_component(demo5);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Data_table", slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Data_table> was created with unknown prop '${key}'`);
	});

	$$self.$capture_state = () => ({
		Demo,
		Simple,
		ProgressIndicator,
		StickyHeader,
		RowSelection,
		Pagination: Pagination_1,
		Sortable
	});

	return [];
}

class Data_table extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Data_table",
			options,
			id: create_fragment.name
		});
	}
}

export default Data_table;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguMmQwM2JlNTIuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3BhY2thZ2VzL2RhdGEtdGFibGUvUGFnaW5hdGlvbi5zdmVsdGUiLCIuLi8uLi8uLi9wYWNrYWdlcy9kYXRhLXRhYmxlL25vZGVfbW9kdWxlcy9Ac211aS9jb21tb24vU3Bhbi5zdmVsdGUiLCIuLi8uLi8uLi9wYWNrYWdlcy9kYXRhLXRhYmxlL25vZGVfbW9kdWxlcy9Ac211aS9jb21tb24vQ29tbW9uTGFiZWwuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL3JvdXRlcy9kZW1vL2RhdGEtdGFibGUvX1Byb2dyZXNzSW5kaWNhdG9yLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9yb3V0ZXMvZGVtby9kYXRhLXRhYmxlL19Sb3dTZWxlY3Rpb24uc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL3JvdXRlcy9kZW1vL2RhdGEtdGFibGUvX1BhZ2luYXRpb24uc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL3JvdXRlcy9kZW1vL2RhdGEtdGFibGUvX1NvcnRhYmxlLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9yb3V0ZXMvZGVtby9kYXRhLXRhYmxlL2luZGV4LnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8ZGl2XG4gIGJpbmQ6dGhpcz17ZWxlbWVudH1cbiAgdXNlOnVzZUFjdGlvbnM9e3VzZX1cbiAgdXNlOmZvcndhcmRFdmVudHNcbiAgY2xhc3M9e2NsYXNzTWFwKHtcbiAgICBbY2xhc3NOYW1lXTogdHJ1ZSxcbiAgICAnbWRjLWRhdGEtdGFibGVfX3BhZ2luYXRpb24nOiB0cnVlLFxuICB9KX1cbiAgey4uLmV4Y2x1ZGUoJCRyZXN0UHJvcHMsIFsndHJhaWxpbmckJ10pfVxuPlxuICA8ZGl2XG4gICAgdXNlOnVzZUFjdGlvbnM9e3RyYWlsaW5nJHVzZX1cbiAgICBjbGFzcz17Y2xhc3NNYXAoe1xuICAgICAgW3RyYWlsaW5nJGNsYXNzXTogdHJ1ZSxcbiAgICAgICdtZGMtZGF0YS10YWJsZV9fcGFnaW5hdGlvbi10cmFpbGluZyc6IHRydWUsXG4gICAgfSl9XG4gICAgey4uLnByZWZpeEZpbHRlcigkJHJlc3RQcm9wcywgJ3RyYWlsaW5nJCcpfVxuICA+XG4gICAgeyNpZiAkJHNsb3RzLnJvd3NQZXJQYWdlfVxuICAgICAgPGRpdiBjbGFzcz1cIm1kYy1kYXRhLXRhYmxlX19wYWdpbmF0aW9uLXJvd3MtcGVyLXBhZ2VcIj5cbiAgICAgICAgPHNsb3QgbmFtZT1cInJvd3NQZXJQYWdlXCIgLz5cbiAgICAgIDwvZGl2PlxuICAgIHsvaWZ9XG5cbiAgICA8ZGl2IGNsYXNzPVwibWRjLWRhdGEtdGFibGVfX3BhZ2luYXRpb24tbmF2aWdhdGlvblwiPlxuICAgICAgeyNpZiAkJHNsb3RzLnRvdGFsfVxuICAgICAgICA8ZGl2IGNsYXNzPVwibWRjLWRhdGEtdGFibGVfX3BhZ2luYXRpb24tdG90YWxcIj5cbiAgICAgICAgICA8c2xvdCBuYW1lPVwidG90YWxcIiAvPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIHsvaWZ9XG5cbiAgICAgIDxzbG90IC8+XG4gICAgPC9kaXY+XG4gIDwvZGl2PlxuPC9kaXY+XG5cbjxzY3JpcHQ+XG4gIGltcG9ydCB7IHNldENvbnRleHQgfSBmcm9tICdzdmVsdGUnO1xuICBpbXBvcnQgeyBnZXRfY3VycmVudF9jb21wb25lbnQgfSBmcm9tICdzdmVsdGUvaW50ZXJuYWwnO1xuICBpbXBvcnQge1xuICAgIGZvcndhcmRFdmVudHNCdWlsZGVyLFxuICAgIGNsYXNzTWFwLFxuICAgIGV4Y2x1ZGUsXG4gICAgcHJlZml4RmlsdGVyLFxuICAgIHVzZUFjdGlvbnMsXG4gIH0gZnJvbSAnQHNtdWkvY29tbW9uL2ludGVybmFsLmpzJztcblxuICBjb25zdCBmb3J3YXJkRXZlbnRzID0gZm9yd2FyZEV2ZW50c0J1aWxkZXIoZ2V0X2N1cnJlbnRfY29tcG9uZW50KCkpO1xuXG4gIGV4cG9ydCBsZXQgdXNlID0gW107XG4gIGxldCBjbGFzc05hbWUgPSAnJztcbiAgZXhwb3J0IHsgY2xhc3NOYW1lIGFzIGNsYXNzIH07XG4gIGV4cG9ydCBsZXQgdHJhaWxpbmckdXNlID0gW107XG4gIGV4cG9ydCBsZXQgdHJhaWxpbmckY2xhc3MgPSAnJztcblxuICBsZXQgZWxlbWVudDtcblxuICBzZXRDb250ZXh0KCdTTVVJOmxhYmVsOmNvbnRleHQnLCAnZGF0YS10YWJsZTpwYWdpbmF0aW9uJyk7XG4gIHNldENvbnRleHQoJ1NNVUk6c2VsZWN0OmNvbnRleHQnLCAnZGF0YS10YWJsZTpwYWdpbmF0aW9uJyk7XG4gIHNldENvbnRleHQoJ1NNVUk6aWNvbi1idXR0b246Y29udGV4dCcsICdkYXRhLXRhYmxlOnBhZ2luYXRpb24nKTtcblxuICBleHBvcnQgZnVuY3Rpb24gZ2V0RWxlbWVudCgpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuPC9zY3JpcHQ+XG4iLCI8c3BhblxuICBiaW5kOnRoaXM9e2VsZW1lbnR9XG4gIHVzZTp1c2VBY3Rpb25zPXt1c2V9XG4gIHVzZTpmb3J3YXJkRXZlbnRzXG4gIHsuLi4kJHJlc3RQcm9wc30+PHNsb3QgLz48L3NwYW5cbj5cblxuPHNjcmlwdD5cbiAgaW1wb3J0IHsgZ2V0X2N1cnJlbnRfY29tcG9uZW50IH0gZnJvbSAnc3ZlbHRlL2ludGVybmFsJztcbiAgaW1wb3J0IHsgZm9yd2FyZEV2ZW50c0J1aWxkZXIsIHVzZUFjdGlvbnMgfSBmcm9tICcuL2ludGVybmFsLmpzJztcblxuICBleHBvcnQgbGV0IHVzZSA9IFtdO1xuXG4gIGNvbnN0IGZvcndhcmRFdmVudHMgPSBmb3J3YXJkRXZlbnRzQnVpbGRlcihnZXRfY3VycmVudF9jb21wb25lbnQoKSk7XG5cbiAgbGV0IGVsZW1lbnQgPSBudWxsO1xuXG4gIGV4cG9ydCBmdW5jdGlvbiBnZXRFbGVtZW50KCkge1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG48L3NjcmlwdD5cbiIsIjxzdmVsdGU6Y29tcG9uZW50XG4gIHRoaXM9e2NvbXBvbmVudH1cbiAgYmluZDp0aGlzPXtlbGVtZW50fVxuICB1c2U9e1tmb3J3YXJkRXZlbnRzLCAuLi51c2VdfVxuICBjbGFzcz17Y2xhc3NNYXAoe1xuICAgIFtjbGFzc05hbWVdOiB0cnVlLFxuICAgICdtZGMtYnV0dG9uX19sYWJlbCc6IGNvbnRleHQgPT09ICdidXR0b24nLFxuICAgICdtZGMtZmFiX19sYWJlbCc6IGNvbnRleHQgPT09ICdmYWInLFxuICAgICdtZGMtdGFiX190ZXh0LWxhYmVsJzogY29udGV4dCA9PT0gJ3RhYicsXG4gICAgJ21kYy1pbWFnZS1saXN0X19sYWJlbCc6IGNvbnRleHQgPT09ICdpbWFnZS1saXN0JyxcbiAgICAnbWRjLXNuYWNrYmFyX19sYWJlbCc6IGNvbnRleHQgPT09ICdzbmFja2JhcicsXG4gICAgJ21kYy1iYW5uZXJfX3RleHQnOiBjb250ZXh0ID09PSAnYmFubmVyJyxcbiAgICAnbWRjLXNlZ21lbnRlZC1idXR0b25fX2xhYmVsJzogY29udGV4dCA9PT0gJ3NlZ21lbnRlZC1idXR0b24nLFxuICAgICdtZGMtZGF0YS10YWJsZV9fcGFnaW5hdGlvbi1yb3dzLXBlci1wYWdlLWxhYmVsJzpcbiAgICAgIGNvbnRleHQgPT09ICdkYXRhLXRhYmxlOnBhZ2luYXRpb24nLFxuICAgICdtZGMtZGF0YS10YWJsZV9faGVhZGVyLWNlbGwtbGFiZWwnOlxuICAgICAgY29udGV4dCA9PT0gJ2RhdGEtdGFibGU6c29ydGFibGUtaGVhZGVyLWNlbGwnLFxuICB9KX1cbiAgey4uLmNvbnRleHQgPT09ICdzbmFja2JhcicgPyB7ICdhcmlhLWF0b21pYyc6ICdmYWxzZScgfSA6IHt9fVxuICB7dGFiaW5kZXh9XG4gIHsuLi4kJHJlc3RQcm9wc30+PHNsb3QgLz48L3N2ZWx0ZTpjb21wb25lbnRcbj5cblxuPHNjcmlwdD5cbiAgaW1wb3J0IHsgZ2V0Q29udGV4dCB9IGZyb20gJ3N2ZWx0ZSc7XG4gIGltcG9ydCB7IGdldF9jdXJyZW50X2NvbXBvbmVudCB9IGZyb20gJ3N2ZWx0ZS9pbnRlcm5hbCc7XG4gIGltcG9ydCB7IGZvcndhcmRFdmVudHNCdWlsZGVyLCBjbGFzc01hcCwgdXNlQWN0aW9ucyB9IGZyb20gJy4vaW50ZXJuYWwuanMnO1xuICBpbXBvcnQgU3BhbiBmcm9tICcuL1NwYW4uc3ZlbHRlJztcblxuICBjb25zdCBmb3J3YXJkRXZlbnRzID0gZm9yd2FyZEV2ZW50c0J1aWxkZXIoZ2V0X2N1cnJlbnRfY29tcG9uZW50KCkpO1xuXG4gIGV4cG9ydCBsZXQgdXNlID0gW107XG4gIGxldCBjbGFzc05hbWUgPSAnJztcbiAgZXhwb3J0IHsgY2xhc3NOYW1lIGFzIGNsYXNzIH07XG5cbiAgbGV0IGVsZW1lbnQ7XG5cbiAgZXhwb3J0IGxldCBjb21wb25lbnQgPSBTcGFuO1xuXG4gIGNvbnN0IGNvbnRleHQgPSBnZXRDb250ZXh0KCdTTVVJOmxhYmVsOmNvbnRleHQnKTtcbiAgY29uc3QgdGFiaW5kZXggPSBnZXRDb250ZXh0KCdTTVVJOmxhYmVsOnRhYmluZGV4Jyk7XG5cbiAgZXhwb3J0IGZ1bmN0aW9uIGdldEVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQuZ2V0RWxlbWVudCgpO1xuICB9XG48L3NjcmlwdD5cbiIsIjxkaXYgc3R5bGU9XCJtYXJnaW4tYm90dG9tOiAxZW07XCI+XG4gIDxCdXR0b24gb246Y2xpY2s9eygpID0+IGxvYWRUaGluZ3ModHJ1ZSl9PkRvIFByZXRlbmQgTG9hZGluZzwvQnV0dG9uPlxuPC9kaXY+XG5cbjxEYXRhVGFibGUgdGFibGUkYXJpYS1sYWJlbD1cIlVzZXIgbGlzdFwiIHN0eWxlPVwid2lkdGg6IDEwMCU7XCI+XG4gIDxIZWFkPlxuICAgIDxSb3c+XG4gICAgICA8Q2VsbCBudW1lcmljPklEPC9DZWxsPlxuICAgICAgPENlbGwgc3R5bGU9XCJ3aWR0aDogMTAwJTtcIj5OYW1lPC9DZWxsPlxuICAgICAgPENlbGw+VXNlcm5hbWU8L0NlbGw+XG4gICAgICA8Q2VsbD5FbWFpbDwvQ2VsbD5cbiAgICA8L1Jvdz5cbiAgPC9IZWFkPlxuICA8Qm9keT5cbiAgICB7I2VhY2ggaXRlbXMgYXMgaXRlbSAoaXRlbS5pZCl9XG4gICAgICA8Um93PlxuICAgICAgICA8Q2VsbCBudW1lcmljPntpdGVtLmlkfTwvQ2VsbD5cbiAgICAgICAgPENlbGw+e2l0ZW0ubmFtZX08L0NlbGw+XG4gICAgICAgIDxDZWxsPntpdGVtLnVzZXJuYW1lfTwvQ2VsbD5cbiAgICAgICAgPENlbGw+e2l0ZW0uZW1haWx9PC9DZWxsPlxuICAgICAgPC9Sb3c+XG4gICAgey9lYWNofVxuICA8L0JvZHk+XG5cbiAgPExpbmVhclByb2dyZXNzXG4gICAgaW5kZXRlcm1pbmF0ZVxuICAgIGJpbmQ6Y2xvc2VkPXtsb2FkZWR9XG4gICAgYXJpYS1sYWJlbD1cIkRhdGEgaXMgYmVpbmcgbG9hZGVkLi4uXCJcbiAgICBzbG90PVwicHJvZ3Jlc3NcIlxuICAvPlxuPC9EYXRhVGFibGU+XG5cbjxzY3JpcHQ+XG4gIGltcG9ydCBEYXRhVGFibGUsIHsgSGVhZCwgQm9keSwgUm93LCBDZWxsIH0gZnJvbSAnQHNtdWkvZGF0YS10YWJsZSc7XG4gIGltcG9ydCBMaW5lYXJQcm9ncmVzcyBmcm9tICdAc211aS9saW5lYXItcHJvZ3Jlc3MnO1xuICBpbXBvcnQgQnV0dG9uIGZyb20gJ0BzbXVpL2J1dHRvbic7XG5cbiAgbGV0IGl0ZW1zID0gW107XG4gIGxldCBsb2FkZWQgPSBmYWxzZTtcblxuICBsb2FkVGhpbmdzKGZhbHNlKTtcblxuICBmdW5jdGlvbiBsb2FkVGhpbmdzKHdhaXQpIHtcbiAgICBpZiAodHlwZW9mIGZldGNoICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgbG9hZGVkID0gZmFsc2U7XG5cbiAgICAgIGZldGNoKFxuICAgICAgICAnaHR0cHM6Ly9naXN0LmdpdGh1YnVzZXJjb250ZW50LmNvbS9ocGVycmluL2UyNGE0ZWJkOWFmZGYyYThjMjgzMzM4YWU1MTYwYTYyL3Jhdy9kY2JmOGU2MzgyZGI0OWIwZGNhYjcwYjIyZjU2YjFjYzQ0NGYyNmQ0L3VzZXJzLmpzb24nXG4gICAgICApXG4gICAgICAgIC50aGVuKChyZXNwb25zZSkgPT4gcmVzcG9uc2UuanNvbigpKVxuICAgICAgICAudGhlbigoanNvbikgPT5cbiAgICAgICAgICBzZXRUaW1lb3V0KFxuICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICBpdGVtcyA9IGpzb247XG4gICAgICAgICAgICAgIGxvYWRlZCA9IHRydWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gU2ltdWxhdGUgYSBsb25nIGxvYWQgdGltZS5cbiAgICAgICAgICAgIHdhaXQgPyAyMDAwIDogMFxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICB9XG4gIH1cbjwvc2NyaXB0PlxuIiwiPERhdGFUYWJsZSBzdHlsZT1cIm1heC13aWR0aDogMTAwJTtcIj5cbiAgPEhlYWQ+XG4gICAgPFJvdz5cbiAgICAgIDxDZWxsIGNoZWNrYm94PlxuICAgICAgICA8Q2hlY2tib3ggLz5cbiAgICAgIDwvQ2VsbD5cbiAgICAgIDxDZWxsPk5hbWU8L0NlbGw+XG4gICAgICA8Q2VsbD5EZXNjcmlwdGlvbjwvQ2VsbD5cbiAgICAgIDxDZWxsIG51bWVyaWM+UHJpY2U8L0NlbGw+XG4gICAgPC9Sb3c+XG4gIDwvSGVhZD5cbiAgPEJvZHk+XG4gICAgeyNlYWNoIG9wdGlvbnMgYXMgb3B0aW9uIChvcHRpb24ubmFtZSl9XG4gICAgICA8Um93PlxuICAgICAgICA8Q2VsbCBjaGVja2JveD5cbiAgICAgICAgICA8Q2hlY2tib3hcbiAgICAgICAgICAgIGJpbmQ6Z3JvdXA9e3NlbGVjdGVkfVxuICAgICAgICAgICAgdmFsdWU9e29wdGlvbn1cbiAgICAgICAgICAgIHZhbHVlS2V5PXtvcHRpb24ubmFtZX1cbiAgICAgICAgICAvPlxuICAgICAgICA8L0NlbGw+XG4gICAgICAgIDxDZWxsPntvcHRpb24ubmFtZX08L0NlbGw+XG4gICAgICAgIDxDZWxsPntvcHRpb24uZGVzY3JpcHRpb259PC9DZWxsPlxuICAgICAgICA8Q2VsbCBudW1lcmljPntvcHRpb24ucHJpY2V9PC9DZWxsPlxuICAgICAgPC9Sb3c+XG4gICAgey9lYWNofVxuICA8L0JvZHk+XG48L0RhdGFUYWJsZT5cblxuPHByZVxuICBjbGFzcz1cInN0YXR1c1wiPlNlbGVjdGVkOiB7c2VsZWN0ZWQubWFwKG9wdGlvbiA9PiBvcHRpb24ubmFtZSkuam9pbignLCAnKX08L3ByZT5cbjxwcmUgY2xhc3M9XCJzdGF0dXNcIj5Ub3RhbDoge3NlbGVjdGVkUHJpY2V9PC9wcmU+XG5cbjxzY3JpcHQ+XG4gIGltcG9ydCBEYXRhVGFibGUsIHsgSGVhZCwgQm9keSwgUm93LCBDZWxsIH0gZnJvbSAnQHNtdWkvZGF0YS10YWJsZSc7XG4gIGltcG9ydCBDaGVja2JveCBmcm9tICdAc211aS9jaGVja2JveCc7XG5cbiAgJDogc2VsZWN0ZWRQcmljZSA9IHNlbGVjdGVkLnJlZHVjZShcbiAgICAodG90YWwsIG9wdGlvbikgPT4gb3B0aW9uLnByaWNlICsgdG90YWwsXG4gICAgMFxuICApO1xuXG4gIGxldCBvcHRpb25zID0gW1xuICAgIHtcbiAgICAgIG5hbWU6ICdCcm9vbScsXG4gICAgICBkZXNjcmlwdGlvbjogJ0Egd29vZGVuIGhhbmRsZWQgYnJvb20uJyxcbiAgICAgIHByaWNlOiAxNSxcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdEdXN0IFBhbicsXG4gICAgICBkZXNjcmlwdGlvbjogJ0EgcGxhc3RpYyBkdXN0IHBhbi4nLFxuICAgICAgcHJpY2U6IDgsXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnTW9wJyxcbiAgICAgIGRlc2NyaXB0aW9uOiAnQSBzdHJvbmcsIGR1cmFibGUgbW9wLicsXG4gICAgICBwcmljZTogMTgsXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnSG9yc2UnLFxuICAgICAgZGVzY3JpcHRpb246IFwiU2hlJ3MgZ290IHNvbWUgbWlsZXMgb24gaGVyLlwiLFxuICAgICAgcHJpY2U6IDgzLFxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ0J1Y2tldCcsXG4gICAgICBkZXNjcmlwdGlvbjogJ0EgbWV0YWwgYnVja2V0LicsXG4gICAgICBwcmljZTogMTMsXG4gICAgfSxcbiAgXTtcbiAgbGV0IHNlbGVjdGVkID0gW29wdGlvbnNbMl1dO1xuPC9zY3JpcHQ+XG4iLCI8RGF0YVRhYmxlIHRhYmxlJGFyaWEtbGFiZWw9XCJUb2RvIGxpc3RcIiBzdHlsZT1cIndpZHRoOiAxMDAlO1wiPlxuICA8SGVhZD5cbiAgICA8Um93PlxuICAgICAgPENlbGwgbnVtZXJpYz5JRDwvQ2VsbD5cbiAgICAgIDxDZWxsIHN0eWxlPVwid2lkdGg6IDEwMCU7XCI+VGl0bGU8L0NlbGw+XG4gICAgICA8Q2VsbD5Db21wbGV0ZWQ8L0NlbGw+XG4gICAgICA8Q2VsbCBudW1lcmljPlVzZXIgSUQ8L0NlbGw+XG4gICAgPC9Sb3c+XG4gIDwvSGVhZD5cbiAgPEJvZHk+XG4gICAgeyNlYWNoIHNsaWNlIGFzIGl0ZW0gKGl0ZW0uaWQpfVxuICAgICAgPFJvdz5cbiAgICAgICAgPENlbGwgbnVtZXJpYz57aXRlbS5pZH08L0NlbGw+XG4gICAgICAgIDxDZWxsPntpdGVtLnRpdGxlfTwvQ2VsbD5cbiAgICAgICAgPENlbGw+e2l0ZW0uY29tcGxldGVkID8gJ1llcycgOiAnTm8nfTwvQ2VsbD5cbiAgICAgICAgPENlbGwgbnVtZXJpYz57aXRlbS51c2VySWR9PC9DZWxsPlxuICAgICAgPC9Sb3c+XG4gICAgey9lYWNofVxuICA8L0JvZHk+XG5cbiAgPFBhZ2luYXRpb24gc2xvdD1cInBhZ2luYXRlXCI+XG4gICAgPHN2ZWx0ZTpmcmFnbWVudCBzbG90PVwicm93c1BlclBhZ2VcIj5cbiAgICAgIDxMYWJlbD5Sb3dzIFBlciBQYWdlPC9MYWJlbD5cbiAgICAgIDxTZWxlY3QgdmFyaWFudD1cIm91dGxpbmVkXCIgYmluZDp2YWx1ZT17cm93c1BlclBhZ2V9IG5vTGFiZWw+XG4gICAgICAgIDxPcHRpb24gdmFsdWU9ezEwfT4xMDwvT3B0aW9uPlxuICAgICAgICA8T3B0aW9uIHZhbHVlPXsyNX0+MjU8L09wdGlvbj5cbiAgICAgICAgPE9wdGlvbiB2YWx1ZT17MTAwfT4xMDA8L09wdGlvbj5cbiAgICAgIDwvU2VsZWN0PlxuICAgIDwvc3ZlbHRlOmZyYWdtZW50PlxuICAgIDxzdmVsdGU6ZnJhZ21lbnQgc2xvdD1cInRvdGFsXCI+XG4gICAgICB7c3RhcnQgKyAxfS17ZW5kfSBvZiB7aXRlbXMubGVuZ3RofVxuICAgIDwvc3ZlbHRlOmZyYWdtZW50PlxuXG4gICAgPEljb25CdXR0b25cbiAgICAgIGNsYXNzPVwibWF0ZXJpYWwtaWNvbnNcIlxuICAgICAgYWN0aW9uPVwiZmlyc3QtcGFnZVwiXG4gICAgICB0aXRsZT1cIkZpcnN0IHBhZ2VcIlxuICAgICAgb246Y2xpY2s9eygpID0+IChjdXJyZW50UGFnZSA9IDApfVxuICAgICAgZGlzYWJsZWQ9e2N1cnJlbnRQYWdlID09PSAwfT5maXJzdF9wYWdlPC9JY29uQnV0dG9uXG4gICAgPlxuICAgIDxJY29uQnV0dG9uXG4gICAgICBjbGFzcz1cIm1hdGVyaWFsLWljb25zXCJcbiAgICAgIGFjdGlvbj1cInByZXYtcGFnZVwiXG4gICAgICB0aXRsZT1cIlByZXYgcGFnZVwiXG4gICAgICBvbjpjbGljaz17KCkgPT4gY3VycmVudFBhZ2UtLX1cbiAgICAgIGRpc2FibGVkPXtjdXJyZW50UGFnZSA9PT0gMH0+Y2hldnJvbl9sZWZ0PC9JY29uQnV0dG9uXG4gICAgPlxuICAgIDxJY29uQnV0dG9uXG4gICAgICBjbGFzcz1cIm1hdGVyaWFsLWljb25zXCJcbiAgICAgIGFjdGlvbj1cIm5leHQtcGFnZVwiXG4gICAgICB0aXRsZT1cIk5leHQgcGFnZVwiXG4gICAgICBvbjpjbGljaz17KCkgPT4gY3VycmVudFBhZ2UrK31cbiAgICAgIGRpc2FibGVkPXtjdXJyZW50UGFnZSA9PT0gbGFzdFBhZ2V9PmNoZXZyb25fcmlnaHQ8L0ljb25CdXR0b25cbiAgICA+XG4gICAgPEljb25CdXR0b25cbiAgICAgIGNsYXNzPVwibWF0ZXJpYWwtaWNvbnNcIlxuICAgICAgYWN0aW9uPVwibGFzdC1wYWdlXCJcbiAgICAgIHRpdGxlPVwiTGFzdCBwYWdlXCJcbiAgICAgIG9uOmNsaWNrPXsoKSA9PiAoY3VycmVudFBhZ2UgPSBsYXN0UGFnZSl9XG4gICAgICBkaXNhYmxlZD17Y3VycmVudFBhZ2UgPT09IGxhc3RQYWdlfT5sYXN0X3BhZ2U8L0ljb25CdXR0b25cbiAgICA+XG4gIDwvUGFnaW5hdGlvbj5cbjwvRGF0YVRhYmxlPlxuXG48c2NyaXB0PlxuICBpbXBvcnQgRGF0YVRhYmxlLCB7XG4gICAgSGVhZCxcbiAgICBCb2R5LFxuICAgIFJvdyxcbiAgICBDZWxsLFxuICAgIFBhZ2luYXRpb24sXG4gIH0gZnJvbSAnQHNtdWkvZGF0YS10YWJsZSc7XG4gIGltcG9ydCBTZWxlY3QsIHsgT3B0aW9uIH0gZnJvbSAnQHNtdWkvc2VsZWN0JztcbiAgaW1wb3J0IEljb25CdXR0b24gZnJvbSAnQHNtdWkvaWNvbi1idXR0b24nO1xuICBpbXBvcnQgeyBMYWJlbCB9IGZyb20gJ0BzbXVpL2NvbW1vbic7XG5cbiAgbGV0IHJvd3NQZXJQYWdlID0gMTA7XG4gIGxldCBjdXJyZW50UGFnZSA9IDA7XG4gIGxldCBpdGVtcyA9IFtdO1xuXG4gICQ6IHN0YXJ0ID0gY3VycmVudFBhZ2UgKiByb3dzUGVyUGFnZTtcbiAgJDogZW5kID0gTWF0aC5taW4oc3RhcnQgKyByb3dzUGVyUGFnZSwgaXRlbXMubGVuZ3RoKTtcbiAgJDogc2xpY2UgPSBpdGVtcy5zbGljZShzdGFydCwgZW5kKTtcbiAgJDogbGFzdFBhZ2UgPSBNYXRoLm1heChNYXRoLmNlaWwoaXRlbXMubGVuZ3RoIC8gcm93c1BlclBhZ2UpIC0gMSwgMCk7XG5cbiAgJDogaWYgKGN1cnJlbnRQYWdlID4gbGFzdFBhZ2UpIHtcbiAgICBjdXJyZW50UGFnZSA9IGxhc3RQYWdlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBmZXRjaCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBTbGljZSBhIGZldyBvZmYgdGhlIGVuZCB0byBzaG93IGhvdyB0aGVcbiAgICAvLyBsYXN0IHBhZ2UgbG9va3Mgd2hlbiBpdCdzIG5vdCBmdWxsLlxuICAgIGZldGNoKFxuICAgICAgJ2h0dHBzOi8vZ2lzdC5naXRodWJ1c2VyY29udGVudC5jb20vaHBlcnJpbi9lMjRhNGViZDlhZmRmMmE4YzI4MzMzOGFlNTE2MGE2Mi9yYXcvZGNiZjhlNjM4MmRiNDliMGRjYWI3MGIyMmY1NmIxY2M0NDRmMjZkNC90b2Rvcy5qc29uJ1xuICAgIClcbiAgICAgIC50aGVuKChyZXNwb25zZSkgPT4gcmVzcG9uc2UuanNvbigpKVxuICAgICAgLnRoZW4oKGpzb24pID0+IChpdGVtcyA9IGpzb24uc2xpY2UoMCwgMTk3KSkpO1xuICB9XG48L3NjcmlwdD5cbiIsIjxEYXRhVGFibGVcbiAgc29ydGFibGVcbiAgYmluZDpzb3J0XG4gIGJpbmQ6c29ydERpcmVjdGlvblxuICBvbjpNRENEYXRhVGFibGU6c29ydGVkPXtoYW5kbGVTb3J0fVxuICB0YWJsZSRhcmlhLWxhYmVsPVwiVXNlciBsaXN0XCJcbiAgc3R5bGU9XCJ3aWR0aDogMTAwJTtcIlxuPlxuICA8SGVhZD5cbiAgICA8Um93PlxuICAgICAgPCEtLVxuICAgICAgICBOb3RlOiB3aGF0ZXZlciB5b3Ugc3VwcGx5IHRvIFwiY29sdW1uSWRcIiBpc1xuICAgICAgICBhcHBlbmRlZCB3aXRoIFwiLXN0YXR1cy1sYWJlbFwiIGFuZCB1c2VkIGFzIGFuIElEXG4gICAgICAgIGZvciB0aGUgaGlkZGVuIGxhYmVsIHRoYXQgZGVzY3JpYmVzIHRoZSBzb3J0XG4gICAgICAgIHN0YXR1cyB0byBzY3JlZW4gcmVhZGVycy5cblxuICAgICAgICBZb3UgY2FuIGxvY2FsaXplIHRob3NlIGxhYmVscyB3aXRoIHRoZVxuICAgICAgICBcInNvcnRBc2NlbmRpbmdBcmlhTGFiZWxcIiBhbmRcbiAgICAgICAgXCJzb3J0RGVzY2VuZGluZ0FyaWFMYWJlbFwiIHByb3BzIG9uIHRoZSBEYXRhVGFibGUuXG4gICAgICAtLT5cbiAgICAgIDxDZWxsIG51bWVyaWMgY29sdW1uSWQ9XCJpZFwiPlxuICAgICAgICA8IS0tIEZvciBudW1lcmljIGNvbHVtbnMsIGljb24gY29tZXMgZmlyc3QuIC0tPlxuICAgICAgICA8SWNvbkJ1dHRvbiBjbGFzcz1cIm1hdGVyaWFsLWljb25zXCI+YXJyb3dfdXB3YXJkPC9JY29uQnV0dG9uPlxuICAgICAgICA8TGFiZWw+SUQ8L0xhYmVsPlxuICAgICAgPC9DZWxsPlxuICAgICAgPENlbGwgY29sdW1uSWQ9XCJuYW1lXCIgc3R5bGU9XCJ3aWR0aDogMTAwJTtcIj5cbiAgICAgICAgPExhYmVsPk5hbWU8L0xhYmVsPlxuICAgICAgICA8IS0tIEZvciBub24tbnVtZXJpYyBjb2x1bW5zLCBpY29uIGNvbWVzIHNlY29uZC4gLS0+XG4gICAgICAgIDxJY29uQnV0dG9uIGNsYXNzPVwibWF0ZXJpYWwtaWNvbnNcIj5hcnJvd191cHdhcmQ8L0ljb25CdXR0b24+XG4gICAgICA8L0NlbGw+XG4gICAgICA8Q2VsbCBjb2x1bW5JZD1cInVzZXJuYW1lXCI+XG4gICAgICAgIDxMYWJlbD5Vc2VybmFtZTwvTGFiZWw+XG4gICAgICAgIDxJY29uQnV0dG9uIGNsYXNzPVwibWF0ZXJpYWwtaWNvbnNcIj5hcnJvd191cHdhcmQ8L0ljb25CdXR0b24+XG4gICAgICA8L0NlbGw+XG4gICAgICA8Q2VsbCBjb2x1bW5JZD1cImVtYWlsXCIgbD5cbiAgICAgICAgPExhYmVsPkVtYWlsPC9MYWJlbD5cbiAgICAgICAgPEljb25CdXR0b24gY2xhc3M9XCJtYXRlcmlhbC1pY29uc1wiPmFycm93X3Vwd2FyZDwvSWNvbkJ1dHRvbj5cbiAgICAgIDwvQ2VsbD5cbiAgICAgIDwhLS0gWW91IGNhbiB0dXJuIG9mZiBzb3J0aW5nIGZvciBhIGNvbHVtbi4gLS0+XG4gICAgICA8Q2VsbCBzb3J0YWJsZT17ZmFsc2V9PldlYnNpdGU8L0NlbGw+XG4gICAgPC9Sb3c+XG4gIDwvSGVhZD5cbiAgPEJvZHk+XG4gICAgeyNlYWNoIGl0ZW1zIGFzIGl0ZW0gKGl0ZW0uaWQpfVxuICAgICAgPFJvdz5cbiAgICAgICAgPENlbGwgbnVtZXJpYz57aXRlbS5pZH08L0NlbGw+XG4gICAgICAgIDxDZWxsPntpdGVtLm5hbWV9PC9DZWxsPlxuICAgICAgICA8Q2VsbD57aXRlbS51c2VybmFtZX08L0NlbGw+XG4gICAgICAgIDxDZWxsPntpdGVtLmVtYWlsfTwvQ2VsbD5cbiAgICAgICAgPENlbGw+e2l0ZW0ud2Vic2l0ZX08L0NlbGw+XG4gICAgICA8L1Jvdz5cbiAgICB7L2VhY2h9XG4gIDwvQm9keT5cbjwvRGF0YVRhYmxlPlxuXG48c2NyaXB0PlxuICBpbXBvcnQgRGF0YVRhYmxlLCB7IEhlYWQsIEJvZHksIFJvdywgQ2VsbCwgTGFiZWwgfSBmcm9tICdAc211aS9kYXRhLXRhYmxlJztcbiAgaW1wb3J0IEljb25CdXR0b24gZnJvbSAnQHNtdWkvaWNvbi1idXR0b24nO1xuXG4gIGxldCBpdGVtcyA9IFtdO1xuICBsZXQgc29ydCA9ICdpZCc7XG4gIGxldCBzb3J0RGlyZWN0aW9uID0gJ2FzY2VuZGluZyc7XG5cbiAgaWYgKHR5cGVvZiBmZXRjaCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBmZXRjaChcbiAgICAgICdodHRwczovL2dpc3QuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2hwZXJyaW4vZTI0YTRlYmQ5YWZkZjJhOGMyODMzMzhhZTUxNjBhNjIvcmF3L2RjYmY4ZTYzODJkYjQ5YjBkY2FiNzBiMjJmNTZiMWNjNDQ0ZjI2ZDQvdXNlcnMuanNvbidcbiAgICApXG4gICAgICAudGhlbigocmVzcG9uc2UpID0+IHJlc3BvbnNlLmpzb24oKSlcbiAgICAgIC50aGVuKChqc29uKSA9PiAoaXRlbXMgPSBqc29uKSk7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVTb3J0KCkge1xuICAgIGl0ZW1zLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgIGNvbnN0IFthVmFsLCBiVmFsXSA9IFthW3NvcnRdLCBiW3NvcnRdXVtcbiAgICAgICAgc29ydERpcmVjdGlvbiA9PT0gJ2FzY2VuZGluZycgPyAnc2xpY2UnIDogJ3JldmVyc2UnXG4gICAgICBdKCk7XG4gICAgICBpZiAodHlwZW9mIGFWYWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBhVmFsLmxvY2FsZUNvbXBhcmUoYlZhbCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYVZhbCAtIGJWYWw7XG4gICAgfSk7XG4gICAgaXRlbXMgPSBpdGVtcztcbiAgfVxuPC9zY3JpcHQ+XG4iLCI8c3ZlbHRlOmhlYWQ+XG4gIDx0aXRsZT5EYXRhIFRhYmxlIC0gU01VSTwvdGl0bGU+XG48L3N2ZWx0ZTpoZWFkPlxuXG48c2VjdGlvbj5cbiAgPGgyPkRhdGEgVGFibGU8L2gyPlxuXG4gIDxwcmUgY2xhc3M9XCJkZW1vLXNwYWNlZFwiPm5wbSBpIC1EIEBzbXVpL2RhdGEtdGFibGU8L3ByZT5cblxuICA8RGVtbyBjb21wb25lbnQ9e1NpbXBsZX0gZmlsZT1cImRhdGEtdGFibGUvX1NpbXBsZS5zdmVsdGVcIiAvPlxuXG4gIDxEZW1vXG4gICAgY29tcG9uZW50PXtQcm9ncmVzc0luZGljYXRvcn1cbiAgICBmaWxlPVwiZGF0YS10YWJsZS9fUHJvZ3Jlc3NJbmRpY2F0b3Iuc3ZlbHRlXCJcbiAgPlxuICAgIFByb2dyZXNzIGluZGljYXRvclxuICA8L0RlbW8+XG5cbiAgPERlbW8gY29tcG9uZW50PXtTdGlja3lIZWFkZXJ9IGZpbGU9XCJkYXRhLXRhYmxlL2lmcmFtZS5zdmVsdGVcIj5cbiAgICBTdGlja3kgaGVhZGVyXG4gICAgPHN2ZWx0ZTpmcmFnbWVudCBzbG90PVwic3VidGl0bGVcIj5cbiAgICAgIFRoaXMgaXMgZGlzcGxheWVkIGluIGFuIGlmcmFtZSBhbmQgdGhlIHNvdXJjZSB2aWV3ZXIgc2hvd3MgdGhlIGlmcmFtZVxuICAgICAgc291cmNlLiBTdGlja3kgaGVhZGVycyBkb24ndCB3b3JrIGlmIGFueSBhbmNlc3RvciBlbGVtZW50IGhhcyB0aGVcbiAgICAgIFwib3ZlcmZsb3dcIiBzdHlsZSBzZXQgdG8gXCJoaWRkZW5cIiwgXCJzY3JvbGxcIiwgb3IgXCJhdXRvXCIuXG4gICAgPC9zdmVsdGU6ZnJhZ21lbnQ+XG4gIDwvRGVtbz5cblxuICA8RGVtbyBjb21wb25lbnQ9e1Jvd1NlbGVjdGlvbn0gZmlsZT1cImRhdGEtdGFibGUvX1Jvd1NlbGVjdGlvbi5zdmVsdGVcIj5cbiAgICBSb3cgc2VsZWN0aW9uXG4gIDwvRGVtbz5cblxuICA8RGVtbyBjb21wb25lbnQ9e1BhZ2luYXRpb259IGZpbGU9XCJkYXRhLXRhYmxlL19QYWdpbmF0aW9uLnN2ZWx0ZVwiPlxuICAgIFBhZ2luYXRpb25cbiAgPC9EZW1vPlxuXG4gIDxEZW1vIGNvbXBvbmVudD17U29ydGFibGV9IGZpbGU9XCJkYXRhLXRhYmxlL19Tb3J0YWJsZS5zdmVsdGVcIj5Tb3J0YWJsZTwvRGVtbz5cbjwvc2VjdGlvbj5cblxuPHNjcmlwdD5cbiAgaW1wb3J0IERlbW8gZnJvbSAnLi4vLi4vLi4vY29tcG9uZW50cy9EZW1vLnN2ZWx0ZSc7XG4gIGltcG9ydCBTaW1wbGUgZnJvbSAnLi9fU2ltcGxlLnN2ZWx0ZSc7XG4gIGltcG9ydCBQcm9ncmVzc0luZGljYXRvciBmcm9tICcuL19Qcm9ncmVzc0luZGljYXRvci5zdmVsdGUnO1xuICBpbXBvcnQgU3RpY2t5SGVhZGVyIGZyb20gJy4vX1N0aWNreUhlYWRlci5zdmVsdGUnO1xuICBpbXBvcnQgUm93U2VsZWN0aW9uIGZyb20gJy4vX1Jvd1NlbGVjdGlvbi5zdmVsdGUnO1xuICBpbXBvcnQgUGFnaW5hdGlvbiBmcm9tICcuL19QYWdpbmF0aW9uLnN2ZWx0ZSc7XG4gIGltcG9ydCBTb3J0YWJsZSBmcm9tICcuL19Tb3J0YWJsZS5zdmVsdGUnO1xuPC9zY3JpcHQ+XG4iXSwibmFtZXMiOlsiUGFnaW5hdGlvbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt3QkNjRyxHQUFJLElBQUMsRUFBRTs7Ozs7Ozs7Ozs7Ozs7OERB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Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztjQzNDYixLQUFLOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7d0JBTUosR0FBSSxJQUFDLEVBQUU7Ozs7Ozs7Ozs7Ozs7OzhEQUFQLEdBQUksSUFBQyxFQUFFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt3QkFDZixHQUFJLElBQUMsSUFBSTs7Ozs7Ozs7Ozs7Ozs7OERBQVQsR0FBSSxJQUFDLElB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
