import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, a7 as create_slot, $ as assign, W as compute_rest_props, v as validate_slots, Y as get_current_component, Z as setContext, a0 as exclude_internal_props, p as element, x as claim_element, y as children, u as detach_dev, a9 as set_attributes, D as add_location, F as insert_dev, G as append_dev, aa as action_destroyer, a8 as update_slot, a2 as get_spread_update, ab as is_function, J as transition_in, K as transition_out, ac as run_all, a6 as binding_callbacks, L as List, I as Item, aS as Separator, T as Text, q as create_component, o as space, t as text, A as claim_component, w as claim_space, z as claim_text, E as attr_dev, H as mount_component, aw as set_data_dev, M as destroy_component, B as set_style, ak as bind, P as PrimaryText, l as SecondaryText, aF as globals, al as add_flush_callback, ag as validate_each_argument, a1 as empty, a4 as group_outros, a5 as check_outros, aj as destroy_each, O as noop, r as query_selector_all } from './client.ec94238b.js';
import { D as Demo } from './Demo.9c515360.js';
import { c as classMap, f as forwardEventsBuilder, u as useActions, M as Menu$1, S as SelectionGroupIcon } from './SelectionGroupIcon.cb410e51.js';
import { B as Button_1 } from './Button.d66ce348.js';
import { A as Anchor } from './Anchor.88237b9f.js';

function exclude(obj, keys) {
  let names = Object.getOwnPropertyNames(obj);
  const newObj = {};

  for (let i = 0; i < names.length; i++) {
    const name = names[i];
    const cashIndex = name.indexOf('$');
    if (
      cashIndex !== -1 &&
      keys.indexOf(name.substring(0, cashIndex + 1)) !== -1
    ) {
      continue;
    }
    if (keys.indexOf(name) !== -1) {
      continue;
    }
    newObj[name] = obj[name];
  }

  return newObj;
}

function prefixFilter(obj, prefix) {
  let names = Object.getOwnPropertyNames(obj);
  const newObj = {};

  for (let i = 0; i < names.length; i++) {
    const name = names[i];
    if (name.substring(0, prefix.length) === prefix) {
      newObj[name.substring(prefix.length)] = obj[name];
    }
  }

  return newObj;
}

/* packages/menu/SelectionGroup.svelte generated by Svelte v3.37.0 */

const file$5 = "packages/menu/SelectionGroup.svelte";

function create_fragment$5(ctx) {
	let li;
	let ul;
	let ul_class_value;
	let useActions_action;
	let useActions_action_1;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[8].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);

	let ul_levels = [
		{
			class: ul_class_value = classMap({
				[/*list$class*/ ctx[2]]: true,
				"mdc-menu__selection-group": true
			})
		},
		prefixFilter(/*$$restProps*/ ctx[5], "list$")
	];

	let ul_data = {};

	for (let i = 0; i < ul_levels.length; i += 1) {
		ul_data = assign(ul_data, ul_levels[i]);
	}

	let li_levels = [exclude(/*$$restProps*/ ctx[5], ["list$"])];
	let li_data = {};

	for (let i = 0; i < li_levels.length; i += 1) {
		li_data = assign(li_data, li_levels[i]);
	}

	const block = {
		c: function create() {
			li = element("li");
			ul = element("ul");
			if (default_slot) default_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			li = claim_element(nodes, "LI", {});
			var li_nodes = children(li);
			ul = claim_element(li_nodes, "UL", { class: true });
			var ul_nodes = children(ul);
			if (default_slot) default_slot.l(ul_nodes);
			ul_nodes.forEach(detach_dev);
			li_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_attributes(ul, ul_data);
			add_location(ul, file$5, 6, 2, 112);
			set_attributes(li, li_data);
			add_location(li, file$5, 0, 0, 0);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			append_dev(li, ul);

			if (default_slot) {
				default_slot.m(ul, null);
			}

			/*li_binding*/ ctx[9](li);
			current = true;

			if (!mounted) {
				dispose = [
					action_destroyer(useActions_action = useActions.call(null, ul, /*list$use*/ ctx[1])),
					action_destroyer(useActions_action_1 = useActions.call(null, li, /*use*/ ctx[0])),
					action_destroyer(/*forwardEvents*/ ctx[4].call(null, li))
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 128) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[7], dirty, null, null);
				}
			}

			set_attributes(ul, ul_data = get_spread_update(ul_levels, [
				(!current || dirty & /*list$class*/ 4 && ul_class_value !== (ul_class_value = classMap({
					[/*list$class*/ ctx[2]]: true,
					"mdc-menu__selection-group": true
				}))) && { class: ul_class_value },
				dirty & /*$$restProps*/ 32 && prefixFilter(/*$$restProps*/ ctx[5], "list$")
			]));

			if (useActions_action && is_function(useActions_action.update) && dirty & /*list$use*/ 2) useActions_action.update.call(null, /*list$use*/ ctx[1]);
			set_attributes(li, li_data = get_spread_update(li_levels, [dirty & /*$$restProps*/ 32 && exclude(/*$$restProps*/ ctx[5], ["list$"])]));
			if (useActions_action_1 && is_function(useActions_action_1.update) && dirty & /*use*/ 1) useActions_action_1.update.call(null, /*use*/ ctx[0]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			if (default_slot) default_slot.d(detaching);
			/*li_binding*/ ctx[9](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$5.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$5($$self, $$props, $$invalidate) {
	const omit_props_names = ["use","list$use","list$class","getElement"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("SelectionGroup", slots, ['default']);
	const forwardEvents = forwardEventsBuilder(get_current_component());
	let { use = [] } = $$props;
	let { list$use = [] } = $$props;
	let { list$class = "" } = $$props;
	let element;
	setContext("SMUI:list:graphic:menu-selection-group", true);

	function getElement() {
		return element;
	}

	function li_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			element = $$value;
			$$invalidate(3, element);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("use" in $$new_props) $$invalidate(0, use = $$new_props.use);
		if ("list$use" in $$new_props) $$invalidate(1, list$use = $$new_props.list$use);
		if ("list$class" in $$new_props) $$invalidate(2, list$class = $$new_props.list$class);
		if ("$$scope" in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		setContext,
		get_current_component,
		forwardEventsBuilder,
		classMap,
		exclude,
		prefixFilter,
		useActions,
		forwardEvents,
		use,
		list$use,
		list$class,
		element,
		getElement
	});

	$$self.$inject_state = $$new_props => {
		if ("use" in $$props) $$invalidate(0, use = $$new_props.use);
		if ("list$use" in $$props) $$invalidate(1, list$use = $$new_props.list$use);
		if ("list$class" in $$props) $$invalidate(2, list$class = $$new_props.list$class);
		if ("element" in $$props) $$invalidate(3, element = $$new_props.element);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		use,
		list$use,
		list$class,
		element,
		forwardEvents,
		$$restProps,
		getElement,
		$$scope,
		slots,
		li_binding
	];
}

class SelectionGroup extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$5, create_fragment$5, safe_not_equal, {
			use: 0,
			list$use: 1,
			list$class: 2,
			getElement: 6
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "SelectionGroup",
			options,
			id: create_fragment$5.name
		});
	}

	get use() {
		throw new Error("<SelectionGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set use(value) {
		throw new Error("<SelectionGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get list$use() {
		throw new Error("<SelectionGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set list$use(value) {
		throw new Error("<SelectionGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get list$class() {
		throw new Error("<SelectionGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set list$class(value) {
		throw new Error("<SelectionGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get getElement() {
		return this.$$.ctx[6];
	}

	set getElement(value) {
		throw new Error("<SelectionGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/demo/menu/_Static.svelte generated by Svelte v3.37.0 */
const file$4 = "src/routes/demo/menu/_Static.svelte";

// (4:6) <Text>
function create_default_slot_9$3(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Cut");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Cut");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_9$3.name,
		type: "slot",
		source: "(4:6) <Text>",
		ctx
	});

	return block;
}

// (3:4) <Item on:SMUI:action={() => (clicked = 'Cut')}>
function create_default_slot_8$3(ctx) {
	let text_1;
	let current;

	text_1 = new Text({
			props: {
				$$slots: { default: [create_default_slot_9$3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(text_1.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(text_1.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(text_1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const text_1_changes = {};

			if (dirty & /*$$scope*/ 32) {
				text_1_changes.$$scope = { dirty, ctx };
			}

			text_1.$set(text_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(text_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(text_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(text_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_8$3.name,
		type: "slot",
		source: "(3:4) <Item on:SMUI:action={() => (clicked = 'Cut')}>",
		ctx
	});

	return block;
}

// (7:6) <Text>
function create_default_slot_7$3(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Copy");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Copy");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_7$3.name,
		type: "slot",
		source: "(7:6) <Text>",
		ctx
	});

	return block;
}

// (6:4) <Item on:SMUI:action={() => (clicked = 'Copy')}>
function create_default_slot_6$3(ctx) {
	let text_1;
	let current;

	text_1 = new Text({
			props: {
				$$slots: { default: [create_default_slot_7$3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(text_1.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(text_1.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(text_1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const text_1_changes = {};

			if (dirty & /*$$scope*/ 32) {
				text_1_changes.$$scope = { dirty, ctx };
			}

			text_1.$set(text_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(text_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(text_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(text_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_6$3.name,
		type: "slot",
		source: "(6:4) <Item on:SMUI:action={() => (clicked = 'Copy')}>",
		ctx
	});

	return block;
}

// (10:6) <Text>
function create_default_slot_5$3(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Paste");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Paste");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_5$3.name,
		type: "slot",
		source: "(10:6) <Text>",
		ctx
	});

	return block;
}

// (9:4) <Item on:SMUI:action={() => (clicked = 'Paste')}>
function create_default_slot_4$3(ctx) {
	let text_1;
	let current;

	text_1 = new Text({
			props: {
				$$slots: { default: [create_default_slot_5$3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(text_1.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(text_1.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(text_1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const text_1_changes = {};

			if (dirty & /*$$scope*/ 32) {
				text_1_changes.$$scope = { dirty, ctx };
			}

			text_1.$set(text_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(text_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(text_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(text_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_4$3.name,
		type: "slot",
		source: "(9:4) <Item on:SMUI:action={() => (clicked = 'Paste')}>",
		ctx
	});

	return block;
}

// (14:6) <Text>
function create_default_slot_3$3(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Delete");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Delete");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3$3.name,
		type: "slot",
		source: "(14:6) <Text>",
		ctx
	});

	return block;
}

// (13:4) <Item on:SMUI:action={() => (clicked = 'Delete')}>
function create_default_slot_2$4(ctx) {
	let text_1;
	let current;

	text_1 = new Text({
			props: {
				$$slots: { default: [create_default_slot_3$3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(text_1.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(text_1.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(text_1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const text_1_changes = {};

			if (dirty & /*$$scope*/ 32) {
				text_1_changes.$$scope = { dirty, ctx };
			}

			text_1.$set(text_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(text_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(text_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(text_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2$4.name,
		type: "slot",
		source: "(13:4) <Item on:SMUI:action={() => (clicked = 'Delete')}>",
		ctx
	});

	return block;
}

// (2:2) <List>
function create_default_slot_1$4(ctx) {
	let item0;
	let t0;
	let item1;
	let t1;
	let item2;
	let t2;
	let separator;
	let t3;
	let item3;
	let current;

	item0 = new Item({
			props: {
				$$slots: { default: [create_default_slot_8$3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	item0.$on("SMUI:action", /*SMUI_action_handler*/ ctx[1]);

	item1 = new Item({
			props: {
				$$slots: { default: [create_default_slot_6$3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	item1.$on("SMUI:action", /*SMUI_action_handler_1*/ ctx[2]);

	item2 = new Item({
			props: {
				$$slots: { default: [create_default_slot_4$3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	item2.$on("SMUI:action", /*SMUI_action_handler_2*/ ctx[3]);
	separator = new Separator({ $$inline: true });

	item3 = new Item({
			props: {
				$$slots: { default: [create_default_slot_2$4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	item3.$on("SMUI:action", /*SMUI_action_handler_3*/ ctx[4]);

	const block = {
		c: function create() {
			create_component(item0.$$.fragment);
			t0 = space();
			create_component(item1.$$.fragment);
			t1 = space();
			create_component(item2.$$.fragment);
			t2 = space();
			create_component(separator.$$.fragment);
			t3 = space();
			create_component(item3.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(item0.$$.fragment, nodes);
			t0 = claim_space(nodes);
			claim_component(item1.$$.fragment, nodes);
			t1 = claim_space(nodes);
			claim_component(item2.$$.fragment, nodes);
			t2 = claim_space(nodes);
			claim_component(separator.$$.fragment, nodes);
			t3 = claim_space(nodes);
			claim_component(item3.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(item0, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(item1, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(item2, target, anchor);
			insert_dev(target, t2, anchor);
			mount_component(separator, target, anchor);
			insert_dev(target, t3, anchor);
			mount_component(item3, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const item0_changes = {};

			if (dirty & /*$$scope*/ 32) {
				item0_changes.$$scope = { dirty, ctx };
			}

			item0.$set(item0_changes);
			const item1_changes = {};

			if (dirty & /*$$scope*/ 32) {
				item1_changes.$$scope = { dirty, ctx };
			}

			item1.$set(item1_changes);
			const item2_changes = {};

			if (dirty & /*$$scope*/ 32) {
				item2_changes.$$scope = { dirty, ctx };
			}

			item2.$set(item2_changes);
			const item3_changes = {};

			if (dirty & /*$$scope*/ 32) {
				item3_changes.$$scope = { dirty, ctx };
			}

			item3.$set(item3_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(item0.$$.fragment, local);
			transition_in(item1.$$.fragment, local);
			transition_in(item2.$$.fragment, local);
			transition_in(separator.$$.fragment, local);
			transition_in(item3.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(item0.$$.fragment, local);
			transition_out(item1.$$.fragment, local);
			transition_out(item2.$$.fragment, local);
			transition_out(separator.$$.fragment, local);
			transition_out(item3.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(item0, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(item1, detaching);
			if (detaching) detach_dev(t1);
			destroy_component(item2, detaching);
			if (detaching) detach_dev(t2);
			destroy_component(separator, detaching);
			if (detaching) detach_dev(t3);
			destroy_component(item3, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$4.name,
		type: "slot",
		source: "(2:2) <List>",
		ctx
	});

	return block;
}

// (1:0) <Menu static>
function create_default_slot$4(ctx) {
	let list;
	let current;

	list = new List({
			props: {
				$$slots: { default: [create_default_slot_1$4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(list.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(list.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(list, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const list_changes = {};

			if (dirty & /*$$scope, clicked*/ 33) {
				list_changes.$$scope = { dirty, ctx };
			}

			list.$set(list_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(list.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(list.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(list, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$4.name,
		type: "slot",
		source: "(1:0) <Menu static>",
		ctx
	});

	return block;
}

function create_fragment$4(ctx) {
	let menu;
	let t0;
	let pre;
	let t1;
	let t2;
	let current;

	menu = new Menu$1({
			props: {
				static: true,
				$$slots: { default: [create_default_slot$4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(menu.$$.fragment);
			t0 = space();
			pre = element("pre");
			t1 = text("Clicked: ");
			t2 = text(/*clicked*/ ctx[0]);
			this.h();
		},
		l: function claim(nodes) {
			claim_component(menu.$$.fragment, nodes);
			t0 = claim_space(nodes);
			pre = claim_element(nodes, "PRE", { class: true });
			var pre_nodes = children(pre);
			t1 = claim_text(pre_nodes, "Clicked: ");
			t2 = claim_text(pre_nodes, /*clicked*/ ctx[0]);
			pre_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(pre, "class", "status");
			add_location(pre, file$4, 18, 0, 420);
		},
		m: function mount(target, anchor) {
			mount_component(menu, target, anchor);
			insert_dev(target, t0, anchor);
			insert_dev(target, pre, anchor);
			append_dev(pre, t1);
			append_dev(pre, t2);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const menu_changes = {};

			if (dirty & /*$$scope, clicked*/ 33) {
				menu_changes.$$scope = { dirty, ctx };
			}

			menu.$set(menu_changes);
			if (!current || dirty & /*clicked*/ 1) set_data_dev(t2, /*clicked*/ ctx[0]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(menu.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(menu.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(menu, detaching);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(pre);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Static", slots, []);
	let clicked = "nothing yet";
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Static> was created with unknown prop '${key}'`);
	});

	const SMUI_action_handler = () => $$invalidate(0, clicked = "Cut");
	const SMUI_action_handler_1 = () => $$invalidate(0, clicked = "Copy");
	const SMUI_action_handler_2 = () => $$invalidate(0, clicked = "Paste");
	const SMUI_action_handler_3 = () => $$invalidate(0, clicked = "Delete");

	$$self.$capture_state = () => ({
		Menu: Menu$1,
		List,
		Item,
		Separator,
		Text,
		clicked
	});

	$$self.$inject_state = $$props => {
		if ("clicked" in $$props) $$invalidate(0, clicked = $$props.clicked);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		clicked,
		SMUI_action_handler,
		SMUI_action_handler_1,
		SMUI_action_handler_2,
		SMUI_action_handler_3
	];
}

class Static extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4, create_fragment$4, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Static",
			options,
			id: create_fragment$4.name
		});
	}
}

/* src/routes/demo/menu/_Anchored.svelte generated by Svelte v3.37.0 */
const file$3 = "src/routes/demo/menu/_Anchored.svelte";

// (2:2) <Button on:click={() => menu.setOpen(true)}>
function create_default_slot_10$2(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Open Menu");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Open Menu");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_10$2.name,
		type: "slot",
		source: "(2:2) <Button on:click={() => menu.setOpen(true)}>",
		ctx
	});

	return block;
}

// (6:8) <Text>
function create_default_slot_9$2(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Cut");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Cut");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_9$2.name,
		type: "slot",
		source: "(6:8) <Text>",
		ctx
	});

	return block;
}

// (5:6) <Item on:SMUI:action={() => (clicked = 'Cut')}>
function create_default_slot_8$2(ctx) {
	let text_1;
	let current;

	text_1 = new Text({
			props: {
				$$slots: { default: [create_default_slot_9$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(text_1.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(text_1.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(text_1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const text_1_changes = {};

			if (dirty & /*$$scope*/ 256) {
				text_1_changes.$$scope = { dirty, ctx };
			}

			text_1.$set(text_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(text_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(text_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(text_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_8$2.name,
		type: "slot",
		source: "(5:6) <Item on:SMUI:action={() => (clicked = 'Cut')}>",
		ctx
	});

	return block;
}

// (9:8) <Text>
function create_default_slot_7$2(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Copy");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Copy");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_7$2.name,
		type: "slot",
		source: "(9:8) <Text>",
		ctx
	});

	return block;
}

// (8:6) <Item on:SMUI:action={() => (clicked = 'Copy')}>
function create_default_slot_6$2(ctx) {
	let text_1;
	let current;

	text_1 = new Text({
			props: {
				$$slots: { default: [create_default_slot_7$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(text_1.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(text_1.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(text_1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const text_1_changes = {};

			if (dirty & /*$$scope*/ 256) {
				text_1_changes.$$scope = { dirty, ctx };
			}

			text_1.$set(text_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(text_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(text_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(text_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_6$2.name,
		type: "slot",
		source: "(8:6) <Item on:SMUI:action={() => (clicked = 'Copy')}>",
		ctx
	});

	return block;
}

// (12:8) <Text>
function create_default_slot_5$2(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Paste");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Paste");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_5$2.name,
		type: "slot",
		source: "(12:8) <Text>",
		ctx
	});

	return block;
}

// (11:6) <Item on:SMUI:action={() => (clicked = 'Paste')}>
function create_default_slot_4$2(ctx) {
	let text_1;
	let current;

	text_1 = new Text({
			props: {
				$$slots: { default: [create_default_slot_5$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(text_1.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(text_1.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(text_1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const text_1_changes = {};

			if (dirty & /*$$scope*/ 256) {
				text_1_changes.$$scope = { dirty, ctx };
			}

			text_1.$set(text_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(text_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(text_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(text_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_4$2.name,
		type: "slot",
		source: "(11:6) <Item on:SMUI:action={() => (clicked = 'Paste')}>",
		ctx
	});

	return block;
}

// (16:8) <Text>
function create_default_slot_3$2(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Delete");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Delete");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3$2.name,
		type: "slot",
		source: "(16:8) <Text>",
		ctx
	});

	return block;
}

// (15:6) <Item on:SMUI:action={() => (clicked = 'Delete')}>
function create_default_slot_2$3(ctx) {
	let text_1;
	let current;

	text_1 = new Text({
			props: {
				$$slots: { default: [create_default_slot_3$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(text_1.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(text_1.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(text_1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const text_1_changes = {};

			if (dirty & /*$$scope*/ 256) {
				text_1_changes.$$scope = { dirty, ctx };
			}

			text_1.$set(text_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(text_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(text_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(text_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2$3.name,
		type: "slot",
		source: "(15:6) <Item on:SMUI:action={() => (clicked = 'Delete')}>",
		ctx
	});

	return block;
}

// (4:4) <List>
function create_default_slot_1$3(ctx) {
	let item0;
	let t0;
	let item1;
	let t1;
	let item2;
	let t2;
	let separator;
	let t3;
	let item3;
	let current;

	item0 = new Item({
			props: {
				$$slots: { default: [create_default_slot_8$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	item0.$on("SMUI:action", /*SMUI_action_handler*/ ctx[3]);

	item1 = new Item({
			props: {
				$$slots: { default: [create_default_slot_6$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	item1.$on("SMUI:action", /*SMUI_action_handler_1*/ ctx[4]);

	item2 = new Item({
			props: {
				$$slots: { default: [create_default_slot_4$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	item2.$on("SMUI:action", /*SMUI_action_handler_2*/ ctx[5]);
	separator = new Separator({ $$inline: true });

	item3 = new Item({
			props: {
				$$slots: { default: [create_default_slot_2$3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	item3.$on("SMUI:action", /*SMUI_action_handler_3*/ ctx[6]);

	const block = {
		c: function create() {
			create_component(item0.$$.fragment);
			t0 = space();
			create_component(item1.$$.fragment);
			t1 = space();
			create_component(item2.$$.fragment);
			t2 = space();
			create_component(separator.$$.fragment);
			t3 = space();
			create_component(item3.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(item0.$$.fragment, nodes);
			t0 = claim_space(nodes);
			claim_component(item1.$$.fragment, nodes);
			t1 = claim_space(nodes);
			claim_component(item2.$$.fragment, nodes);
			t2 = claim_space(nodes);
			claim_component(separator.$$.fragment, nodes);
			t3 = claim_space(nodes);
			claim_component(item3.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(item0, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(item1, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(item2, target, anchor);
			insert_dev(target, t2, anchor);
			mount_component(separator, target, anchor);
			insert_dev(target, t3, anchor);
			mount_component(item3, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const item0_changes = {};

			if (dirty & /*$$scope*/ 256) {
				item0_changes.$$scope = { dirty, ctx };
			}

			item0.$set(item0_changes);
			const item1_changes = {};

			if (dirty & /*$$scope*/ 256) {
				item1_changes.$$scope = { dirty, ctx };
			}

			item1.$set(item1_changes);
			const item2_changes = {};

			if (dirty & /*$$scope*/ 256) {
				item2_changes.$$scope = { dirty, ctx };
			}

			item2.$set(item2_changes);
			const item3_changes = {};

			if (dirty & /*$$scope*/ 256) {
				item3_changes.$$scope = { dirty, ctx };
			}

			item3.$set(item3_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(item0.$$.fragment, local);
			transition_in(item1.$$.fragment, local);
			transition_in(item2.$$.fragment, local);
			transition_in(separator.$$.fragment, local);
			transition_in(item3.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(item0.$$.fragment, local);
			transition_out(item1.$$.fragment, local);
			transition_out(item2.$$.fragment, local);
			transition_out(separator.$$.fragment, local);
			transition_out(item3.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(item0, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(item1, detaching);
			if (detaching) detach_dev(t1);
			destroy_component(item2, detaching);
			if (detaching) detach_dev(t2);
			destroy_component(separator, detaching);
			if (detaching) detach_dev(t3);
			destroy_component(item3, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$3.name,
		type: "slot",
		source: "(4:4) <List>",
		ctx
	});

	return block;
}

// (3:2) <Menu bind:this={menu}>
function create_default_slot$3(ctx) {
	let list;
	let current;

	list = new List({
			props: {
				$$slots: { default: [create_default_slot_1$3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(list.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(list.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(list, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const list_changes = {};

			if (dirty & /*$$scope, clicked*/ 258) {
				list_changes.$$scope = { dirty, ctx };
			}

			list.$set(list_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(list.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(list.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(list, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$3.name,
		type: "slot",
		source: "(3:2) <Menu bind:this={menu}>",
		ctx
	});

	return block;
}

function create_fragment$3(ctx) {
	let div;
	let button;
	let t0;
	let menu_1;
	let t1;
	let pre;
	let t2;
	let t3;
	let current;

	button = new Button_1({
			props: {
				$$slots: { default: [create_default_slot_10$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button.$on("click", /*click_handler*/ ctx[2]);

	let menu_1_props = {
		$$slots: { default: [create_default_slot$3] },
		$$scope: { ctx }
	};

	menu_1 = new Menu$1({ props: menu_1_props, $$inline: true });
	/*menu_1_binding*/ ctx[7](menu_1);

	const block = {
		c: function create() {
			div = element("div");
			create_component(button.$$.fragment);
			t0 = space();
			create_component(menu_1.$$.fragment);
			t1 = space();
			pre = element("pre");
			t2 = text("Clicked: ");
			t3 = text(/*clicked*/ ctx[1]);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { style: true });
			var div_nodes = children(div);
			claim_component(button.$$.fragment, div_nodes);
			t0 = claim_space(div_nodes);
			claim_component(menu_1.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			pre = claim_element(nodes, "PRE", { class: true });
			var pre_nodes = children(pre);
			t2 = claim_text(pre_nodes, "Clicked: ");
			t3 = claim_text(pre_nodes, /*clicked*/ ctx[1]);
			pre_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_style(div, "min-width", "100px");
			add_location(div, file$3, 0, 0, 0);
			attr_dev(pre, "class", "status");
			add_location(pre, file$3, 21, 0, 568);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(button, div, null);
			append_dev(div, t0);
			mount_component(menu_1, div, null);
			insert_dev(target, t1, anchor);
			insert_dev(target, pre, anchor);
			append_dev(pre, t2);
			append_dev(pre, t3);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const button_changes = {};

			if (dirty & /*$$scope*/ 256) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
			const menu_1_changes = {};

			if (dirty & /*$$scope, clicked*/ 258) {
				menu_1_changes.$$scope = { dirty, ctx };
			}

			menu_1.$set(menu_1_changes);
			if (!current || dirty & /*clicked*/ 2) set_data_dev(t3, /*clicked*/ ctx[1]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			transition_in(menu_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button.$$.fragment, local);
			transition_out(menu_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(button);
			/*menu_1_binding*/ ctx[7](null);
			destroy_component(menu_1);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(pre);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Anchored", slots, []);
	let menu;
	let clicked = "nothing yet";
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Anchored> was created with unknown prop '${key}'`);
	});

	const click_handler = () => menu.setOpen(true);
	const SMUI_action_handler = () => $$invalidate(1, clicked = "Cut");
	const SMUI_action_handler_1 = () => $$invalidate(1, clicked = "Copy");
	const SMUI_action_handler_2 = () => $$invalidate(1, clicked = "Paste");
	const SMUI_action_handler_3 = () => $$invalidate(1, clicked = "Delete");

	function menu_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			menu = $$value;
			$$invalidate(0, menu);
		});
	}

	$$self.$capture_state = () => ({
		Menu: Menu$1,
		List,
		Item,
		Separator,
		Text,
		Button: Button_1,
		menu,
		clicked
	});

	$$self.$inject_state = $$props => {
		if ("menu" in $$props) $$invalidate(0, menu = $$props.menu);
		if ("clicked" in $$props) $$invalidate(1, clicked = $$props.clicked);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		menu,
		clicked,
		click_handler,
		SMUI_action_handler,
		SMUI_action_handler_1,
		SMUI_action_handler_2,
		SMUI_action_handler_3,
		menu_1_binding
	];
}

class Anchored extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3, create_fragment$3, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Anchored",
			options,
			id: create_fragment$3.name
		});
	}
}

/* src/routes/demo/menu/_TwoLineManunalAnchor.svelte generated by Svelte v3.37.0 */

const { Object: Object_1 } = globals;
const file$2 = "src/routes/demo/menu/_TwoLineManunalAnchor.svelte";

// (18:2) <Button on:click={() => menu.setOpen(true)}>
function create_default_slot_18(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Open Menu");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Open Menu");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_18.name,
		type: "slot",
		source: "(18:2) <Button on:click={() => menu.setOpen(true)}>",
		ctx
	});

	return block;
}

// (28:10) <PrimaryText>
function create_default_slot_17(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Cut");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Cut");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_17.name,
		type: "slot",
		source: "(28:10) <PrimaryText>",
		ctx
	});

	return block;
}

// (29:10) <SecondaryText>
function create_default_slot_16(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Copy to clipboard and remove.");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Copy to clipboard and remove.");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_16.name,
		type: "slot",
		source: "(29:10) <SecondaryText>",
		ctx
	});

	return block;
}

// (27:8) <Text>
function create_default_slot_15(ctx) {
	let primarytext;
	let t;
	let secondarytext;
	let current;

	primarytext = new PrimaryText({
			props: {
				$$slots: { default: [create_default_slot_17] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	secondarytext = new SecondaryText({
			props: {
				$$slots: { default: [create_default_slot_16] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(primarytext.$$.fragment);
			t = space();
			create_component(secondarytext.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(primarytext.$$.fragment, nodes);
			t = claim_space(nodes);
			claim_component(secondarytext.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(primarytext, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(secondarytext, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const primarytext_changes = {};

			if (dirty & /*$$scope*/ 16384) {
				primarytext_changes.$$scope = { dirty, ctx };
			}

			primarytext.$set(primarytext_changes);
			const secondarytext_changes = {};

			if (dirty & /*$$scope*/ 16384) {
				secondarytext_changes.$$scope = { dirty, ctx };
			}

			secondarytext.$set(secondarytext_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(primarytext.$$.fragment, local);
			transition_in(secondarytext.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(primarytext.$$.fragment, local);
			transition_out(secondarytext.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(primarytext, detaching);
			if (detaching) detach_dev(t);
			destroy_component(secondarytext, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_15.name,
		type: "slot",
		source: "(27:8) <Text>",
		ctx
	});

	return block;
}

// (26:6) <Item on:SMUI:action={() => (clicked = 'Cut')}>
function create_default_slot_14(ctx) {
	let text_1;
	let current;

	text_1 = new Text({
			props: {
				$$slots: { default: [create_default_slot_15] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(text_1.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(text_1.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(text_1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const text_1_changes = {};

			if (dirty & /*$$scope*/ 16384) {
				text_1_changes.$$scope = { dirty, ctx };
			}

			text_1.$set(text_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(text_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(text_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(text_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_14.name,
		type: "slot",
		source: "(26:6) <Item on:SMUI:action={() => (clicked = 'Cut')}>",
		ctx
	});

	return block;
}

// (34:10) <PrimaryText>
function create_default_slot_13(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Copy");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Copy");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_13.name,
		type: "slot",
		source: "(34:10) <PrimaryText>",
		ctx
	});

	return block;
}

// (35:10) <SecondaryText>
function create_default_slot_12$1(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Copy to clipboard.");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Copy to clipboard.");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_12$1.name,
		type: "slot",
		source: "(35:10) <SecondaryText>",
		ctx
	});

	return block;
}

// (33:8) <Text>
function create_default_slot_11$1(ctx) {
	let primarytext;
	let t;
	let secondarytext;
	let current;

	primarytext = new PrimaryText({
			props: {
				$$slots: { default: [create_default_slot_13] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	secondarytext = new SecondaryText({
			props: {
				$$slots: { default: [create_default_slot_12$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(primarytext.$$.fragment);
			t = space();
			create_component(secondarytext.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(primarytext.$$.fragment, nodes);
			t = claim_space(nodes);
			claim_component(secondarytext.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(primarytext, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(secondarytext, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const primarytext_changes = {};

			if (dirty & /*$$scope*/ 16384) {
				primarytext_changes.$$scope = { dirty, ctx };
			}

			primarytext.$set(primarytext_changes);
			const secondarytext_changes = {};

			if (dirty & /*$$scope*/ 16384) {
				secondarytext_changes.$$scope = { dirty, ctx };
			}

			secondarytext.$set(secondarytext_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(primarytext.$$.fragment, local);
			transition_in(secondarytext.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(primarytext.$$.fragment, local);
			transition_out(secondarytext.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(primarytext, detaching);
			if (detaching) detach_dev(t);
			destroy_component(secondarytext, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_11$1.name,
		type: "slot",
		source: "(33:8) <Text>",
		ctx
	});

	return block;
}

// (32:6) <Item on:SMUI:action={() => (clicked = 'Copy')}>
function create_default_slot_10$1(ctx) {
	let text_1;
	let current;

	text_1 = new Text({
			props: {
				$$slots: { default: [create_default_slot_11$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(text_1.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(text_1.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(text_1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const text_1_changes = {};

			if (dirty & /*$$scope*/ 16384) {
				text_1_changes.$$scope = { dirty, ctx };
			}

			text_1.$set(text_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(text_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(text_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(text_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_10$1.name,
		type: "slot",
		source: "(32:6) <Item on:SMUI:action={() => (clicked = 'Copy')}>",
		ctx
	});

	return block;
}

// (40:10) <PrimaryText>
function create_default_slot_9$1(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Paste");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Paste");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_9$1.name,
		type: "slot",
		source: "(40:10) <PrimaryText>",
		ctx
	});

	return block;
}

// (41:10) <SecondaryText>
function create_default_slot_8$1(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Paste from clipboard.");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Paste from clipboard.");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_8$1.name,
		type: "slot",
		source: "(41:10) <SecondaryText>",
		ctx
	});

	return block;
}

// (39:8) <Text>
function create_default_slot_7$1(ctx) {
	let primarytext;
	let t;
	let secondarytext;
	let current;

	primarytext = new PrimaryText({
			props: {
				$$slots: { default: [create_default_slot_9$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	secondarytext = new SecondaryText({
			props: {
				$$slots: { default: [create_default_slot_8$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(primarytext.$$.fragment);
			t = space();
			create_component(secondarytext.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(primarytext.$$.fragment, nodes);
			t = claim_space(nodes);
			claim_component(secondarytext.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(primarytext, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(secondarytext, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const primarytext_changes = {};

			if (dirty & /*$$scope*/ 16384) {
				primarytext_changes.$$scope = { dirty, ctx };
			}

			primarytext.$set(primarytext_changes);
			const secondarytext_changes = {};

			if (dirty & /*$$scope*/ 16384) {
				secondarytext_changes.$$scope = { dirty, ctx };
			}

			secondarytext.$set(secondarytext_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(primarytext.$$.fragment, local);
			transition_in(secondarytext.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(primarytext.$$.fragment, local);
			transition_out(secondarytext.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(primarytext, detaching);
			if (detaching) detach_dev(t);
			destroy_component(secondarytext, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_7$1.name,
		type: "slot",
		source: "(39:8) <Text>",
		ctx
	});

	return block;
}

// (38:6) <Item on:SMUI:action={() => (clicked = 'Paste')}>
function create_default_slot_6$1(ctx) {
	let text_1;
	let current;

	text_1 = new Text({
			props: {
				$$slots: { default: [create_default_slot_7$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(text_1.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(text_1.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(text_1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const text_1_changes = {};

			if (dirty & /*$$scope*/ 16384) {
				text_1_changes.$$scope = { dirty, ctx };
			}

			text_1.$set(text_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(text_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(text_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(text_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_6$1.name,
		type: "slot",
		source: "(38:6) <Item on:SMUI:action={() => (clicked = 'Paste')}>",
		ctx
	});

	return block;
}

// (47:10) <PrimaryText>
function create_default_slot_5$1(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Delete");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Delete");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_5$1.name,
		type: "slot",
		source: "(47:10) <PrimaryText>",
		ctx
	});

	return block;
}

// (48:10) <SecondaryText>
function create_default_slot_4$1(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Remove item.");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Remove item.");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_4$1.name,
		type: "slot",
		source: "(48:10) <SecondaryText>",
		ctx
	});

	return block;
}

// (46:8) <Text>
function create_default_slot_3$1(ctx) {
	let primarytext;
	let t;
	let secondarytext;
	let current;

	primarytext = new PrimaryText({
			props: {
				$$slots: { default: [create_default_slot_5$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	secondarytext = new SecondaryText({
			props: {
				$$slots: { default: [create_default_slot_4$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(primarytext.$$.fragment);
			t = space();
			create_component(secondarytext.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(primarytext.$$.fragment, nodes);
			t = claim_space(nodes);
			claim_component(secondarytext.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(primarytext, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(secondarytext, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const primarytext_changes = {};

			if (dirty & /*$$scope*/ 16384) {
				primarytext_changes.$$scope = { dirty, ctx };
			}

			primarytext.$set(primarytext_changes);
			const secondarytext_changes = {};

			if (dirty & /*$$scope*/ 16384) {
				secondarytext_changes.$$scope = { dirty, ctx };
			}

			secondarytext.$set(secondarytext_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(primarytext.$$.fragment, local);
			transition_in(secondarytext.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(primarytext.$$.fragment, local);
			transition_out(secondarytext.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(primarytext, detaching);
			if (detaching) detach_dev(t);
			destroy_component(secondarytext, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3$1.name,
		type: "slot",
		source: "(46:8) <Text>",
		ctx
	});

	return block;
}

// (45:6) <Item on:SMUI:action={() => (clicked = 'Delete')}>
function create_default_slot_2$2(ctx) {
	let text_1;
	let current;

	text_1 = new Text({
			props: {
				$$slots: { default: [create_default_slot_3$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(text_1.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(text_1.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(text_1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const text_1_changes = {};

			if (dirty & /*$$scope*/ 16384) {
				text_1_changes.$$scope = { dirty, ctx };
			}

			text_1.$set(text_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(text_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(text_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(text_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2$2.name,
		type: "slot",
		source: "(45:6) <Item on:SMUI:action={() => (clicked = 'Delete')}>",
		ctx
	});

	return block;
}

// (25:4) <List twoLine>
function create_default_slot_1$2(ctx) {
	let item0;
	let t0;
	let item1;
	let t1;
	let item2;
	let t2;
	let separator;
	let t3;
	let item3;
	let current;

	item0 = new Item({
			props: {
				$$slots: { default: [create_default_slot_14] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	item0.$on("SMUI:action", /*SMUI_action_handler*/ ctx[5]);

	item1 = new Item({
			props: {
				$$slots: { default: [create_default_slot_10$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	item1.$on("SMUI:action", /*SMUI_action_handler_1*/ ctx[6]);

	item2 = new Item({
			props: {
				$$slots: { default: [create_default_slot_6$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	item2.$on("SMUI:action", /*SMUI_action_handler_2*/ ctx[7]);
	separator = new Separator({ $$inline: true });

	item3 = new Item({
			props: {
				$$slots: { default: [create_default_slot_2$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	item3.$on("SMUI:action", /*SMUI_action_handler_3*/ ctx[8]);

	const block = {
		c: function create() {
			create_component(item0.$$.fragment);
			t0 = space();
			create_component(item1.$$.fragment);
			t1 = space();
			create_component(item2.$$.fragment);
			t2 = space();
			create_component(separator.$$.fragment);
			t3 = space();
			create_component(item3.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(item0.$$.fragment, nodes);
			t0 = claim_space(nodes);
			claim_component(item1.$$.fragment, nodes);
			t1 = claim_space(nodes);
			claim_component(item2.$$.fragment, nodes);
			t2 = claim_space(nodes);
			claim_component(separator.$$.fragment, nodes);
			t3 = claim_space(nodes);
			claim_component(item3.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(item0, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(item1, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(item2, target, anchor);
			insert_dev(target, t2, anchor);
			mount_component(separator, target, anchor);
			insert_dev(target, t3, anchor);
			mount_component(item3, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const item0_changes = {};

			if (dirty & /*$$scope*/ 16384) {
				item0_changes.$$scope = { dirty, ctx };
			}

			item0.$set(item0_changes);
			const item1_changes = {};

			if (dirty & /*$$scope*/ 16384) {
				item1_changes.$$scope = { dirty, ctx };
			}

			item1.$set(item1_changes);
			const item2_changes = {};

			if (dirty & /*$$scope*/ 16384) {
				item2_changes.$$scope = { dirty, ctx };
			}

			item2.$set(item2_changes);
			const item3_changes = {};

			if (dirty & /*$$scope*/ 16384) {
				item3_changes.$$scope = { dirty, ctx };
			}

			item3.$set(item3_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(item0.$$.fragment, local);
			transition_in(item1.$$.fragment, local);
			transition_in(item2.$$.fragment, local);
			transition_in(separator.$$.fragment, local);
			transition_in(item3.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(item0.$$.fragment, local);
			transition_out(item1.$$.fragment, local);
			transition_out(item2.$$.fragment, local);
			transition_out(separator.$$.fragment, local);
			transition_out(item3.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(item0, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(item1, detaching);
			if (detaching) detach_dev(t1);
			destroy_component(item2, detaching);
			if (detaching) detach_dev(t2);
			destroy_component(separator, detaching);
			if (detaching) detach_dev(t3);
			destroy_component(item3, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$2.name,
		type: "slot",
		source: "(25:4) <List twoLine>",
		ctx
	});

	return block;
}

// (19:2) <Menu     bind:this={menu}     anchor={false}     bind:anchorElement={anchor}     anchorCorner="BOTTOM_LEFT"   >
function create_default_slot$2(ctx) {
	let list;
	let current;

	list = new List({
			props: {
				twoLine: true,
				$$slots: { default: [create_default_slot_1$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(list.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(list.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(list, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const list_changes = {};

			if (dirty & /*$$scope, clicked*/ 16392) {
				list_changes.$$scope = { dirty, ctx };
			}

			list.$set(list_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(list.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(list.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(list, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$2.name,
		type: "slot",
		source: "(19:2) <Menu     bind:this={menu}     anchor={false}     bind:anchorElement={anchor}     anchorCorner=\\\"BOTTOM_LEFT\\\"   >",
		ctx
	});

	return block;
}

function create_fragment$2(ctx) {
	let div;
	let button;
	let t0;
	let menu_1;
	let updating_anchorElement;
	let div_class_value;
	let Anchor_action;
	let t1;
	let pre;
	let t2;
	let t3;
	let current;
	let mounted;
	let dispose;

	button = new Button_1({
			props: {
				$$slots: { default: [create_default_slot_18] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button.$on("click", /*click_handler*/ ctx[4]);

	function menu_1_anchorElement_binding(value) {
		/*menu_1_anchorElement_binding*/ ctx[10](value);
	}

	let menu_1_props = {
		anchor: false,
		anchorCorner: "BOTTOM_LEFT",
		$$slots: { default: [create_default_slot$2] },
		$$scope: { ctx }
	};

	if (/*anchor*/ ctx[1] !== void 0) {
		menu_1_props.anchorElement = /*anchor*/ ctx[1];
	}

	menu_1 = new Menu$1({ props: menu_1_props, $$inline: true });
	/*menu_1_binding*/ ctx[9](menu_1);
	binding_callbacks.push(() => bind(menu_1, "anchorElement", menu_1_anchorElement_binding));

	const block = {
		c: function create() {
			div = element("div");
			create_component(button.$$.fragment);
			t0 = space();
			create_component(menu_1.$$.fragment);
			t1 = space();
			pre = element("pre");
			t2 = text("Clicked: ");
			t3 = text(/*clicked*/ ctx[3]);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			claim_component(button.$$.fragment, div_nodes);
			t0 = claim_space(div_nodes);
			claim_component(menu_1.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			pre = claim_element(nodes, "PRE", { class: true });
			var pre_nodes = children(pre);
			t2 = claim_text(pre_nodes, "Clicked: ");
			t3 = claim_text(pre_nodes, /*clicked*/ ctx[3]);
			pre_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", div_class_value = Object.keys(/*anchorClasses*/ ctx[2]).join(" "));
			add_location(div, file$2, 0, 0, 0);
			attr_dev(pre, "class", "status");
			add_location(pre, file$2, 54, 0, 1458);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(button, div, null);
			append_dev(div, t0);
			mount_component(menu_1, div, null);
			/*div_binding*/ ctx[13](div);
			insert_dev(target, t1, anchor);
			insert_dev(target, pre, anchor);
			append_dev(pre, t2);
			append_dev(pre, t3);
			current = true;

			if (!mounted) {
				dispose = action_destroyer(Anchor_action = Anchor.call(null, div, {
					addClass: /*Anchor_function*/ ctx[11],
					removeClass: /*Anchor_function_1*/ ctx[12]
				}));

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			const button_changes = {};

			if (dirty & /*$$scope*/ 16384) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
			const menu_1_changes = {};

			if (dirty & /*$$scope, clicked*/ 16392) {
				menu_1_changes.$$scope = { dirty, ctx };
			}

			if (!updating_anchorElement && dirty & /*anchor*/ 2) {
				updating_anchorElement = true;
				menu_1_changes.anchorElement = /*anchor*/ ctx[1];
				add_flush_callback(() => updating_anchorElement = false);
			}

			menu_1.$set(menu_1_changes);

			if (!current || dirty & /*anchorClasses*/ 4 && div_class_value !== (div_class_value = Object.keys(/*anchorClasses*/ ctx[2]).join(" "))) {
				attr_dev(div, "class", div_class_value);
			}

			if (Anchor_action && is_function(Anchor_action.update) && dirty & /*anchorClasses*/ 4) Anchor_action.update.call(null, {
				addClass: /*Anchor_function*/ ctx[11],
				removeClass: /*Anchor_function_1*/ ctx[12]
			});

			if (!current || dirty & /*clicked*/ 8) set_data_dev(t3, /*clicked*/ ctx[3]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			transition_in(menu_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button.$$.fragment, local);
			transition_out(menu_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(button);
			/*menu_1_binding*/ ctx[9](null);
			destroy_component(menu_1);
			/*div_binding*/ ctx[13](null);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(pre);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("TwoLineManunalAnchor", slots, []);
	let menu;
	let anchor;
	let anchorClasses = {};
	let clicked = "nothing yet";
	const writable_props = [];

	Object_1.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<TwoLineManunalAnchor> was created with unknown prop '${key}'`);
	});

	const click_handler = () => menu.setOpen(true);
	const SMUI_action_handler = () => $$invalidate(3, clicked = "Cut");
	const SMUI_action_handler_1 = () => $$invalidate(3, clicked = "Copy");
	const SMUI_action_handler_2 = () => $$invalidate(3, clicked = "Paste");
	const SMUI_action_handler_3 = () => $$invalidate(3, clicked = "Delete");

	function menu_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			menu = $$value;
			$$invalidate(0, menu);
		});
	}

	function menu_1_anchorElement_binding(value) {
		anchor = value;
		$$invalidate(1, anchor);
	}

	const Anchor_function = className => {
		if (!anchorClasses[className]) {
			$$invalidate(2, anchorClasses[className] = true, anchorClasses);
		}
	};

	const Anchor_function_1 = className => {
		if (anchorClasses[className]) {
			delete anchorClasses[className];
			$$invalidate(2, anchorClasses);
		}
	};

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			anchor = $$value;
			$$invalidate(1, anchor);
		});
	}

	$$self.$capture_state = () => ({
		Menu: Menu$1,
		Anchor,
		List,
		Item,
		Separator,
		Text,
		PrimaryText,
		SecondaryText,
		Button: Button_1,
		menu,
		anchor,
		anchorClasses,
		clicked
	});

	$$self.$inject_state = $$props => {
		if ("menu" in $$props) $$invalidate(0, menu = $$props.menu);
		if ("anchor" in $$props) $$invalidate(1, anchor = $$props.anchor);
		if ("anchorClasses" in $$props) $$invalidate(2, anchorClasses = $$props.anchorClasses);
		if ("clicked" in $$props) $$invalidate(3, clicked = $$props.clicked);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		menu,
		anchor,
		anchorClasses,
		clicked,
		click_handler,
		SMUI_action_handler,
		SMUI_action_handler_1,
		SMUI_action_handler_2,
		SMUI_action_handler_3,
		menu_1_binding,
		menu_1_anchorElement_binding,
		Anchor_function,
		Anchor_function_1,
		div_binding
	];
}

class TwoLineManunalAnchor extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2, create_fragment$2, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "TwoLineManunalAnchor",
			options,
			id: create_fragment$2.name
		});
	}
}

/* src/routes/demo/menu/_SelectionGroup.svelte generated by Svelte v3.37.0 */
const file$1 = "src/routes/demo/menu/_SelectionGroup.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[9] = list[i];
	return child_ctx;
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[9] = list[i];
	return child_ctx;
}

// (2:2) <Button on:click={() => menu.setOpen(true)}>
function create_default_slot_12(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Open Menu");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Open Menu");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_12.name,
		type: "slot",
		source: "(2:2) <Button on:click={() => menu.setOpen(true)}>",
		ctx
	});

	return block;
}

// (11:12) <SelectionGroupIcon>
function create_default_slot_11(ctx) {
	let i;
	let t;

	const block = {
		c: function create() {
			i = element("i");
			t = text("check");
			this.h();
		},
		l: function claim(nodes) {
			i = claim_element(nodes, "I", { class: true });
			var i_nodes = children(i);
			t = claim_text(i_nodes, "check");
			i_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(i, "class", "material-icons");
			add_location(i, file$1, 11, 14, 377);
		},
		m: function mount(target, anchor) {
			insert_dev(target, i, anchor);
			append_dev(i, t);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(i);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_11.name,
		type: "slot",
		source: "(11:12) <SelectionGroupIcon>",
		ctx
	});

	return block;
}

// (14:12) <Text>
function create_default_slot_10(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text(/*item*/ ctx[9]);
		},
		l: function claim(nodes) {
			t = claim_text(nodes, /*item*/ ctx[9]);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_10.name,
		type: "slot",
		source: "(14:12) <Text>",
		ctx
	});

	return block;
}

// (7:10) <Item             on:SMUI:action={() => (selected1 = item)}             selected={selected1 === item}           >
function create_default_slot_9(ctx) {
	let selectiongroupicon;
	let t0;
	let text_1;
	let t1;
	let current;

	selectiongroupicon = new SelectionGroupIcon({
			props: {
				$$slots: { default: [create_default_slot_11] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	text_1 = new Text({
			props: {
				$$slots: { default: [create_default_slot_10] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(selectiongroupicon.$$.fragment);
			t0 = space();
			create_component(text_1.$$.fragment);
			t1 = space();
		},
		l: function claim(nodes) {
			claim_component(selectiongroupicon.$$.fragment, nodes);
			t0 = claim_space(nodes);
			claim_component(text_1.$$.fragment, nodes);
			t1 = claim_space(nodes);
		},
		m: function mount(target, anchor) {
			mount_component(selectiongroupicon, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(text_1, target, anchor);
			insert_dev(target, t1, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const selectiongroupicon_changes = {};

			if (dirty & /*$$scope*/ 16384) {
				selectiongroupicon_changes.$$scope = { dirty, ctx };
			}

			selectiongroupicon.$set(selectiongroupicon_changes);
			const text_1_changes = {};

			if (dirty & /*$$scope*/ 16384) {
				text_1_changes.$$scope = { dirty, ctx };
			}

			text_1.$set(text_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(selectiongroupicon.$$.fragment, local);
			transition_in(text_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(selectiongroupicon.$$.fragment, local);
			transition_out(text_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(selectiongroupicon, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(text_1, detaching);
			if (detaching) detach_dev(t1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_9.name,
		type: "slot",
		source: "(7:10) <Item             on:SMUI:action={() => (selected1 = item)}             selected={selected1 === item}           >",
		ctx
	});

	return block;
}

// (6:8) {#each ['Red', 'Green', 'Blue'] as item}
function create_each_block_1(ctx) {
	let item;
	let current;

	function SMUI_action_handler() {
		return /*SMUI_action_handler*/ ctx[5](/*item*/ ctx[9]);
	}

	item = new Item({
			props: {
				selected: /*selected1*/ ctx[2] === /*item*/ ctx[9],
				$$slots: { default: [create_default_slot_9] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	item.$on("SMUI:action", SMUI_action_handler);

	const block = {
		c: function create() {
			create_component(item.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(item.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(item, target, anchor);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			const item_changes = {};
			if (dirty & /*selected1*/ 4) item_changes.selected = /*selected1*/ ctx[2] === /*item*/ ctx[9];

			if (dirty & /*$$scope*/ 16384) {
				item_changes.$$scope = { dirty, ctx };
			}

			item.$set(item_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(item.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(item.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(item, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_1.name,
		type: "each",
		source: "(6:8) {#each ['Red', 'Green', 'Blue'] as item}",
		ctx
	});

	return block;
}

// (5:6) <SelectionGroup>
function create_default_slot_8(ctx) {
	let each_1_anchor;
	let current;
	let each_value_1 = ["Red", "Green", "Blue"];
	validate_each_argument(each_value_1);
	let each_blocks = [];

	for (let i = 0; i < 3; i += 1) {
		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			for (let i = 0; i < 3; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < 3; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < 3; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (dirty & /*selected1*/ 4) {
				each_value_1 = ["Red", "Green", "Blue"];
				validate_each_argument(each_value_1);
				let i;

				for (i = 0; i < 3; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block_1(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();

				for (i = 3; i < 3; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < 3; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < 3; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_8.name,
		type: "slot",
		source: "(5:6) <SelectionGroup>",
		ctx
	});

	return block;
}

// (25:12) <SelectionGroupIcon>
function create_default_slot_7(ctx) {
	let i;
	let t;

	const block = {
		c: function create() {
			i = element("i");
			t = text("check");
			this.h();
		},
		l: function claim(nodes) {
			i = claim_element(nodes, "I", { class: true });
			var i_nodes = children(i);
			t = claim_text(i_nodes, "check");
			i_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(i, "class", "material-icons");
			add_location(i, file$1, 25, 14, 804);
		},
		m: function mount(target, anchor) {
			insert_dev(target, i, anchor);
			append_dev(i, t);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(i);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_7.name,
		type: "slot",
		source: "(25:12) <SelectionGroupIcon>",
		ctx
	});

	return block;
}

// (28:12) <Text>
function create_default_slot_6(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text(/*item*/ ctx[9]);
		},
		l: function claim(nodes) {
			t = claim_text(nodes, /*item*/ ctx[9]);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_6.name,
		type: "slot",
		source: "(28:12) <Text>",
		ctx
	});

	return block;
}

// (21:10) <Item             on:SMUI:action={() => (selected2 = item)}             selected={selected2 === item}           >
function create_default_slot_5(ctx) {
	let selectiongroupicon;
	let t0;
	let text_1;
	let t1;
	let current;

	selectiongroupicon = new SelectionGroupIcon({
			props: {
				$$slots: { default: [create_default_slot_7] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	text_1 = new Text({
			props: {
				$$slots: { default: [create_default_slot_6] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(selectiongroupicon.$$.fragment);
			t0 = space();
			create_component(text_1.$$.fragment);
			t1 = space();
		},
		l: function claim(nodes) {
			claim_component(selectiongroupicon.$$.fragment, nodes);
			t0 = claim_space(nodes);
			claim_component(text_1.$$.fragment, nodes);
			t1 = claim_space(nodes);
		},
		m: function mount(target, anchor) {
			mount_component(selectiongroupicon, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(text_1, target, anchor);
			insert_dev(target, t1, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const selectiongroupicon_changes = {};

			if (dirty & /*$$scope*/ 16384) {
				selectiongroupicon_changes.$$scope = { dirty, ctx };
			}

			selectiongroupicon.$set(selectiongroupicon_changes);
			const text_1_changes = {};

			if (dirty & /*$$scope*/ 16384) {
				text_1_changes.$$scope = { dirty, ctx };
			}

			text_1.$set(text_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(selectiongroupicon.$$.fragment, local);
			transition_in(text_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(selectiongroupicon.$$.fragment, local);
			transition_out(text_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(selectiongroupicon, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(text_1, detaching);
			if (detaching) detach_dev(t1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_5.name,
		type: "slot",
		source: "(21:10) <Item             on:SMUI:action={() => (selected2 = item)}             selected={selected2 === item}           >",
		ctx
	});

	return block;
}

// (20:8) {#each ['Small', 'Medium', 'Large'] as item}
function create_each_block(ctx) {
	let item;
	let current;

	function SMUI_action_handler_1() {
		return /*SMUI_action_handler_1*/ ctx[6](/*item*/ ctx[9]);
	}

	item = new Item({
			props: {
				selected: /*selected2*/ ctx[3] === /*item*/ ctx[9],
				$$slots: { default: [create_default_slot_5] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	item.$on("SMUI:action", SMUI_action_handler_1);

	const block = {
		c: function create() {
			create_component(item.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(item.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(item, target, anchor);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			const item_changes = {};
			if (dirty & /*selected2*/ 8) item_changes.selected = /*selected2*/ ctx[3] === /*item*/ ctx[9];

			if (dirty & /*$$scope*/ 16384) {
				item_changes.$$scope = { dirty, ctx };
			}

			item.$set(item_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(item.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(item.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(item, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(20:8) {#each ['Small', 'Medium', 'Large'] as item}",
		ctx
	});

	return block;
}

// (19:6) <SelectionGroup>
function create_default_slot_4(ctx) {
	let each_1_anchor;
	let current;
	let each_value = ["Small", "Medium", "Large"];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < 3; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			for (let i = 0; i < 3; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < 3; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < 3; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (dirty & /*selected2*/ 8) {
				each_value = ["Small", "Medium", "Large"];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < 3; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();

				for (i = 3; i < 3; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < 3; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < 3; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_4.name,
		type: "slot",
		source: "(19:6) <SelectionGroup>",
		ctx
	});

	return block;
}

// (34:8) <Text>
function create_default_slot_3(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Save for Later");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Save for Later");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3.name,
		type: "slot",
		source: "(34:8) <Text>",
		ctx
	});

	return block;
}

// (33:6) <Item on:SMUI:action={() => (clicked = 'Save for Later')}>
function create_default_slot_2$1(ctx) {
	let text_1;
	let current;

	text_1 = new Text({
			props: {
				$$slots: { default: [create_default_slot_3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(text_1.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(text_1.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(text_1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const text_1_changes = {};

			if (dirty & /*$$scope*/ 16384) {
				text_1_changes.$$scope = { dirty, ctx };
			}

			text_1.$set(text_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(text_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(text_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(text_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2$1.name,
		type: "slot",
		source: "(33:6) <Item on:SMUI:action={() => (clicked = 'Save for Later')}>",
		ctx
	});

	return block;
}

// (4:4) <List>
function create_default_slot_1$1(ctx) {
	let selectiongroup0;
	let t0;
	let separator0;
	let t1;
	let selectiongroup1;
	let t2;
	let separator1;
	let t3;
	let item;
	let current;

	selectiongroup0 = new SelectionGroup({
			props: {
				$$slots: { default: [create_default_slot_8] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	separator0 = new Separator({ $$inline: true });

	selectiongroup1 = new SelectionGroup({
			props: {
				$$slots: { default: [create_default_slot_4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	separator1 = new Separator({ $$inline: true });

	item = new Item({
			props: {
				$$slots: { default: [create_default_slot_2$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	item.$on("SMUI:action", /*SMUI_action_handler_2*/ ctx[7]);

	const block = {
		c: function create() {
			create_component(selectiongroup0.$$.fragment);
			t0 = space();
			create_component(separator0.$$.fragment);
			t1 = space();
			create_component(selectiongroup1.$$.fragment);
			t2 = space();
			create_component(separator1.$$.fragment);
			t3 = space();
			create_component(item.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(selectiongroup0.$$.fragment, nodes);
			t0 = claim_space(nodes);
			claim_component(separator0.$$.fragment, nodes);
			t1 = claim_space(nodes);
			claim_component(selectiongroup1.$$.fragment, nodes);
			t2 = claim_space(nodes);
			claim_component(separator1.$$.fragment, nodes);
			t3 = claim_space(nodes);
			claim_component(item.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(selectiongroup0, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(separator0, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(selectiongroup1, target, anchor);
			insert_dev(target, t2, anchor);
			mount_component(separator1, target, anchor);
			insert_dev(target, t3, anchor);
			mount_component(item, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const selectiongroup0_changes = {};

			if (dirty & /*$$scope, selected1*/ 16388) {
				selectiongroup0_changes.$$scope = { dirty, ctx };
			}

			selectiongroup0.$set(selectiongroup0_changes);
			const selectiongroup1_changes = {};

			if (dirty & /*$$scope, selected2*/ 16392) {
				selectiongroup1_changes.$$scope = { dirty, ctx };
			}

			selectiongroup1.$set(selectiongroup1_changes);
			const item_changes = {};

			if (dirty & /*$$scope*/ 16384) {
				item_changes.$$scope = { dirty, ctx };
			}

			item.$set(item_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(selectiongroup0.$$.fragment, local);
			transition_in(separator0.$$.fragment, local);
			transition_in(selectiongroup1.$$.fragment, local);
			transition_in(separator1.$$.fragment, local);
			transition_in(item.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(selectiongroup0.$$.fragment, local);
			transition_out(separator0.$$.fragment, local);
			transition_out(selectiongroup1.$$.fragment, local);
			transition_out(separator1.$$.fragment, local);
			transition_out(item.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(selectiongroup0, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(separator0, detaching);
			if (detaching) detach_dev(t1);
			destroy_component(selectiongroup1, detaching);
			if (detaching) detach_dev(t2);
			destroy_component(separator1, detaching);
			if (detaching) detach_dev(t3);
			destroy_component(item, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$1.name,
		type: "slot",
		source: "(4:4) <List>",
		ctx
	});

	return block;
}

// (3:2) <Menu bind:this={menu}>
function create_default_slot$1(ctx) {
	let list;
	let current;

	list = new List({
			props: {
				$$slots: { default: [create_default_slot_1$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(list.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(list.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(list, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const list_changes = {};

			if (dirty & /*$$scope, clicked, selected2, selected1*/ 16398) {
				list_changes.$$scope = { dirty, ctx };
			}

			list.$set(list_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(list.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(list.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(list, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$1.name,
		type: "slot",
		source: "(3:2) <Menu bind:this={menu}>",
		ctx
	});

	return block;
}

function create_fragment$1(ctx) {
	let div;
	let button;
	let t0;
	let menu_1;
	let t1;
	let pre0;
	let t2;
	let t3;
	let t4;
	let pre1;
	let t5;
	let t6;
	let t7;
	let pre2;
	let t8;
	let t9;
	let current;

	button = new Button_1({
			props: {
				$$slots: { default: [create_default_slot_12] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button.$on("click", /*click_handler*/ ctx[4]);

	let menu_1_props = {
		$$slots: { default: [create_default_slot$1] },
		$$scope: { ctx }
	};

	menu_1 = new Menu$1({ props: menu_1_props, $$inline: true });
	/*menu_1_binding*/ ctx[8](menu_1);

	const block = {
		c: function create() {
			div = element("div");
			create_component(button.$$.fragment);
			t0 = space();
			create_component(menu_1.$$.fragment);
			t1 = space();
			pre0 = element("pre");
			t2 = text("Selection 1: ");
			t3 = text(/*selected1*/ ctx[2]);
			t4 = space();
			pre1 = element("pre");
			t5 = text("Selection 2: ");
			t6 = text(/*selected2*/ ctx[3]);
			t7 = space();
			pre2 = element("pre");
			t8 = text("Clicked: ");
			t9 = text(/*clicked*/ ctx[1]);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { style: true });
			var div_nodes = children(div);
			claim_component(button.$$.fragment, div_nodes);
			t0 = claim_space(div_nodes);
			claim_component(menu_1.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			pre0 = claim_element(nodes, "PRE", { class: true });
			var pre0_nodes = children(pre0);
			t2 = claim_text(pre0_nodes, "Selection 1: ");
			t3 = claim_text(pre0_nodes, /*selected1*/ ctx[2]);
			pre0_nodes.forEach(detach_dev);
			t4 = claim_space(nodes);
			pre1 = claim_element(nodes, "PRE", { class: true });
			var pre1_nodes = children(pre1);
			t5 = claim_text(pre1_nodes, "Selection 2: ");
			t6 = claim_text(pre1_nodes, /*selected2*/ ctx[3]);
			pre1_nodes.forEach(detach_dev);
			t7 = claim_space(nodes);
			pre2 = claim_element(nodes, "PRE", { class: true });
			var pre2_nodes = children(pre2);
			t8 = claim_text(pre2_nodes, "Clicked: ");
			t9 = claim_text(pre2_nodes, /*clicked*/ ctx[1]);
			pre2_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_style(div, "min-width", "100px");
			add_location(div, file$1, 0, 0, 0);
			attr_dev(pre0, "class", "status");
			add_location(pre0, file$1, 39, 0, 1129);
			attr_dev(pre1, "class", "status");
			add_location(pre1, file$1, 40, 0, 1180);
			attr_dev(pre2, "class", "status");
			add_location(pre2, file$1, 41, 0, 1231);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(button, div, null);
			append_dev(div, t0);
			mount_component(menu_1, div, null);
			insert_dev(target, t1, anchor);
			insert_dev(target, pre0, anchor);
			append_dev(pre0, t2);
			append_dev(pre0, t3);
			insert_dev(target, t4, anchor);
			insert_dev(target, pre1, anchor);
			append_dev(pre1, t5);
			append_dev(pre1, t6);
			insert_dev(target, t7, anchor);
			insert_dev(target, pre2, anchor);
			append_dev(pre2, t8);
			append_dev(pre2, t9);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const button_changes = {};

			if (dirty & /*$$scope*/ 16384) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
			const menu_1_changes = {};

			if (dirty & /*$$scope, clicked, selected2, selected1*/ 16398) {
				menu_1_changes.$$scope = { dirty, ctx };
			}

			menu_1.$set(menu_1_changes);
			if (!current || dirty & /*selected1*/ 4) set_data_dev(t3, /*selected1*/ ctx[2]);
			if (!current || dirty & /*selected2*/ 8) set_data_dev(t6, /*selected2*/ ctx[3]);
			if (!current || dirty & /*clicked*/ 2) set_data_dev(t9, /*clicked*/ ctx[1]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			transition_in(menu_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button.$$.fragment, local);
			transition_out(menu_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(button);
			/*menu_1_binding*/ ctx[8](null);
			destroy_component(menu_1);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(pre0);
			if (detaching) detach_dev(t4);
			if (detaching) detach_dev(pre1);
			if (detaching) detach_dev(t7);
			if (detaching) detach_dev(pre2);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("SelectionGroup", slots, []);
	let menu;
	let clicked = "nothing yet";
	let selected1 = "Red";
	let selected2 = "Small";
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<SelectionGroup> was created with unknown prop '${key}'`);
	});

	const click_handler = () => menu.setOpen(true);
	const SMUI_action_handler = item => $$invalidate(2, selected1 = item);
	const SMUI_action_handler_1 = item => $$invalidate(3, selected2 = item);
	const SMUI_action_handler_2 = () => $$invalidate(1, clicked = "Save for Later");

	function menu_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			menu = $$value;
			$$invalidate(0, menu);
		});
	}

	$$self.$capture_state = () => ({
		Menu: Menu$1,
		SelectionGroup,
		SelectionGroupIcon,
		List,
		Item,
		Separator,
		Text,
		Button: Button_1,
		menu,
		clicked,
		selected1,
		selected2
	});

	$$self.$inject_state = $$props => {
		if ("menu" in $$props) $$invalidate(0, menu = $$props.menu);
		if ("clicked" in $$props) $$invalidate(1, clicked = $$props.clicked);
		if ("selected1" in $$props) $$invalidate(2, selected1 = $$props.selected1);
		if ("selected2" in $$props) $$invalidate(3, selected2 = $$props.selected2);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		menu,
		clicked,
		selected1,
		selected2,
		click_handler,
		SMUI_action_handler,
		SMUI_action_handler_1,
		SMUI_action_handler_2,
		menu_1_binding
	];
}

class SelectionGroup_1 extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$1, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "SelectionGroup_1",
			options,
			id: create_fragment$1.name
		});
	}
}

/* src/routes/demo/menu/index.svelte generated by Svelte v3.37.0 */
const file = "src/routes/demo/menu/index.svelte";

// (12:2) <Demo component={Anchored} file="menu/_Anchored.svelte">
function create_default_slot_2(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Anchored automatically");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Anchored automatically");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2.name,
		type: "slot",
		source: "(12:2) <Demo component={Anchored} file=\\\"menu/_Anchored.svelte\\\">",
		ctx
	});

	return block;
}

// (16:2) <Demo     component={TwoLineManunalAnchor}     file="menu/_TwoLineManunalAnchor.svelte"   >
function create_default_slot_1(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Two line, anchored manually, corner set to bottom-left");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Two line, anchored manually, corner set to bottom-left");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1.name,
		type: "slot",
		source: "(16:2) <Demo     component={TwoLineManunalAnchor}     file=\\\"menu/_TwoLineManunalAnchor.svelte\\\"   >",
		ctx
	});

	return block;
}

// (23:2) <Demo component={SelectionGroup} file="menu/_SelectionGroup.svelte">
function create_default_slot(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Selection groups");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Selection groups");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(23:2) <Demo component={SelectionGroup} file=\\\"menu/_SelectionGroup.svelte\\\">",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let t0;
	let section;
	let h2;
	let t1;
	let t2;
	let pre;
	let t3;
	let t4;
	let demo0;
	let t5;
	let demo1;
	let t6;
	let demo2;
	let t7;
	let demo3;
	let t8;
	let div;
	let t9;
	let current;

	demo0 = new Demo({
			props: {
				component: Static,
				file: "menu/_Static.svelte"
			},
			$$inline: true
		});

	demo1 = new Demo({
			props: {
				component: Anchored,
				file: "menu/_Anchored.svelte",
				$$slots: { default: [create_default_slot_2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	demo2 = new Demo({
			props: {
				component: TwoLineManunalAnchor,
				file: "menu/_TwoLineManunalAnchor.svelte",
				$$slots: { default: [create_default_slot_1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	demo3 = new Demo({
			props: {
				component: SelectionGroup_1,
				file: "menu/_SelectionGroup.svelte",
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			t0 = space();
			section = element("section");
			h2 = element("h2");
			t1 = text("Menu");
			t2 = space();
			pre = element("pre");
			t3 = text("npm i -D @smui/menu");
			t4 = space();
			create_component(demo0.$$.fragment);
			t5 = space();
			create_component(demo1.$$.fragment);
			t6 = space();
			create_component(demo2.$$.fragment);
			t7 = space();
			create_component(demo3.$$.fragment);
			t8 = space();
			div = element("div");
			t9 = text("Long div for scrolling...");
			this.h();
		},
		l: function claim(nodes) {
			const head_nodes = query_selector_all("[data-svelte=\"svelte-1csefpf\"]", document.head);
			head_nodes.forEach(detach_dev);
			t0 = claim_space(nodes);
			section = claim_element(nodes, "SECTION", {});
			var section_nodes = children(section);
			h2 = claim_element(section_nodes, "H2", {});
			var h2_nodes = children(h2);
			t1 = claim_text(h2_nodes, "Menu");
			h2_nodes.forEach(detach_dev);
			t2 = claim_space(section_nodes);
			pre = claim_element(section_nodes, "PRE", { class: true });
			var pre_nodes = children(pre);
			t3 = claim_text(pre_nodes, "npm i -D @smui/menu");
			pre_nodes.forEach(detach_dev);
			t4 = claim_space(section_nodes);
			claim_component(demo0.$$.fragment, section_nodes);
			t5 = claim_space(section_nodes);
			claim_component(demo1.$$.fragment, section_nodes);
			t6 = claim_space(section_nodes);
			claim_component(demo2.$$.fragment, section_nodes);
			t7 = claim_space(section_nodes);
			claim_component(demo3.$$.fragment, section_nodes);
			t8 = claim_space(section_nodes);
			div = claim_element(section_nodes, "DIV", { style: true });
			var div_nodes = children(div);
			t9 = claim_text(div_nodes, "Long div for scrolling...");
			div_nodes.forEach(detach_dev);
			section_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			document.title = "Menu - SMUI";
			add_location(h2, file, 5, 2, 71);
			attr_dev(pre, "class", "demo-spaced");
			add_location(pre, file, 7, 2, 88);
			set_style(div, "padding-top", "200px");
			add_location(div, file, 26, 2, 564);
			add_location(section, file, 4, 0, 59);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			insert_dev(target, section, anchor);
			append_dev(section, h2);
			append_dev(h2, t1);
			append_dev(section, t2);
			append_dev(section, pre);
			append_dev(pre, t3);
			append_dev(section, t4);
			mount_component(demo0, section, null);
			append_dev(section, t5);
			mount_component(demo1, section, null);
			append_dev(section, t6);
			mount_component(demo2, section, null);
			append_dev(section, t7);
			mount_component(demo3, section, null);
			append_dev(section, t8);
			append_dev(section, div);
			append_dev(div, t9);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const demo1_changes = {};

			if (dirty & /*$$scope*/ 1) {
				demo1_changes.$$scope = { dirty, ctx };
			}

			demo1.$set(demo1_changes);
			const demo2_changes = {};

			if (dirty & /*$$scope*/ 1) {
				demo2_changes.$$scope = { dirty, ctx };
			}

			demo2.$set(demo2_changes);
			const demo3_changes = {};

			if (dirty & /*$$scope*/ 1) {
				demo3_changes.$$scope = { dirty, ctx };
			}

			demo3.$set(demo3_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(demo0.$$.fragment, local);
			transition_in(demo1.$$.fragment, local);
			transition_in(demo2.$$.fragment, local);
			transition_in(demo3.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(demo0.$$.fragment, local);
			transition_out(demo1.$$.fragment, local);
			transition_out(demo2.$$.fragment, local);
			transition_out(demo3.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(section);
			destroy_component(demo0);
			destroy_component(demo1);
			destroy_component(demo2);
			destroy_component(demo3);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Menu", slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Menu> was created with unknown prop '${key}'`);
	});

	$$self.$capture_state = () => ({
		Demo,
		Static,
		Anchored,
		TwoLineManunalAnchor,
		SelectionGroup: SelectionGroup_1
	});

	return [];
}

class Menu extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Menu",
			options,
			id: create_fragment.name
		});
	}
}

export default Menu;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguNDNhNjJlYzQuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3BhY2thZ2VzL21lbnUvbm9kZV9tb2R1bGVzL0BzbXVpL2NvbW1vbi9leGNsdWRlLmpzIiwiLi4vLi4vLi4vcGFja2FnZXMvbWVudS9ub2RlX21vZHVsZXMvQHNtdWkvY29tbW9uL3ByZWZpeEZpbHRlci5qcyIsIi4uLy4uLy4uL3BhY2thZ2VzL21lbnUvU2VsZWN0aW9uR3JvdXAuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL3JvdXRlcy9kZW1vL21lbnUvX1N0YXRpYy5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvcm91dGVzL2RlbW8vbWVudS9fQW5jaG9yZWQuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL3JvdXRlcy9kZW1vL21lbnUvX1R3b0xpbmVNYW51bmFsQW5jaG9yLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9yb3V0ZXMvZGVtby9tZW51L19TZWxlY3Rpb25Hcm91cC5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvcm91dGVzL2RlbW8vbWVudS9pbmRleC5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIGV4Y2x1ZGUob2JqLCBrZXlzKSB7XG4gIGxldCBuYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaik7XG4gIGNvbnN0IG5ld09iaiA9IHt9O1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBuYW1lID0gbmFtZXNbaV07XG4gICAgY29uc3QgY2FzaEluZGV4ID0gbmFtZS5pbmRleE9mKCckJyk7XG4gICAgaWYgKFxuICAgICAgY2FzaEluZGV4ICE9PSAtMSAmJlxuICAgICAga2V5cy5pbmRleE9mKG5hbWUuc3Vic3RyaW5nKDAsIGNhc2hJbmRleCArIDEpKSAhPT0gLTFcbiAgICApIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoa2V5cy5pbmRleE9mKG5hbWUpICE9PSAtMSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIG5ld09ialtuYW1lXSA9IG9ialtuYW1lXTtcbiAgfVxuXG4gIHJldHVybiBuZXdPYmo7XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gcHJlZml4RmlsdGVyKG9iaiwgcHJlZml4KSB7XG4gIGxldCBuYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaik7XG4gIGNvbnN0IG5ld09iaiA9IHt9O1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBuYW1lID0gbmFtZXNbaV07XG4gICAgaWYgKG5hbWUuc3Vic3RyaW5nKDAsIHByZWZpeC5sZW5ndGgpID09PSBwcmVmaXgpIHtcbiAgICAgIG5ld09ialtuYW1lLnN1YnN0cmluZyhwcmVmaXgubGVuZ3RoKV0gPSBvYmpbbmFtZV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ld09iajtcbn1cbiIsIjxsaVxuICBiaW5kOnRoaXM9e2VsZW1lbnR9XG4gIHVzZTp1c2VBY3Rpb25zPXt1c2V9XG4gIHVzZTpmb3J3YXJkRXZlbnRzXG4gIHsuLi5leGNsdWRlKCQkcmVzdFByb3BzLCBbJ2xpc3QkJ10pfVxuPlxuICA8dWxcbiAgICB1c2U6dXNlQWN0aW9ucz17bGlzdCR1c2V9XG4gICAgY2xhc3M9e2NsYXNzTWFwKHtcbiAgICAgIFtsaXN0JGNsYXNzXTogdHJ1ZSxcbiAgICAgICdtZGMtbWVudV9fc2VsZWN0aW9uLWdyb3VwJzogdHJ1ZSxcbiAgICB9KX1cbiAgICB7Li4ucHJlZml4RmlsdGVyKCQkcmVzdFByb3BzLCAnbGlzdCQnKX1cbiAgPlxuICAgIDxzbG90IC8+XG4gIDwvdWw+XG48L2xpPlxuXG48c2NyaXB0PlxuICBpbXBvcnQgeyBzZXRDb250ZXh0IH0gZnJvbSAnc3ZlbHRlJztcbiAgaW1wb3J0IHsgZ2V0X2N1cnJlbnRfY29tcG9uZW50IH0gZnJvbSAnc3ZlbHRlL2ludGVybmFsJztcbiAgaW1wb3J0IHtcbiAgICBmb3J3YXJkRXZlbnRzQnVpbGRlcixcbiAgICBjbGFzc01hcCxcbiAgICBleGNsdWRlLFxuICAgIHByZWZpeEZpbHRlcixcbiAgICB1c2VBY3Rpb25zLFxuICB9IGZyb20gJ0BzbXVpL2NvbW1vbi9pbnRlcm5hbC5qcyc7XG5cbiAgY29uc3QgZm9yd2FyZEV2ZW50cyA9IGZvcndhcmRFdmVudHNCdWlsZGVyKGdldF9jdXJyZW50X2NvbXBvbmVudCgpKTtcblxuICBleHBvcnQgbGV0IHVzZSA9IFtdO1xuICBleHBvcnQgbGV0IGxpc3QkdXNlID0gW107XG4gIGV4cG9ydCBsZXQgbGlzdCRjbGFzcyA9ICcnO1xuXG4gIGxldCBlbGVtZW50O1xuXG4gIHNldENvbnRleHQoJ1NNVUk6bGlzdDpncmFwaGljOm1lbnUtc2VsZWN0aW9uLWdyb3VwJywgdHJ1ZSk7XG5cbiAgZXhwb3J0IGZ1bmN0aW9uIGdldEVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbjwvc2NyaXB0PlxuIiwiPE1lbnUgc3RhdGljPlxuICA8TGlzdD5cbiAgICA8SXRlbSBvbjpTTVVJOmFjdGlvbj17KCkgPT4gKGNsaWNrZWQgPSAnQ3V0Jyl9PlxuICAgICAgPFRleHQ+Q3V0PC9UZXh0PlxuICAgIDwvSXRlbT5cbiAgICA8SXRlbSBvbjpTTVVJOmFjdGlvbj17KCkgPT4gKGNsaWNrZWQgPSAnQ29weScpfT5cbiAgICAgIDxUZXh0PkNvcHk8L1RleHQ+XG4gICAgPC9JdGVtPlxuICAgIDxJdGVtIG9uOlNNVUk6YWN0aW9uPXsoKSA9PiAoY2xpY2tlZCA9ICdQYXN0ZScpfT5cbiAgICAgIDxUZXh0PlBhc3RlPC9UZXh0PlxuICAgIDwvSXRlbT5cbiAgICA8U2VwYXJhdG9yIC8+XG4gICAgPEl0ZW0gb246U01VSTphY3Rpb249eygpID0+IChjbGlja2VkID0gJ0RlbGV0ZScpfT5cbiAgICAgIDxUZXh0PkRlbGV0ZTwvVGV4dD5cbiAgICA8L0l0ZW0+XG4gIDwvTGlzdD5cbjwvTWVudT5cblxuPHByZSBjbGFzcz1cInN0YXR1c1wiPkNsaWNrZWQ6IHtjbGlja2VkfTwvcHJlPlxuXG48c2NyaXB0PlxuICBpbXBvcnQgTWVudSBmcm9tICdAc211aS9tZW51JztcbiAgaW1wb3J0IExpc3QsIHsgSXRlbSwgU2VwYXJhdG9yLCBUZXh0IH0gZnJvbSAnQHNtdWkvbGlzdCc7XG5cbiAgbGV0IGNsaWNrZWQgPSAnbm90aGluZyB5ZXQnO1xuPC9zY3JpcHQ+XG4iLCI8ZGl2IHN0eWxlPVwibWluLXdpZHRoOiAxMDBweDtcIj5cbiAgPEJ1dHRvbiBvbjpjbGljaz17KCkgPT4gbWVudS5zZXRPcGVuKHRydWUpfT5PcGVuIE1lbnU8L0J1dHRvbj5cbiAgPE1lbnUgYmluZDp0aGlzPXttZW51fT5cbiAgICA8TGlzdD5cbiAgICAgIDxJdGVtIG9uOlNNVUk6YWN0aW9uPXsoKSA9PiAoY2xpY2tlZCA9ICdDdXQnKX0+XG4gICAgICAgIDxUZXh0PkN1dDwvVGV4dD5cbiAgICAgIDwvSXRlbT5cbiAgICAgIDxJdGVtIG9uOlNNVUk6YWN0aW9uPXsoKSA9PiAoY2xpY2tlZCA9ICdDb3B5Jyl9PlxuICAgICAgICA8VGV4dD5Db3B5PC9UZXh0PlxuICAgICAgPC9JdGVtPlxuICAgICAgPEl0ZW0gb246U01VSTphY3Rpb249eygpID0+IChjbGlja2VkID0gJ1Bhc3RlJyl9PlxuICAgICAgICA8VGV4dD5QYXN0ZTwvVGV4dD5cbiAgICAgIDwvSXRlbT5cbiAgICAgIDxTZXBhcmF0b3IgLz5cbiAgICAgIDxJdGVtIG9uOlNNVUk6YWN0aW9uPXsoKSA9PiAoY2xpY2tlZCA9ICdEZWxldGUnKX0+XG4gICAgICAgIDxUZXh0PkRlbGV0ZTwvVGV4dD5cbiAgICAgIDwvSXRlbT5cbiAgICA8L0xpc3Q+XG4gIDwvTWVudT5cbjwvZGl2PlxuXG48cHJlIGNsYXNzPVwic3RhdHVzXCI+Q2xpY2tlZDoge2NsaWNrZWR9PC9wcmU+XG5cbjxzY3JpcHQ+XG4gIGltcG9ydCBNZW51IGZyb20gJ0BzbXVpL21lbnUnO1xuICBpbXBvcnQgTGlzdCwgeyBJdGVtLCBTZXBhcmF0b3IsIFRleHQgfSBmcm9tICdAc211aS9saXN0JztcbiAgaW1wb3J0IEJ1dHRvbiBmcm9tICdAc211aS9idXR0b24nO1xuXG4gIGxldCBtZW51O1xuICBsZXQgY2xpY2tlZCA9ICdub3RoaW5nIHlldCc7XG48L3NjcmlwdD5cbiIsIjxkaXZcbiAgY2xhc3M9e09iamVjdC5rZXlzKGFuY2hvckNsYXNzZXMpLmpvaW4oJyAnKX1cbiAgdXNlOkFuY2hvcj17e1xuICAgIGFkZENsYXNzOiAoY2xhc3NOYW1lKSA9PiB7XG4gICAgICBpZiAoIWFuY2hvckNsYXNzZXNbY2xhc3NOYW1lXSkge1xuICAgICAgICBhbmNob3JDbGFzc2VzW2NsYXNzTmFtZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVtb3ZlQ2xhc3M6IChjbGFzc05hbWUpID0+IHtcbiAgICAgIGlmIChhbmNob3JDbGFzc2VzW2NsYXNzTmFtZV0pIHtcbiAgICAgICAgZGVsZXRlIGFuY2hvckNsYXNzZXNbY2xhc3NOYW1lXTtcbiAgICAgICAgYW5jaG9yQ2xhc3NlcyA9IGFuY2hvckNsYXNzZXM7XG4gICAgICB9XG4gICAgfSxcbiAgfX1cbiAgYmluZDp0aGlzPXthbmNob3J9XG4+XG4gIDxCdXR0b24gb246Y2xpY2s9eygpID0+IG1lbnUuc2V0T3Blbih0cnVlKX0+T3BlbiBNZW51PC9CdXR0b24+XG4gIDxNZW51XG4gICAgYmluZDp0aGlzPXttZW51fVxuICAgIGFuY2hvcj17ZmFsc2V9XG4gICAgYmluZDphbmNob3JFbGVtZW50PXthbmNob3J9XG4gICAgYW5jaG9yQ29ybmVyPVwiQk9UVE9NX0xFRlRcIlxuICA+XG4gICAgPExpc3QgdHdvTGluZT5cbiAgICAgIDxJdGVtIG9uOlNNVUk6YWN0aW9uPXsoKSA9PiAoY2xpY2tlZCA9ICdDdXQnKX0+XG4gICAgICAgIDxUZXh0PlxuICAgICAgICAgIDxQcmltYXJ5VGV4dD5DdXQ8L1ByaW1hcnlUZXh0PlxuICAgICAgICAgIDxTZWNvbmRhcnlUZXh0PkNvcHkgdG8gY2xpcGJvYXJkIGFuZCByZW1vdmUuPC9TZWNvbmRhcnlUZXh0PlxuICAgICAgICA8L1RleHQ+XG4gICAgICA8L0l0ZW0+XG4gICAgICA8SXRlbSBvbjpTTVVJOmFjdGlvbj17KCkgPT4gKGNsaWNrZWQgPSAnQ29weScpfT5cbiAgICAgICAgPFRleHQ+XG4gICAgICAgICAgPFByaW1hcnlUZXh0PkNvcHk8L1ByaW1hcnlUZXh0PlxuICAgICAgICAgIDxTZWNvbmRhcnlUZXh0PkNvcHkgdG8gY2xpcGJvYXJkLjwvU2Vjb25kYXJ5VGV4dD5cbiAgICAgICAgPC9UZXh0PlxuICAgICAgPC9JdGVtPlxuICAgICAgPEl0ZW0gb246U01VSTphY3Rpb249eygpID0+IChjbGlja2VkID0gJ1Bhc3RlJyl9PlxuICAgICAgICA8VGV4dD5cbiAgICAgICAgICA8UHJpbWFyeVRleHQ+UGFzdGU8L1ByaW1hcnlUZXh0PlxuICAgICAgICAgIDxTZWNvbmRhcnlUZXh0PlBhc3RlIGZyb20gY2xpcGJvYXJkLjwvU2Vjb25kYXJ5VGV4dD5cbiAgICAgICAgPC9UZXh0PlxuICAgICAgPC9JdGVtPlxuICAgICAgPFNlcGFyYXRvciAvPlxuICAgICAgPEl0ZW0gb246U01VSTphY3Rpb249eygpID0+IChjbGlja2VkID0gJ0RlbGV0ZScpfT5cbiAgICAgICAgPFRleHQ+XG4gICAgICAgICAgPFByaW1hcnlUZXh0PkRlbGV0ZTwvUHJpbWFyeVRleHQ+XG4gICAgICAgICAgPFNlY29uZGFyeVRleHQ+UmVtb3ZlIGl0ZW0uPC9TZWNvbmRhcnlUZXh0PlxuICAgICAgICA8L1RleHQ+XG4gICAgICA8L0l0ZW0+XG4gICAgPC9MaXN0PlxuICA8L01lbnU+XG48L2Rpdj5cblxuPHByZSBjbGFzcz1cInN0YXR1c1wiPkNsaWNrZWQ6IHtjbGlja2VkfTwvcHJlPlxuXG48c2NyaXB0PlxuICBpbXBvcnQgTWVudSBmcm9tICdAc211aS9tZW51JztcbiAgaW1wb3J0IHsgQW5jaG9yIH0gZnJvbSAnQHNtdWkvbWVudS1zdXJmYWNlJztcbiAgaW1wb3J0IExpc3QsIHtcbiAgICBJdGVtLFxuICAgIFNlcGFyYXRvcixcbiAgICBUZXh0LFxuICAgIFByaW1hcnlUZXh0LFxuICAgIFNlY29uZGFyeVRleHQsXG4gIH0gZnJvbSAnQHNtdWkvbGlzdCc7XG4gIGltcG9ydCBCdXR0b24gZnJvbSAnQHNtdWkvYnV0dG9uJztcblxuICBsZXQgbWVudTtcbiAgbGV0IGFuY2hvcjtcbiAgbGV0IGFuY2hvckNsYXNzZXMgPSB7fTtcbiAgbGV0IGNsaWNrZWQgPSAnbm90aGluZyB5ZXQnO1xuPC9zY3JpcHQ+XG4iLCI8ZGl2IHN0eWxlPVwibWluLXdpZHRoOiAxMDBweDtcIj5cbiAgPEJ1dHRvbiBvbjpjbGljaz17KCkgPT4gbWVudS5zZXRPcGVuKHRydWUpfT5PcGVuIE1lbnU8L0J1dHRvbj5cbiAgPE1lbnUgYmluZDp0aGlzPXttZW51fT5cbiAgICA8TGlzdD5cbiAgICAgIDxTZWxlY3Rpb25Hcm91cD5cbiAgICAgICAgeyNlYWNoIFsnUmVkJywgJ0dyZWVuJywgJ0JsdWUnXSBhcyBpdGVtfVxuICAgICAgICAgIDxJdGVtXG4gICAgICAgICAgICBvbjpTTVVJOmFjdGlvbj17KCkgPT4gKHNlbGVjdGVkMSA9IGl0ZW0pfVxuICAgICAgICAgICAgc2VsZWN0ZWQ9e3NlbGVjdGVkMSA9PT0gaXRlbX1cbiAgICAgICAgICA+XG4gICAgICAgICAgICA8U2VsZWN0aW9uR3JvdXBJY29uPlxuICAgICAgICAgICAgICA8aSBjbGFzcz1cIm1hdGVyaWFsLWljb25zXCI+Y2hlY2s8L2k+XG4gICAgICAgICAgICA8L1NlbGVjdGlvbkdyb3VwSWNvbj5cbiAgICAgICAgICAgIDxUZXh0PntpdGVtfTwvVGV4dD5cbiAgICAgICAgICA8L0l0ZW0+XG4gICAgICAgIHsvZWFjaH1cbiAgICAgIDwvU2VsZWN0aW9uR3JvdXA+XG4gICAgICA8U2VwYXJhdG9yIC8+XG4gICAgICA8U2VsZWN0aW9uR3JvdXA+XG4gICAgICAgIHsjZWFjaCBbJ1NtYWxsJywgJ01lZGl1bScsICdMYXJnZSddIGFzIGl0ZW19XG4gICAgICAgICAgPEl0ZW1cbiAgICAgICAgICAgIG9uOlNNVUk6YWN0aW9uPXsoKSA9PiAoc2VsZWN0ZWQyID0gaXRlbSl9XG4gICAgICAgICAgICBzZWxlY3RlZD17c2VsZWN0ZWQyID09PSBpdGVtfVxuICAgICAgICAgID5cbiAgICAgICAgICAgIDxTZWxlY3Rpb25Hcm91cEljb24+XG4gICAgICAgICAgICAgIDxpIGNsYXNzPVwibWF0ZXJpYWwtaWNvbnNcIj5jaGVjazwvaT5cbiAgICAgICAgICAgIDwvU2VsZWN0aW9uR3JvdXBJY29uPlxuICAgICAgICAgICAgPFRleHQ+e2l0ZW19PC9UZXh0PlxuICAgICAgICAgIDwvSXRlbT5cbiAgICAgICAgey9lYWNofVxuICAgICAgPC9TZWxlY3Rpb25Hcm91cD5cbiAgICAgIDxTZXBhcmF0b3IgLz5cbiAgICAgIDxJdGVtIG9uOlNNVUk6YWN0aW9uPXsoKSA9PiAoY2xpY2tlZCA9ICdTYXZlIGZvciBMYXRlcicpfT5cbiAgICAgICAgPFRleHQ+U2F2ZSBmb3IgTGF0ZXI8L1RleHQ+XG4gICAgICA8L0l0ZW0+XG4gICAgPC9MaXN0PlxuICA8L01lbnU+XG48L2Rpdj5cblxuPHByZSBjbGFzcz1cInN0YXR1c1wiPlNlbGVjdGlvbiAxOiB7c2VsZWN0ZWQxfTwvcHJlPlxuPHByZSBjbGFzcz1cInN0YXR1c1wiPlNlbGVjdGlvbiAyOiB7c2VsZWN0ZWQyfTwvcHJlPlxuPHByZSBjbGFzcz1cInN0YXR1c1wiPkNsaWNrZWQ6IHtjbGlja2VkfTwvcHJlPlxuXG48c2NyaXB0PlxuICBpbXBvcnQgTWVudSwgeyBTZWxlY3Rpb25Hcm91cCwgU2VsZWN0aW9uR3JvdXBJY29uIH0gZnJvbSAnQHNtdWkvbWVudSc7XG4gIGltcG9ydCBMaXN0LCB7IEl0ZW0sIFNlcGFyYXRvciwgVGV4dCB9IGZyb20gJ0BzbXVpL2xpc3QnO1xuICBpbXBvcnQgQnV0dG9uIGZyb20gJ0BzbXVpL2J1dHRvbic7XG5cbiAgbGV0IG1lbnU7XG4gIGxldCBjbGlja2VkID0gJ25vdGhpbmcgeWV0JztcbiAgbGV0IHNlbGVjdGVkMSA9ICdSZWQnO1xuICBsZXQgc2VsZWN0ZWQyID0gJ1NtYWxsJztcbjwvc2NyaXB0PlxuIiwiPHN2ZWx0ZTpoZWFkPlxuICA8dGl0bGU+TWVudSAtIFNNVUk8L3RpdGxlPlxuPC9zdmVsdGU6aGVhZD5cblxuPHNlY3Rpb24+XG4gIDxoMj5NZW51PC9oMj5cblxuICA8cHJlIGNsYXNzPVwiZGVtby1zcGFjZWRcIj5ucG0gaSAtRCBAc211aS9tZW51PC9wcmU+XG5cbiAgPERlbW8gY29tcG9uZW50PXtTdGF0aWN9IGZpbGU9XCJtZW51L19TdGF0aWMuc3ZlbHRlXCIgLz5cblxuICA8RGVtbyBjb21wb25lbnQ9e0FuY2hvcmVkfSBmaWxlPVwibWVudS9fQW5jaG9yZWQuc3ZlbHRlXCI+XG4gICAgQW5jaG9yZWQgYXV0b21hdGljYWxseVxuICA8L0RlbW8+XG5cbiAgPERlbW9cbiAgICBjb21wb25lbnQ9e1R3b0xpbmVNYW51bmFsQW5jaG9yfVxuICAgIGZpbGU9XCJtZW51L19Ud29MaW5lTWFudW5hbEFuY2hvci5zdmVsdGVcIlxuICA+XG4gICAgVHdvIGxpbmUsIGFuY2hvcmVkIG1hbnVhbGx5LCBjb3JuZXIgc2V0IHRvIGJvdHRvbS1sZWZ0XG4gIDwvRGVtbz5cblxuICA8RGVtbyBjb21wb25lbnQ9e1NlbGVjdGlvbkdyb3VwfSBmaWxlPVwibWVudS9fU2VsZWN0aW9uR3JvdXAuc3ZlbHRlXCI+XG4gICAgU2VsZWN0aW9uIGdyb3Vwc1xuICA8L0RlbW8+XG5cbiAgPGRpdiBzdHlsZT1cInBhZGRpbmctdG9wOiAyMDBweDtcIj5Mb25nIGRpdiBmb3Igc2Nyb2xsaW5nLi4uPC9kaXY+XG48L3NlY3Rpb24+XG5cbjxzY3JpcHQ+XG4gIGltcG9ydCBEZW1vIGZyb20gJy4uLy4uLy4uL2NvbXBvbmVudHMvRGVtby5zdmVsdGUnO1xuICBpbXBvcnQgU3RhdGljIGZyb20gJy4vX1N0YXRpYy5zdmVsdGUnO1xuICBpbXBvcnQgQW5jaG9yZWQgZnJvbSAnLi9fQW5jaG9yZWQuc3ZlbHRlJztcbiAgaW1wb3J0IFR3b0xpbmVNYW51bmFsQW5jaG9yIGZyb20gJy4vX1R3b0xpbmVNYW51bmFsQW5jaG9yLnN2ZWx0ZSc7XG4gIGltcG9ydCBTZWxlY3Rpb25Hcm91cCBmcm9tICcuL19TZWxlY3Rpb25Hcm91cC5zdmVsdGUnO1xuPC9zY3JpcHQ+XG4iXSwibmFtZXMiOlsiU2VsZWN0aW9uR3JvdXAiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFPLFNBQVMsT0FBTyxDQUFDLEdBQUcsRUFBRSxJQUFJLEVBQUU7QUFDbkMsRUFBRSxJQUFJLEtBQUssR0FBRyxNQUFNLENBQUMsbUJBQW1CLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDOUMsRUFBRSxNQUFNLE1BQU0sR0FBRyxFQUFFLENBQUM7QUFDcEI7QUFDQSxFQUFFLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxLQUFLLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO0FBQ3pDLElBQUksTUFBTSxJQUFJLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQzFCLElBQUksTUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUN4QyxJQUFJO0FBQ0osTUFBTSxTQUFTLEtBQUssQ0FBQyxDQUFDO0FBQ3RCLE1BQU0sSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsRUFBRSxTQUFTLEdBQUcsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDM0QsTUFBTTtBQUNOLE1BQU0sU0FBUztBQUNmLEtBQUs7QUFDTCxJQUFJLElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRTtBQUNuQyxNQUFNLFNBQVM7QUFDZixLQUFLO0FBQ0wsSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQzdCLEdBQUc7QUFDSDtBQUNBLEVBQUUsT0FBTyxNQUFNLENBQUM7QUFDaEI7O0FDcEJPLFNBQVMsWUFBWSxDQUFDLEdBQUcsRUFBRSxNQUFNLEVBQUU7QUFDMUMsRUFBRSxJQUFJLEtBQUssR0FBRyxNQUFNLENBQUMsbUJBQW1CLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDOUMsRUFBRSxNQUFNLE1BQU0sR0FBRyxFQUFFLENBQUM7QUFDcEI7QUFDQSxFQUFFLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxLQUFLLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO0FBQ3pDLElBQUksTUFBTSxJQUFJLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQzFCLElBQUksSUFBSSxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsTUFBTSxDQUFDLEtBQUssTUFBTSxFQUFFO0FBQ3JELE1BQU0sTUFBTSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ3hELEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQSxFQUFFLE9BQU8sTUFBTSxDQUFDO0FBQ2hCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsyQkNKVyxRQUFRO29CQUNaLEdBQVUsTUFBRyxJQUFJO0lBQ2xCLDJCQUEyQixFQUFFLElBQUk7OztFQUUvQixZQUFZLGlCQUFDLEdBQVcsS0FBRSxPQUFPOzs7Ozs7Ozs7a0JBUm5DLE9BQU8saUJBQUMsR0FBVyxNQUFHLE9BQU87Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7aUZBR2YsR0FBUTs4RUFMVixHQUFHOzs7Ozs7Ozs7Ozs7Ozs7a0ZBTVYsUUFBUTtxQkFDWixHQUFVLE1BQUcsSUFBSTtLQUNsQiwyQkFBMkIsRUFBRSxJQUFJOztrQ0FFL0IsWUFBWSxpQkFBQyxHQUFXLEtBQUUsT0FBTzs7OzhJQUxyQixHQUFROzRGQUh0QixPQUFPLGlCQUFDLEdBQVcsTUFBRyxPQUFPOzBJQUZqQixHQUFHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0EyQmIsYUFBYSxHQUFHLG9CQUFvQixDQUFDLHFCQUFxQjtPQUVyRCxHQUFHO09BQ0gsUUFBUTtPQUNSLFVBQVUsR0FBRyxFQUFFO0tBRXRCLE9BQU87Q0FFWCxVQUFVLENBQUMsd0NBQXdDLEVBQUUsSUFBSTs7VUFFekMsVUFBVTtTQUNqQixPQUFPOzs7OztHQXZDTCxPQUFPOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3lCQ2lCVSxHQUFPOzs7Ozs7Ozs7MENBQVAsR0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3VFQUFQLEdBQU87Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tBTS9CLE9BQU8sR0FBRyxhQUFhOzs7Ozs7O21EQXRCSSxPQUFPLEdBQUcsS0FBSztxREFHZixPQUFPLEdBQUcsTUFBTTtxREFHaEIsT0FBTyxHQUFHLE9BQU87cURBSWpCLE9BQU8sR0FBRyxRQUFROzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt5QkNTckIsR0FBTzs7Ozs7Ozs7Ozs7Ozs7MENBQVAsR0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3VFQUFQLEdBQU87Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0FPL0IsSUFBSTtLQUNKLE9BQU8sR0FBRyxhQUFhOzs7Ozs7OzZCQTVCSCxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUk7bURBR1IsT0FBTyxHQUFHLEtBQUs7cURBR2YsT0FBTyxHQUFHLE1BQU07cURBR2hCLE9BQU8sR0FBRyxPQUFPO3FEQUlqQixPQUFPLEdBQUcsUUFBUTs7OztHQVpsQyxJQUFJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztVQ2tCWCxLQUFLOzs7Ozs7Z0JBQ08sR0FBTTswQ0FBTixHQUFNOzs7Ozs7Ozs7Ozs7Ozs7O3lCQWlDQSxHQUFPOzs7Ozs7Ozs7Ozs7OzswQ0FBUCxHQUFPOzs7Ozs0Q0FyRDVCLE1BQU0sQ0FBQyxJQUFJLG1CQUFDLEdBQWEsS0FBRSxJQUFJLENBQUMsR0FBRzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQUV4QyxRQUFRO0tBS1IsV0FBVzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs4Q0FhUyxHQUFNOzs7Ozs7eUZBcEJyQixNQUFNLENBQUMsSUFBSSxtQkFBQyxHQUFhLEtBQUUsSUFBSSxDQUFDLEdBQUc7Ozs7O0lBRXhDLFFBQVE7SUFLUixXQUFXOzs7dUVBOENlLEdBQU87Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0FjL0IsSUFBSTtLQUNKLE1BQU07S0FDTixhQUFhO0tBQ2IsT0FBTyxHQUFHLGFBQWE7Ozs7Ozs7NkJBdERILElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSTttREFRUixPQUFPLEdBQUcsS0FBSztxREFNZixPQUFPLEdBQUcsTUFBTTtxREFNaEIsT0FBTyxHQUFHLE9BQU87cURBT2pCLE9BQU8sR0FBRyxRQUFROzs7O0dBekJ0QyxJQUFJOzs7Ozs7RUFFSyxNQUFNOzs7O3lCQWxCZixTQUFTO09BQ2IsYUFBYSxDQUFDLFNBQVM7bUJBQzFCLGFBQWEsQ0FBQyxTQUFTLElBQUksSUFBSTs7OzsyQkFHckIsU0FBUztNQUNqQixhQUFhLENBQUMsU0FBUztVQUNsQixhQUFhLENBQUMsU0FBUzs7Ozs7OztHQUt6QixNQUFNOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3FCQ0ZBLEdBQUk7OztrQ0FBSixHQUFJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7NEJBTEQsR0FBUyxpQkFBSyxHQUFJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztzRUFBbEIsR0FBUyxpQkFBSyxHQUFJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3FCQUh4QixLQUFLLEVBQUUsT0FBTyxFQUFFLE1BQU07Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQXRCLEtBQUssRUFBRSxPQUFPLEVBQUUsTUFBTTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7cUJBc0JuQixHQUFJOzs7a0NBQUosR0FBSTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzRCQUxELEdBQVMsaUJBQUssR0FBSTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7c0VBQWxCLEdBQVMsaUJBQUssR0FBSTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzttQkFIeEIsT0FBTyxFQUFFLFFBQVEsRUFBRSxPQUFPOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2tCQUExQixPQUFPLEVBQUUsUUFBUSxFQUFFLE9BQU87Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsyQkFvQlIsR0FBUzs7OzsyQkFDVCxHQUFTOzs7O3lCQUNiLEdBQU87Ozs7Ozs7Ozs7Ozs7OzZDQUZILEdBQVM7Ozs7Ozs2Q0FDVCxHQUFTOzs7Ozs7MkNBQ2IsR0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzJFQUZILEdBQVM7MkVBQ1QsR0FBUzt1RUFDYixHQUFPOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQU8vQixJQUFJO0tBQ0osT0FBTyxHQUFHLGFBQWE7S0FDdkIsU0FBUyxHQUFHLEtBQUs7S0FDakIsU0FBUyxHQUFHLE9BQU87Ozs7Ozs7NkJBbERDLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSTtxREFNUixTQUFTLEdBQUcsSUFBSTt1REFjaEIsU0FBUyxHQUFHLElBQUk7cURBV2hCLE9BQU8sR0FBRyxnQkFBZ0I7Ozs7R0E5QjFDLElBQUk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztlQ09KLE1BQU07Ozs7Ozs7O2VBRU4sUUFBUTs7Ozs7Ozs7OztlQUtaLG9CQUFvQjs7Ozs7Ozs7OztlQU1oQkEsZ0JBQWM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsifQ==
