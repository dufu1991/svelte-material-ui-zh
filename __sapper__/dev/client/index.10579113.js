import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, a7 as create_slot, $ as assign, W as compute_rest_props, v as validate_slots, Y as get_current_component, a0 as exclude_internal_props, p as element, x as claim_element, y as children, u as detach_dev, a9 as set_attributes, D as add_location, F as insert_dev, aa as action_destroyer, a8 as update_slot, a2 as get_spread_update, ab as is_function, J as transition_in, K as transition_out, ac as run_all, a6 as binding_callbacks, X as getContext, q as create_component, a1 as empty, A as claim_component, H as mount_component, a3 as get_spread_object, a4 as group_outros, M as destroy_component, a5 as check_outros, ag as validate_each_argument, O as noop, aj as destroy_each, o as space, w as claim_space, t as text, z as claim_text, r as query_selector_all, E as attr_dev, G as append_dev } from './client.ec94238b.js';
import { D as Demo } from './Demo.9c515360.js';
import { f as forwardEventsBuilder, u as useActions, d as classMap, I as ImageList, a as Item, b as ImageAspectContainer, c as Image, S as Supporting } from './Supporting.a874223d.js';
import { D as Div } from './Div.92a8773b.js';

/* packages/image-list/node_modules/@smui/common/Span.svelte generated by Svelte v3.37.0 */
const file$1 = "packages/image-list/node_modules/@smui/common/Span.svelte";

function create_fragment$6(ctx) {
	let span;
	let useActions_action;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[6].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);
	let span_levels = [/*$$restProps*/ ctx[3]];
	let span_data = {};

	for (let i = 0; i < span_levels.length; i += 1) {
		span_data = assign(span_data, span_levels[i]);
	}

	const block = {
		c: function create() {
			span = element("span");
			if (default_slot) default_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", {});
			var span_nodes = children(span);
			if (default_slot) default_slot.l(span_nodes);
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_attributes(span, span_data);
			add_location(span, file$1, 0, 0, 0);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);

			if (default_slot) {
				default_slot.m(span, null);
			}

			/*span_binding*/ ctx[7](span);
			current = true;

			if (!mounted) {
				dispose = [
					action_destroyer(useActions_action = useActions.call(null, span, /*use*/ ctx[0])),
					action_destroyer(/*forwardEvents*/ ctx[2].call(null, span))
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 32) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[5], dirty, null, null);
				}
			}

			set_attributes(span, span_data = get_spread_update(span_levels, [dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3]]));
			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			if (default_slot) default_slot.d(detaching);
			/*span_binding*/ ctx[7](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$6.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$6($$self, $$props, $$invalidate) {
	const omit_props_names = ["use","getElement"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Span", slots, ['default']);
	let { use = [] } = $$props;
	const forwardEvents = forwardEventsBuilder(get_current_component());
	let element = null;

	function getElement() {
		return element;
	}

	function span_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			element = $$value;
			$$invalidate(1, element);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("use" in $$new_props) $$invalidate(0, use = $$new_props.use);
		if ("$$scope" in $$new_props) $$invalidate(5, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		get_current_component,
		forwardEventsBuilder,
		useActions,
		use,
		forwardEvents,
		element,
		getElement
	});

	$$self.$inject_state = $$new_props => {
		if ("use" in $$props) $$invalidate(0, use = $$new_props.use);
		if ("element" in $$props) $$invalidate(1, element = $$new_props.element);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		use,
		element,
		forwardEvents,
		$$restProps,
		getElement,
		$$scope,
		slots,
		span_binding
	];
}

class Span extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$6, create_fragment$6, safe_not_equal, { use: 0, getElement: 4 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Span",
			options,
			id: create_fragment$6.name
		});
	}

	get use() {
		throw new Error("<Span>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set use(value) {
		throw new Error("<Span>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get getElement() {
		return this.$$.ctx[4];
	}

	set getElement(value) {
		throw new Error("<Span>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* packages/image-list/node_modules/@smui/common/CommonLabel.svelte generated by Svelte v3.37.0 */

// (1:0) <svelte:component   this={component}   bind:this={element}   use={[forwardEvents, ...use]}   class={classMap({     [className]: true,     'mdc-button__label': context === 'button',     'mdc-fab__label': context === 'fab',     'mdc-tab__text-label': context === 'tab',     'mdc-image-list__label': context === 'image-list',     'mdc-snackbar__label': context === 'snackbar',     'mdc-banner__text': context === 'banner',     'mdc-segmented-button__label': context === 'segmented-button',     'mdc-data-table__pagination-rows-per-page-label':       context === 'data-table:pagination',     'mdc-data-table__header-cell-label':       context === 'data-table:sortable-header-cell',   })}   {...context === 'snackbar' ? { 'aria-atomic': 'false' } : {}}   {tabindex}   {...$$restProps}>
function create_default_slot$5(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[9].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		l: function claim(nodes) {
			if (default_slot) default_slot.l(nodes);
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 2048) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[11], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$5.name,
		type: "slot",
		source: "(1:0) <svelte:component   this={component}   bind:this={element}   use={[forwardEvents, ...use]}   class={classMap({     [className]: true,     'mdc-button__label': context === 'button',     'mdc-fab__label': context === 'fab',     'mdc-tab__text-label': context === 'tab',     'mdc-image-list__label': context === 'image-list',     'mdc-snackbar__label': context === 'snackbar',     'mdc-banner__text': context === 'banner',     'mdc-segmented-button__label': context === 'segmented-button',     'mdc-data-table__pagination-rows-per-page-label':       context === 'data-table:pagination',     'mdc-data-table__header-cell-label':       context === 'data-table:sortable-header-cell',   })}   {...context === 'snackbar' ? { 'aria-atomic': 'false' } : {}}   {tabindex}   {...$$restProps}>",
		ctx
	});

	return block;
}

function create_fragment$5(ctx) {
	let switch_instance;
	let switch_instance_anchor;
	let current;

	const switch_instance_spread_levels = [
		{
			use: [/*forwardEvents*/ ctx[4], .../*use*/ ctx[0]]
		},
		{
			class: classMap({
				[/*className*/ ctx[1]]: true,
				"mdc-button__label": /*context*/ ctx[5] === "button",
				"mdc-fab__label": /*context*/ ctx[5] === "fab",
				"mdc-tab__text-label": /*context*/ ctx[5] === "tab",
				"mdc-image-list__label": /*context*/ ctx[5] === "image-list",
				"mdc-snackbar__label": /*context*/ ctx[5] === "snackbar",
				"mdc-banner__text": /*context*/ ctx[5] === "banner",
				"mdc-segmented-button__label": /*context*/ ctx[5] === "segmented-button",
				"mdc-data-table__pagination-rows-per-page-label": /*context*/ ctx[5] === "data-table:pagination",
				"mdc-data-table__header-cell-label": /*context*/ ctx[5] === "data-table:sortable-header-cell"
			})
		},
		/*context*/ ctx[5] === "snackbar"
		? { "aria-atomic": "false" }
		: {},
		{ tabindex: /*tabindex*/ ctx[6] },
		/*$$restProps*/ ctx[7]
	];

	var switch_value = /*component*/ ctx[2];

	function switch_props(ctx) {
		let switch_instance_props = {
			$$slots: { default: [create_default_slot$5] },
			$$scope: { ctx }
		};

		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
		}

		return {
			props: switch_instance_props,
			$$inline: true
		};
	}

	if (switch_value) {
		switch_instance = new switch_value(switch_props(ctx));
		/*switch_instance_binding*/ ctx[10](switch_instance);
	}

	const block = {
		c: function create() {
			if (switch_instance) create_component(switch_instance.$$.fragment);
			switch_instance_anchor = empty();
		},
		l: function claim(nodes) {
			if (switch_instance) claim_component(switch_instance.$$.fragment, nodes);
			switch_instance_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (switch_instance) {
				mount_component(switch_instance, target, anchor);
			}

			insert_dev(target, switch_instance_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const switch_instance_changes = (dirty & /*forwardEvents, use, classMap, className, context, tabindex, $$restProps*/ 243)
			? get_spread_update(switch_instance_spread_levels, [
					dirty & /*forwardEvents, use*/ 17 && {
						use: [/*forwardEvents*/ ctx[4], .../*use*/ ctx[0]]
					},
					dirty & /*classMap, className, context*/ 34 && {
						class: classMap({
							[/*className*/ ctx[1]]: true,
							"mdc-button__label": /*context*/ ctx[5] === "button",
							"mdc-fab__label": /*context*/ ctx[5] === "fab",
							"mdc-tab__text-label": /*context*/ ctx[5] === "tab",
							"mdc-image-list__label": /*context*/ ctx[5] === "image-list",
							"mdc-snackbar__label": /*context*/ ctx[5] === "snackbar",
							"mdc-banner__text": /*context*/ ctx[5] === "banner",
							"mdc-segmented-button__label": /*context*/ ctx[5] === "segmented-button",
							"mdc-data-table__pagination-rows-per-page-label": /*context*/ ctx[5] === "data-table:pagination",
							"mdc-data-table__header-cell-label": /*context*/ ctx[5] === "data-table:sortable-header-cell"
						})
					},
					dirty & /*context*/ 32 && get_spread_object(/*context*/ ctx[5] === "snackbar"
					? { "aria-atomic": "false" }
					: {}),
					dirty & /*tabindex*/ 64 && { tabindex: /*tabindex*/ ctx[6] },
					dirty & /*$$restProps*/ 128 && get_spread_object(/*$$restProps*/ ctx[7])
				])
			: {};

			if (dirty & /*$$scope*/ 2048) {
				switch_instance_changes.$$scope = { dirty, ctx };
			}

			if (switch_value !== (switch_value = /*component*/ ctx[2])) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props(ctx));
					/*switch_instance_binding*/ ctx[10](switch_instance);
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}
		},
		i: function intro(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			/*switch_instance_binding*/ ctx[10](null);
			if (detaching) detach_dev(switch_instance_anchor);
			if (switch_instance) destroy_component(switch_instance, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$5.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$5($$self, $$props, $$invalidate) {
	const omit_props_names = ["use","class","component","getElement"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("CommonLabel", slots, ['default']);
	const forwardEvents = forwardEventsBuilder(get_current_component());
	let { use = [] } = $$props;
	let { class: className = "" } = $$props;
	let element;
	let { component = Span } = $$props;
	const context = getContext("SMUI:label:context");
	const tabindex = getContext("SMUI:label:tabindex");

	function getElement() {
		return element.getElement();
	}

	function switch_instance_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			element = $$value;
			$$invalidate(3, element);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("use" in $$new_props) $$invalidate(0, use = $$new_props.use);
		if ("class" in $$new_props) $$invalidate(1, className = $$new_props.class);
		if ("component" in $$new_props) $$invalidate(2, component = $$new_props.component);
		if ("$$scope" in $$new_props) $$invalidate(11, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		getContext,
		get_current_component,
		forwardEventsBuilder,
		classMap,
		useActions,
		Span,
		forwardEvents,
		use,
		className,
		element,
		component,
		context,
		tabindex,
		getElement
	});

	$$self.$inject_state = $$new_props => {
		if ("use" in $$props) $$invalidate(0, use = $$new_props.use);
		if ("className" in $$props) $$invalidate(1, className = $$new_props.className);
		if ("element" in $$props) $$invalidate(3, element = $$new_props.element);
		if ("component" in $$props) $$invalidate(2, component = $$new_props.component);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		use,
		className,
		component,
		element,
		forwardEvents,
		context,
		tabindex,
		$$restProps,
		getElement,
		slots,
		switch_instance_binding,
		$$scope
	];
}

class CommonLabel extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$5, create_fragment$5, safe_not_equal, {
			use: 0,
			class: 1,
			component: 2,
			getElement: 8
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "CommonLabel",
			options,
			id: create_fragment$5.name
		});
	}

	get use() {
		throw new Error("<CommonLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set use(value) {
		throw new Error("<CommonLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error("<CommonLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<CommonLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get component() {
		throw new Error("<CommonLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set component(value) {
		throw new Error("<CommonLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get getElement() {
		return this.$$.ctx[8];
	}

	set getElement(value) {
		throw new Error("<CommonLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/demo/image-list/_Simple.svelte generated by Svelte v3.37.0 */

function get_each_context$3(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[0] = list[i];
	child_ctx[2] = i;
	return child_ctx;
}

// (4:6) <ImageAspectContainer>
function create_default_slot_4$2(ctx) {
	let image;
	let current;

	image = new Image({
			props: {
				src: "https://place-hold.it/190x190?text=square&fontsize=23",
				alt: "Image " + (/*i*/ ctx[2] + 1)
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(image.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(image.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(image, target, anchor);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(image.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(image.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(image, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_4$2.name,
		type: "slot",
		source: "(4:6) <ImageAspectContainer>",
		ctx
	});

	return block;
}

// (11:8) <Label>
function create_default_slot_3$3(ctx) {
	let t0;
	let t1_value = /*i*/ ctx[2] + 1 + "";
	let t1;

	const block = {
		c: function create() {
			t0 = text("Image ");
			t1 = text(t1_value);
		},
		l: function claim(nodes) {
			t0 = claim_text(nodes, "Image ");
			t1 = claim_text(nodes, t1_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			insert_dev(target, t1, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(t1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3$3.name,
		type: "slot",
		source: "(11:8) <Label>",
		ctx
	});

	return block;
}

// (10:6) <Supporting>
function create_default_slot_2$4(ctx) {
	let label;
	let current;

	label = new CommonLabel({
			props: {
				$$slots: { default: [create_default_slot_3$3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(label.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(label.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(label, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const label_changes = {};

			if (dirty & /*$$scope*/ 8) {
				label_changes.$$scope = { dirty, ctx };
			}

			label.$set(label_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(label.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(label.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(label, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2$4.name,
		type: "slot",
		source: "(10:6) <Supporting>",
		ctx
	});

	return block;
}

// (3:4) <Item>
function create_default_slot_1$4(ctx) {
	let imageaspectcontainer;
	let t0;
	let supporting;
	let t1;
	let current;

	imageaspectcontainer = new ImageAspectContainer({
			props: {
				$$slots: { default: [create_default_slot_4$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	supporting = new Supporting({
			props: {
				$$slots: { default: [create_default_slot_2$4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(imageaspectcontainer.$$.fragment);
			t0 = space();
			create_component(supporting.$$.fragment);
			t1 = space();
		},
		l: function claim(nodes) {
			claim_component(imageaspectcontainer.$$.fragment, nodes);
			t0 = claim_space(nodes);
			claim_component(supporting.$$.fragment, nodes);
			t1 = claim_space(nodes);
		},
		m: function mount(target, anchor) {
			mount_component(imageaspectcontainer, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(supporting, target, anchor);
			insert_dev(target, t1, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const imageaspectcontainer_changes = {};

			if (dirty & /*$$scope*/ 8) {
				imageaspectcontainer_changes.$$scope = { dirty, ctx };
			}

			imageaspectcontainer.$set(imageaspectcontainer_changes);
			const supporting_changes = {};

			if (dirty & /*$$scope*/ 8) {
				supporting_changes.$$scope = { dirty, ctx };
			}

			supporting.$set(supporting_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(imageaspectcontainer.$$.fragment, local);
			transition_in(supporting.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(imageaspectcontainer.$$.fragment, local);
			transition_out(supporting.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(imageaspectcontainer, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(supporting, detaching);
			if (detaching) detach_dev(t1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$4.name,
		type: "slot",
		source: "(3:4) <Item>",
		ctx
	});

	return block;
}

// (2:2) {#each Array(15) as _unused, i}
function create_each_block$3(ctx) {
	let item;
	let current;

	item = new Item({
			props: {
				$$slots: { default: [create_default_slot_1$4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(item.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(item.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(item, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const item_changes = {};

			if (dirty & /*$$scope*/ 8) {
				item_changes.$$scope = { dirty, ctx };
			}

			item.$set(item_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(item.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(item.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(item, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$3.name,
		type: "each",
		source: "(2:2) {#each Array(15) as _unused, i}",
		ctx
	});

	return block;
}

// (1:0) <ImageList class="my-image-list-standard">
function create_default_slot$4(ctx) {
	let each_1_anchor;
	let current;
	let each_value = Array(15);
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$4.name,
		type: "slot",
		source: "(1:0) <ImageList class=\\\"my-image-list-standard\\\">",
		ctx
	});

	return block;
}

function create_fragment$4(ctx) {
	let imagelist;
	let current;

	imagelist = new ImageList({
			props: {
				class: "my-image-list-standard",
				$$slots: { default: [create_default_slot$4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(imagelist.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(imagelist.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(imagelist, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const imagelist_changes = {};

			if (dirty & /*$$scope*/ 8) {
				imagelist_changes.$$scope = { dirty, ctx };
			}

			imagelist.$set(imagelist_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(imagelist.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(imagelist.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(imagelist, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Simple", slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Simple> was created with unknown prop '${key}'`);
	});

	$$self.$capture_state = () => ({
		ImageList,
		Item,
		ImageAspectContainer,
		Image,
		Supporting,
		Label: CommonLabel
	});

	return [];
}

class Simple extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4, create_fragment$4, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Simple",
			options,
			id: create_fragment$4.name
		});
	}
}

/* src/routes/demo/image-list/_FourByFive.svelte generated by Svelte v3.37.0 */

function get_each_context$2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[0] = list[i];
	child_ctx[2] = i;
	return child_ctx;
}

// (4:6) <ImageAspectContainer>
function create_default_slot_4$1(ctx) {
	let image;
	let current;

	image = new Image({
			props: {
				src: "https://place-hold.it/190x238?text=4x5&fontsize=23",
				alt: "Image " + (/*i*/ ctx[2] + 1)
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(image.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(image.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(image, target, anchor);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(image.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(image.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(image, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_4$1.name,
		type: "slot",
		source: "(4:6) <ImageAspectContainer>",
		ctx
	});

	return block;
}

// (11:8) <Label>
function create_default_slot_3$2(ctx) {
	let t0;
	let t1_value = /*i*/ ctx[2] + 1 + "";
	let t1;

	const block = {
		c: function create() {
			t0 = text("Image ");
			t1 = text(t1_value);
		},
		l: function claim(nodes) {
			t0 = claim_text(nodes, "Image ");
			t1 = claim_text(nodes, t1_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			insert_dev(target, t1, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(t1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3$2.name,
		type: "slot",
		source: "(11:8) <Label>",
		ctx
	});

	return block;
}

// (10:6) <Supporting>
function create_default_slot_2$3(ctx) {
	let label;
	let current;

	label = new CommonLabel({
			props: {
				$$slots: { default: [create_default_slot_3$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(label.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(label.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(label, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const label_changes = {};

			if (dirty & /*$$scope*/ 8) {
				label_changes.$$scope = { dirty, ctx };
			}

			label.$set(label_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(label.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(label.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(label, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2$3.name,
		type: "slot",
		source: "(10:6) <Supporting>",
		ctx
	});

	return block;
}

// (3:4) <Item>
function create_default_slot_1$3(ctx) {
	let imageaspectcontainer;
	let t0;
	let supporting;
	let t1;
	let current;

	imageaspectcontainer = new ImageAspectContainer({
			props: {
				$$slots: { default: [create_default_slot_4$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	supporting = new Supporting({
			props: {
				$$slots: { default: [create_default_slot_2$3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(imageaspectcontainer.$$.fragment);
			t0 = space();
			create_component(supporting.$$.fragment);
			t1 = space();
		},
		l: function claim(nodes) {
			claim_component(imageaspectcontainer.$$.fragment, nodes);
			t0 = claim_space(nodes);
			claim_component(supporting.$$.fragment, nodes);
			t1 = claim_space(nodes);
		},
		m: function mount(target, anchor) {
			mount_component(imageaspectcontainer, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(supporting, target, anchor);
			insert_dev(target, t1, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const imageaspectcontainer_changes = {};

			if (dirty & /*$$scope*/ 8) {
				imageaspectcontainer_changes.$$scope = { dirty, ctx };
			}

			imageaspectcontainer.$set(imageaspectcontainer_changes);
			const supporting_changes = {};

			if (dirty & /*$$scope*/ 8) {
				supporting_changes.$$scope = { dirty, ctx };
			}

			supporting.$set(supporting_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(imageaspectcontainer.$$.fragment, local);
			transition_in(supporting.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(imageaspectcontainer.$$.fragment, local);
			transition_out(supporting.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(imageaspectcontainer, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(supporting, detaching);
			if (detaching) detach_dev(t1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$3.name,
		type: "slot",
		source: "(3:4) <Item>",
		ctx
	});

	return block;
}

// (2:2) {#each Array(15) as _unused, i}
function create_each_block$2(ctx) {
	let item;
	let current;

	item = new Item({
			props: {
				$$slots: { default: [create_default_slot_1$3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(item.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(item.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(item, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const item_changes = {};

			if (dirty & /*$$scope*/ 8) {
				item_changes.$$scope = { dirty, ctx };
			}

			item.$set(item_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(item.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(item.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(item, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$2.name,
		type: "each",
		source: "(2:2) {#each Array(15) as _unused, i}",
		ctx
	});

	return block;
}

// (1:0) <ImageList class="my-image-list-4x5" withTextProtection>
function create_default_slot$3(ctx) {
	let each_1_anchor;
	let current;
	let each_value = Array(15);
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$3.name,
		type: "slot",
		source: "(1:0) <ImageList class=\\\"my-image-list-4x5\\\" withTextProtection>",
		ctx
	});

	return block;
}

function create_fragment$3(ctx) {
	let imagelist;
	let current;

	imagelist = new ImageList({
			props: {
				class: "my-image-list-4x5",
				withTextProtection: true,
				$$slots: { default: [create_default_slot$3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(imagelist.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(imagelist.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(imagelist, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const imagelist_changes = {};

			if (dirty & /*$$scope*/ 8) {
				imagelist_changes.$$scope = { dirty, ctx };
			}

			imagelist.$set(imagelist_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(imagelist.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(imagelist.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(imagelist, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("FourByFive", slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<FourByFive> was created with unknown prop '${key}'`);
	});

	$$self.$capture_state = () => ({
		ImageList,
		Item,
		ImageAspectContainer,
		Image,
		Supporting,
		Label: CommonLabel
	});

	return [];
}

class FourByFive extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3, create_fragment$3, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "FourByFive",
			options,
			id: create_fragment$3.name
		});
	}
}

/* src/routes/demo/image-list/_Masonry.svelte generated by Svelte v3.37.0 */

function get_each_context$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[0] = list[i];
	child_ctx[2] = i;
	return child_ctx;
}

// (14:8) <Label>
function create_default_slot_3$1(ctx) {
	let t0;
	let t1_value = /*i*/ ctx[2] + 1 + "";
	let t1;

	const block = {
		c: function create() {
			t0 = text("Image ");
			t1 = text(t1_value);
		},
		l: function claim(nodes) {
			t0 = claim_text(nodes, "Image ");
			t1 = claim_text(nodes, t1_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			insert_dev(target, t1, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(t1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3$1.name,
		type: "slot",
		source: "(14:8) <Label>",
		ctx
	});

	return block;
}

// (13:6) <Supporting>
function create_default_slot_2$2(ctx) {
	let label;
	let current;

	label = new CommonLabel({
			props: {
				$$slots: { default: [create_default_slot_3$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(label.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(label.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(label, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const label_changes = {};

			if (dirty & /*$$scope*/ 8) {
				label_changes.$$scope = { dirty, ctx };
			}

			label.$set(label_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(label.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(label.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(label, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2$2.name,
		type: "slot",
		source: "(13:6) <Supporting>",
		ctx
	});

	return block;
}

// (3:4) <Item>
function create_default_slot_1$2(ctx) {
	let image;
	let t0;
	let supporting;
	let t1;
	let current;

	image = new Image({
			props: {
				src: "https://place-hold.it/190x" + getUnevenImageSize$1(/*i*/ ctx[2], 107, 200, Math.abs) + "?text=190x" + getUnevenImageSize$1(/*i*/ ctx[2], 107, 200, Math.abs) + "&fontsize=23",
				alt: "Image " + (/*i*/ ctx[2] + 1)
			},
			$$inline: true
		});

	supporting = new Supporting({
			props: {
				$$slots: { default: [create_default_slot_2$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(image.$$.fragment);
			t0 = space();
			create_component(supporting.$$.fragment);
			t1 = space();
		},
		l: function claim(nodes) {
			claim_component(image.$$.fragment, nodes);
			t0 = claim_space(nodes);
			claim_component(supporting.$$.fragment, nodes);
			t1 = claim_space(nodes);
		},
		m: function mount(target, anchor) {
			mount_component(image, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(supporting, target, anchor);
			insert_dev(target, t1, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const supporting_changes = {};

			if (dirty & /*$$scope*/ 8) {
				supporting_changes.$$scope = { dirty, ctx };
			}

			supporting.$set(supporting_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(image.$$.fragment, local);
			transition_in(supporting.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(image.$$.fragment, local);
			transition_out(supporting.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(image, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(supporting, detaching);
			if (detaching) detach_dev(t1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$2.name,
		type: "slot",
		source: "(3:4) <Item>",
		ctx
	});

	return block;
}

// (2:2) {#each Array(15) as _unused, i}
function create_each_block$1(ctx) {
	let item;
	let current;

	item = new Item({
			props: {
				$$slots: { default: [create_default_slot_1$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(item.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(item.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(item, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const item_changes = {};

			if (dirty & /*$$scope*/ 8) {
				item_changes.$$scope = { dirty, ctx };
			}

			item.$set(item_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(item.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(item.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(item, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$1.name,
		type: "each",
		source: "(2:2) {#each Array(15) as _unused, i}",
		ctx
	});

	return block;
}

// (1:0) <ImageList class="my-image-list-masonry" masonry>
function create_default_slot$2(ctx) {
	let each_1_anchor;
	let current;
	let each_value = Array(15);
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (dirty & /*getUnevenImageSize, Math*/ 0) {
				each_value = Array(15);
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$1(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$1(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$2.name,
		type: "slot",
		source: "(1:0) <ImageList class=\\\"my-image-list-masonry\\\" masonry>",
		ctx
	});

	return block;
}

function create_fragment$2(ctx) {
	let imagelist;
	let current;

	imagelist = new ImageList({
			props: {
				class: "my-image-list-masonry",
				masonry: true,
				$$slots: { default: [create_default_slot$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(imagelist.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(imagelist.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(imagelist, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const imagelist_changes = {};

			if (dirty & /*$$scope*/ 8) {
				imagelist_changes.$$scope = { dirty, ctx };
			}

			imagelist.$set(imagelist_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(imagelist.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(imagelist.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(imagelist, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function getUnevenImageSize$1(counter, base, variance, preAdd = num => num) {
	const mid = (counter % 2 ? Math.cos : Math.sin)(counter) * variance;
	return base + Math.floor(preAdd(mid));
}

function instance$2($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Masonry", slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Masonry> was created with unknown prop '${key}'`);
	});

	$$self.$capture_state = () => ({
		ImageList,
		Item,
		Image,
		Supporting,
		Label: CommonLabel,
		getUnevenImageSize: getUnevenImageSize$1
	});

	return [];
}

class Masonry extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2, create_fragment$2, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Masonry",
			options,
			id: create_fragment$2.name
		});
	}
}

/* src/routes/demo/image-list/_EnforceAspectRatio.svelte generated by Svelte v3.37.0 */

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[0] = list[i];
	child_ctx[2] = i;
	return child_ctx;
}

// (4:6) <ImageAspectContainer>
function create_default_slot_4(ctx) {
	let image;
	let current;

	image = new Image({
			props: {
				component: Div,
				style: "background-image: url(https://place-hold.it/190x" + getUnevenImageSize(/*i*/ ctx[2], 190, 10) + "?text=190x" + getUnevenImageSize(/*i*/ ctx[2], 190, 10) + "&fontsize=23);"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(image.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(image.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(image, target, anchor);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(image.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(image.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(image, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_4.name,
		type: "slot",
		source: "(4:6) <ImageAspectContainer>",
		ctx
	});

	return block;
}

// (15:8) <Label>
function create_default_slot_3(ctx) {
	let t0;
	let t1_value = /*i*/ ctx[2] + 1 + "";
	let t1;

	const block = {
		c: function create() {
			t0 = text("Image ");
			t1 = text(t1_value);
		},
		l: function claim(nodes) {
			t0 = claim_text(nodes, "Image ");
			t1 = claim_text(nodes, t1_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			insert_dev(target, t1, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(t1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3.name,
		type: "slot",
		source: "(15:8) <Label>",
		ctx
	});

	return block;
}

// (14:6) <Supporting>
function create_default_slot_2$1(ctx) {
	let label;
	let current;

	label = new CommonLabel({
			props: {
				$$slots: { default: [create_default_slot_3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(label.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(label.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(label, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const label_changes = {};

			if (dirty & /*$$scope*/ 8) {
				label_changes.$$scope = { dirty, ctx };
			}

			label.$set(label_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(label.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(label.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(label, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2$1.name,
		type: "slot",
		source: "(14:6) <Supporting>",
		ctx
	});

	return block;
}

// (3:4) <Item>
function create_default_slot_1$1(ctx) {
	let imageaspectcontainer;
	let t0;
	let supporting;
	let t1;
	let current;

	imageaspectcontainer = new ImageAspectContainer({
			props: {
				$$slots: { default: [create_default_slot_4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	supporting = new Supporting({
			props: {
				$$slots: { default: [create_default_slot_2$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(imageaspectcontainer.$$.fragment);
			t0 = space();
			create_component(supporting.$$.fragment);
			t1 = space();
		},
		l: function claim(nodes) {
			claim_component(imageaspectcontainer.$$.fragment, nodes);
			t0 = claim_space(nodes);
			claim_component(supporting.$$.fragment, nodes);
			t1 = claim_space(nodes);
		},
		m: function mount(target, anchor) {
			mount_component(imageaspectcontainer, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(supporting, target, anchor);
			insert_dev(target, t1, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const imageaspectcontainer_changes = {};

			if (dirty & /*$$scope*/ 8) {
				imageaspectcontainer_changes.$$scope = { dirty, ctx };
			}

			imageaspectcontainer.$set(imageaspectcontainer_changes);
			const supporting_changes = {};

			if (dirty & /*$$scope*/ 8) {
				supporting_changes.$$scope = { dirty, ctx };
			}

			supporting.$set(supporting_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(imageaspectcontainer.$$.fragment, local);
			transition_in(supporting.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(imageaspectcontainer.$$.fragment, local);
			transition_out(supporting.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(imageaspectcontainer, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(supporting, detaching);
			if (detaching) detach_dev(t1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$1.name,
		type: "slot",
		source: "(3:4) <Item>",
		ctx
	});

	return block;
}

// (2:2) {#each Array(15) as _unused, i}
function create_each_block(ctx) {
	let item;
	let current;

	item = new Item({
			props: {
				$$slots: { default: [create_default_slot_1$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(item.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(item.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(item, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const item_changes = {};

			if (dirty & /*$$scope*/ 8) {
				item_changes.$$scope = { dirty, ctx };
			}

			item.$set(item_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(item.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(item.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(item, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(2:2) {#each Array(15) as _unused, i}",
		ctx
	});

	return block;
}

// (1:0) <ImageList class="my-image-list-enforce-ratio">
function create_default_slot$1(ctx) {
	let each_1_anchor;
	let current;
	let each_value = Array(15);
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (dirty & /*Div, getUnevenImageSize*/ 0) {
				each_value = Array(15);
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$1.name,
		type: "slot",
		source: "(1:0) <ImageList class=\\\"my-image-list-enforce-ratio\\\">",
		ctx
	});

	return block;
}

function create_fragment$1(ctx) {
	let imagelist;
	let current;

	imagelist = new ImageList({
			props: {
				class: "my-image-list-enforce-ratio",
				$$slots: { default: [create_default_slot$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(imagelist.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(imagelist.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(imagelist, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const imagelist_changes = {};

			if (dirty & /*$$scope*/ 8) {
				imagelist_changes.$$scope = { dirty, ctx };
			}

			imagelist.$set(imagelist_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(imagelist.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(imagelist.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(imagelist, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function getUnevenImageSize(counter, base, variance, preAdd = num => num) {
	const mid = (counter % 2 ? Math.cos : Math.sin)(counter) * variance;
	return base + Math.floor(preAdd(mid));
}

function instance$1($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("EnforceAspectRatio", slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<EnforceAspectRatio> was created with unknown prop '${key}'`);
	});

	$$self.$capture_state = () => ({
		ImageList,
		Item,
		ImageAspectContainer,
		Image,
		Supporting,
		Label: CommonLabel,
		Div,
		getUnevenImageSize
	});

	return [];
}

class EnforceAspectRatio extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$1, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "EnforceAspectRatio",
			options,
			id: create_fragment$1.name
		});
	}
}

/* src/routes/demo/image-list/index.svelte generated by Svelte v3.37.0 */
const file = "src/routes/demo/image-list/index.svelte";

// (15:2) <Demo     component={FourByFive}     files={['image-list/_FourByFive.svelte', 'image-list/_FourByFive.scss']}   >
function create_default_slot_2(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("4x5 aspect ratio, with text protection");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "4x5 aspect ratio, with text protection");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2.name,
		type: "slot",
		source: "(15:2) <Demo     component={FourByFive}     files={['image-list/_FourByFive.svelte', 'image-list/_FourByFive.scss']}   >",
		ctx
	});

	return block;
}

// (22:2) <Demo     component={Masonry}     files={['image-list/_Masonry.svelte', 'image-list/_Masonry.scss']}   >
function create_default_slot_1(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Masonry, with rounded shapes");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Masonry, with rounded shapes");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1.name,
		type: "slot",
		source: "(22:2) <Demo     component={Masonry}     files={['image-list/_Masonry.svelte', 'image-list/_Masonry.scss']}   >",
		ctx
	});

	return block;
}

// (29:2) <Demo     component={EnforceAspectRatio}     files={[       'image-list/_EnforceAspectRatio.svelte',       'image-list/_EnforceAspectRatio.scss',     ]}   >
function create_default_slot(ctx) {
	let t0;
	let code0;
	let t1;
	let t2;
	let code1;
	let t3;
	let t4;

	const block = {
		c: function create() {
			t0 = text("Using a ");
			code0 = element("code");
			t1 = text("div");
			t2 = text(" instead of an ");
			code1 = element("code");
			t3 = text("img");
			t4 = text(" to enforce aspect ratio");
			this.h();
		},
		l: function claim(nodes) {
			t0 = claim_text(nodes, "Using a ");
			code0 = claim_element(nodes, "CODE", {});
			var code0_nodes = children(code0);
			t1 = claim_text(code0_nodes, "div");
			code0_nodes.forEach(detach_dev);
			t2 = claim_text(nodes, " instead of an ");
			code1 = claim_element(nodes, "CODE", {});
			var code1_nodes = children(code1);
			t3 = claim_text(code1_nodes, "img");
			code1_nodes.forEach(detach_dev);
			t4 = claim_text(nodes, " to enforce aspect ratio");
			this.h();
		},
		h: function hydrate() {
			add_location(code0, file, 35, 12, 758);
			add_location(code1, file, 35, 43, 789);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			insert_dev(target, code0, anchor);
			append_dev(code0, t1);
			insert_dev(target, t2, anchor);
			insert_dev(target, code1, anchor);
			append_dev(code1, t3);
			insert_dev(target, t4, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(code0);
			if (detaching) detach_dev(t2);
			if (detaching) detach_dev(code1);
			if (detaching) detach_dev(t4);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(29:2) <Demo     component={EnforceAspectRatio}     files={[       'image-list/_EnforceAspectRatio.svelte',       'image-list/_EnforceAspectRatio.scss',     ]}   >",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let t0;
	let section;
	let h2;
	let t1;
	let t2;
	let pre;
	let t3;
	let t4;
	let demo0;
	let t5;
	let demo1;
	let t6;
	let demo2;
	let t7;
	let demo3;
	let current;

	demo0 = new Demo({
			props: {
				component: Simple,
				files: ["image-list/_Simple.svelte", "image-list/_Simple.scss"]
			},
			$$inline: true
		});

	demo1 = new Demo({
			props: {
				component: FourByFive,
				files: ["image-list/_FourByFive.svelte", "image-list/_FourByFive.scss"],
				$$slots: { default: [create_default_slot_2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	demo2 = new Demo({
			props: {
				component: Masonry,
				files: ["image-list/_Masonry.svelte", "image-list/_Masonry.scss"],
				$$slots: { default: [create_default_slot_1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	demo3 = new Demo({
			props: {
				component: EnforceAspectRatio,
				files: [
					"image-list/_EnforceAspectRatio.svelte",
					"image-list/_EnforceAspectRatio.scss"
				],
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			t0 = space();
			section = element("section");
			h2 = element("h2");
			t1 = text("Image Lists");
			t2 = space();
			pre = element("pre");
			t3 = text("npm i -D @smui/image-list");
			t4 = space();
			create_component(demo0.$$.fragment);
			t5 = space();
			create_component(demo1.$$.fragment);
			t6 = space();
			create_component(demo2.$$.fragment);
			t7 = space();
			create_component(demo3.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			const head_nodes = query_selector_all("[data-svelte=\"svelte-wkf4yw\"]", document.head);
			head_nodes.forEach(detach_dev);
			t0 = claim_space(nodes);
			section = claim_element(nodes, "SECTION", {});
			var section_nodes = children(section);
			h2 = claim_element(section_nodes, "H2", {});
			var h2_nodes = children(h2);
			t1 = claim_text(h2_nodes, "Image Lists");
			h2_nodes.forEach(detach_dev);
			t2 = claim_space(section_nodes);
			pre = claim_element(section_nodes, "PRE", { class: true });
			var pre_nodes = children(pre);
			t3 = claim_text(pre_nodes, "npm i -D @smui/image-list");
			pre_nodes.forEach(detach_dev);
			t4 = claim_space(section_nodes);
			claim_component(demo0.$$.fragment, section_nodes);
			t5 = claim_space(section_nodes);
			claim_component(demo1.$$.fragment, section_nodes);
			t6 = claim_space(section_nodes);
			claim_component(demo2.$$.fragment, section_nodes);
			t7 = claim_space(section_nodes);
			claim_component(demo3.$$.fragment, section_nodes);
			section_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			document.title = "Image Lists - SMUI";
			add_location(h2, file, 5, 2, 78);
			attr_dev(pre, "class", "demo-spaced");
			add_location(pre, file, 7, 2, 102);
			add_location(section, file, 4, 0, 66);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			insert_dev(target, section, anchor);
			append_dev(section, h2);
			append_dev(h2, t1);
			append_dev(section, t2);
			append_dev(section, pre);
			append_dev(pre, t3);
			append_dev(section, t4);
			mount_component(demo0, section, null);
			append_dev(section, t5);
			mount_component(demo1, section, null);
			append_dev(section, t6);
			mount_component(demo2, section, null);
			append_dev(section, t7);
			mount_component(demo3, section, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const demo1_changes = {};

			if (dirty & /*$$scope*/ 1) {
				demo1_changes.$$scope = { dirty, ctx };
			}

			demo1.$set(demo1_changes);
			const demo2_changes = {};

			if (dirty & /*$$scope*/ 1) {
				demo2_changes.$$scope = { dirty, ctx };
			}

			demo2.$set(demo2_changes);
			const demo3_changes = {};

			if (dirty & /*$$scope*/ 1) {
				demo3_changes.$$scope = { dirty, ctx };
			}

			demo3.$set(demo3_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(demo0.$$.fragment, local);
			transition_in(demo1.$$.fragment, local);
			transition_in(demo2.$$.fragment, local);
			transition_in(demo3.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(demo0.$$.fragment, local);
			transition_out(demo1.$$.fragment, local);
			transition_out(demo2.$$.fragment, local);
			transition_out(demo3.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(section);
			destroy_component(demo0);
			destroy_component(demo1);
			destroy_component(demo2);
			destroy_component(demo3);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Image_list", slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Image_list> was created with unknown prop '${key}'`);
	});

	$$self.$capture_state = () => ({
		Demo,
		Simple,
		FourByFive,
		Masonry,
		EnforceAspectRatio
	});

	return [];
}

class Image_list extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Image_list",
			options,
			id: create_fragment.name
		});
	}
}

export default Image_list;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguMTA1NzkxMTMuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3BhY2thZ2VzL2ltYWdlLWxpc3Qvbm9kZV9tb2R1bGVzL0BzbXVpL2NvbW1vbi9TcGFuLnN2ZWx0ZSIsIi4uLy4uLy4uL3BhY2thZ2VzL2ltYWdlLWxpc3Qvbm9kZV9tb2R1bGVzL0BzbXVpL2NvbW1vbi9Db21tb25MYWJlbC5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvcm91dGVzL2RlbW8vaW1hZ2UtbGlzdC9fU2ltcGxlLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9yb3V0ZXMvZGVtby9pbWFnZS1saXN0L19Gb3VyQnlGaXZlLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9yb3V0ZXMvZGVtby9pbWFnZS1saXN0L19NYXNvbnJ5LnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9yb3V0ZXMvZGVtby9pbWFnZS1saXN0L19FbmZvcmNlQXNwZWN0UmF0aW8uc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL3JvdXRlcy9kZW1vL2ltYWdlLWxpc3QvaW5kZXguc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbIjxzcGFuXG4gIGJpbmQ6dGhpcz17ZWxlbWVudH1cbiAgdXNlOnVzZUFjdGlvbnM9e3VzZX1cbiAgdXNlOmZvcndhcmRFdmVudHNcbiAgey4uLiQkcmVzdFByb3BzfT48c2xvdCAvPjwvc3BhblxuPlxuXG48c2NyaXB0PlxuICBpbXBvcnQgeyBnZXRfY3VycmVudF9jb21wb25lbnQgfSBmcm9tICdzdmVsdGUvaW50ZXJuYWwnO1xuICBpbXBvcnQgeyBmb3J3YXJkRXZlbnRzQnVpbGRlciwgdXNlQWN0aW9ucyB9IGZyb20gJy4vaW50ZXJuYWwuanMnO1xuXG4gIGV4cG9ydCBsZXQgdXNlID0gW107XG5cbiAgY29uc3QgZm9yd2FyZEV2ZW50cyA9IGZvcndhcmRFdmVudHNCdWlsZGVyKGdldF9jdXJyZW50X2NvbXBvbmVudCgpKTtcblxuICBsZXQgZWxlbWVudCA9IG51bGw7XG5cbiAgZXhwb3J0IGZ1bmN0aW9uIGdldEVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbjwvc2NyaXB0PlxuIiwiPHN2ZWx0ZTpjb21wb25lbnRcbiAgdGhpcz17Y29tcG9uZW50fVxuICBiaW5kOnRoaXM9e2VsZW1lbnR9XG4gIHVzZT17W2ZvcndhcmRFdmVudHMsIC4uLnVzZV19XG4gIGNsYXNzPXtjbGFzc01hcCh7XG4gICAgW2NsYXNzTmFtZV06IHRydWUsXG4gICAgJ21kYy1idXR0b25fX2xhYmVsJzogY29udGV4dCA9PT0gJ2J1dHRvbicsXG4gICAgJ21kYy1mYWJfX2xhYmVsJzogY29udGV4dCA9PT0gJ2ZhYicsXG4gICAgJ21kYy10YWJfX3RleHQtbGFiZWwnOiBjb250ZXh0ID09PSAndGFiJyxcbiAgICAnbWRjLWltYWdlLWxpc3RfX2xhYmVsJzogY29udGV4dCA9PT0gJ2ltYWdlLWxpc3QnLFxuICAgICdtZGMtc25hY2tiYXJfX2xhYmVsJzogY29udGV4dCA9PT0gJ3NuYWNrYmFyJyxcbiAgICAnbWRjLWJhbm5lcl9fdGV4dCc6IGNvbnRleHQgPT09ICdiYW5uZXInLFxuICAgICdtZGMtc2VnbWVudGVkLWJ1dHRvbl9fbGFiZWwnOiBjb250ZXh0ID09PSAnc2VnbWVudGVkLWJ1dHRvbicsXG4gICAgJ21kYy1kYXRhLXRhYmxlX19wYWdpbmF0aW9uLXJvd3MtcGVyLXBhZ2UtbGFiZWwnOlxuICAgICAgY29udGV4dCA9PT0gJ2RhdGEtdGFibGU6cGFnaW5hdGlvbicsXG4gICAgJ21kYy1kYXRhLXRhYmxlX19oZWFkZXItY2VsbC1sYWJlbCc6XG4gICAgICBjb250ZXh0ID09PSAnZGF0YS10YWJsZTpzb3J0YWJsZS1oZWFkZXItY2VsbCcsXG4gIH0pfVxuICB7Li4uY29udGV4dCA9PT0gJ3NuYWNrYmFyJyA/IHsgJ2FyaWEtYXRvbWljJzogJ2ZhbHNlJyB9IDoge319XG4gIHt0YWJpbmRleH1cbiAgey4uLiQkcmVzdFByb3BzfT48c2xvdCAvPjwvc3ZlbHRlOmNvbXBvbmVudFxuPlxuXG48c2NyaXB0PlxuICBpbXBvcnQgeyBnZXRDb250ZXh0IH0gZnJvbSAnc3ZlbHRlJztcbiAgaW1wb3J0IHsgZ2V0X2N1cnJlbnRfY29tcG9uZW50IH0gZnJvbSAnc3ZlbHRlL2ludGVybmFsJztcbiAgaW1wb3J0IHsgZm9yd2FyZEV2ZW50c0J1aWxkZXIsIGNsYXNzTWFwLCB1c2VBY3Rpb25zIH0gZnJvbSAnLi9pbnRlcm5hbC5qcyc7XG4gIGltcG9ydCBTcGFuIGZyb20gJy4vU3Bhbi5zdmVsdGUnO1xuXG4gIGNvbnN0IGZvcndhcmRFdmVudHMgPSBmb3J3YXJkRXZlbnRzQnVpbGRlcihnZXRfY3VycmVudF9jb21wb25lbnQoKSk7XG5cbiAgZXhwb3J0IGxldCB1c2UgPSBbXTtcbiAgbGV0IGNsYXNzTmFtZSA9ICcnO1xuICBleHBvcnQgeyBjbGFzc05hbWUgYXMgY2xhc3MgfTtcblxuICBsZXQgZWxlbWVudDtcblxuICBleHBvcnQgbGV0IGNvbXBvbmVudCA9IFNwYW47XG5cbiAgY29uc3QgY29udGV4dCA9IGdldENvbnRleHQoJ1NNVUk6bGFiZWw6Y29udGV4dCcpO1xuICBjb25zdCB0YWJpbmRleCA9IGdldENvbnRleHQoJ1NNVUk6bGFiZWw6dGFiaW5kZXgnKTtcblxuICBleHBvcnQgZnVuY3Rpb24gZ2V0RWxlbWVudCgpIHtcbiAgICByZXR1cm4gZWxlbWVudC5nZXRFbGVtZW50KCk7XG4gIH1cbjwvc2NyaXB0PlxuIiwiPEltYWdlTGlzdCBjbGFzcz1cIm15LWltYWdlLWxpc3Qtc3RhbmRhcmRcIj5cbiAgeyNlYWNoIEFycmF5KDE1KSBhcyBfdW51c2VkLCBpfVxuICAgIDxJdGVtPlxuICAgICAgPEltYWdlQXNwZWN0Q29udGFpbmVyPlxuICAgICAgICA8SW1hZ2VcbiAgICAgICAgICBzcmM9XCJodHRwczovL3BsYWNlLWhvbGQuaXQvMTkweDE5MD90ZXh0PXNxdWFyZSZmb250c2l6ZT0yM1wiXG4gICAgICAgICAgYWx0PVwiSW1hZ2Uge2kgKyAxfVwiXG4gICAgICAgIC8+XG4gICAgICA8L0ltYWdlQXNwZWN0Q29udGFpbmVyPlxuICAgICAgPFN1cHBvcnRpbmc+XG4gICAgICAgIDxMYWJlbD5JbWFnZSB7aSArIDF9PC9MYWJlbD5cbiAgICAgIDwvU3VwcG9ydGluZz5cbiAgICA8L0l0ZW0+XG4gIHsvZWFjaH1cbjwvSW1hZ2VMaXN0PlxuXG48c2NyaXB0PlxuICBpbXBvcnQgSW1hZ2VMaXN0LCB7XG4gICAgSXRlbSxcbiAgICBJbWFnZUFzcGVjdENvbnRhaW5lcixcbiAgICBJbWFnZSxcbiAgICBTdXBwb3J0aW5nLFxuICAgIExhYmVsLFxuICB9IGZyb20gJ0BzbXVpL2ltYWdlLWxpc3QnO1xuPC9zY3JpcHQ+XG4iLCI8SW1hZ2VMaXN0IGNsYXNzPVwibXktaW1hZ2UtbGlzdC00eDVcIiB3aXRoVGV4dFByb3RlY3Rpb24+XG4gIHsjZWFjaCBBcnJheSgxNSkgYXMgX3VudXNlZCwgaX1cbiAgICA8SXRlbT5cbiAgICAgIDxJbWFnZUFzcGVjdENvbnRhaW5lcj5cbiAgICAgICAgPEltYWdlXG4gICAgICAgICAgc3JjPVwiaHR0cHM6Ly9wbGFjZS1ob2xkLml0LzE5MHgyMzg/dGV4dD00eDUmZm9udHNpemU9MjNcIlxuICAgICAgICAgIGFsdD1cIkltYWdlIHtpICsgMX1cIlxuICAgICAgICAvPlxuICAgICAgPC9JbWFnZUFzcGVjdENvbnRhaW5lcj5cbiAgICAgIDxTdXBwb3J0aW5nPlxuICAgICAgICA8TGFiZWw+SW1hZ2Uge2kgKyAxfTwvTGFiZWw+XG4gICAgICA8L1N1cHBvcnRpbmc+XG4gICAgPC9JdGVtPlxuICB7L2VhY2h9XG48L0ltYWdlTGlzdD5cblxuPHNjcmlwdD5cbiAgaW1wb3J0IEltYWdlTGlzdCwge1xuICAgIEl0ZW0sXG4gICAgSW1hZ2VBc3BlY3RDb250YWluZXIsXG4gICAgSW1hZ2UsXG4gICAgU3VwcG9ydGluZyxcbiAgICBMYWJlbCxcbiAgfSBmcm9tICdAc211aS9pbWFnZS1saXN0Jztcbjwvc2NyaXB0PlxuIiwiPEltYWdlTGlzdCBjbGFzcz1cIm15LWltYWdlLWxpc3QtbWFzb25yeVwiIG1hc29ucnk+XG4gIHsjZWFjaCBBcnJheSgxNSkgYXMgX3VudXNlZCwgaX1cbiAgICA8SXRlbT5cbiAgICAgIDxJbWFnZVxuICAgICAgICBzcmM9XCJodHRwczovL3BsYWNlLWhvbGQuaXQvMTkweHtnZXRVbmV2ZW5JbWFnZVNpemUoXG4gICAgICAgICAgaSxcbiAgICAgICAgICAxMDcsXG4gICAgICAgICAgMjAwLFxuICAgICAgICAgIE1hdGguYWJzXG4gICAgICAgICl9P3RleHQ9MTkweHtnZXRVbmV2ZW5JbWFnZVNpemUoaSwgMTA3LCAyMDAsIE1hdGguYWJzKX0mZm9udHNpemU9MjNcIlxuICAgICAgICBhbHQ9XCJJbWFnZSB7aSArIDF9XCJcbiAgICAgIC8+XG4gICAgICA8U3VwcG9ydGluZz5cbiAgICAgICAgPExhYmVsPkltYWdlIHtpICsgMX08L0xhYmVsPlxuICAgICAgPC9TdXBwb3J0aW5nPlxuICAgIDwvSXRlbT5cbiAgey9lYWNofVxuPC9JbWFnZUxpc3Q+XG5cbjxzY3JpcHQ+XG4gIGltcG9ydCBJbWFnZUxpc3QsIHsgSXRlbSwgSW1hZ2UsIFN1cHBvcnRpbmcsIExhYmVsIH0gZnJvbSAnQHNtdWkvaW1hZ2UtbGlzdCc7XG5cbiAgZnVuY3Rpb24gZ2V0VW5ldmVuSW1hZ2VTaXplKGNvdW50ZXIsIGJhc2UsIHZhcmlhbmNlLCBwcmVBZGQgPSAobnVtKSA9PiBudW0pIHtcbiAgICBjb25zdCBtaWQgPSAoY291bnRlciAlIDIgPyBNYXRoLmNvcyA6IE1hdGguc2luKShjb3VudGVyKSAqIHZhcmlhbmNlO1xuICAgIHJldHVybiBiYXNlICsgTWF0aC5mbG9vcihwcmVBZGQobWlkKSk7XG4gIH1cbjwvc2NyaXB0PlxuIiwiPEltYWdlTGlzdCBjbGFzcz1cIm15LWltYWdlLWxpc3QtZW5mb3JjZS1yYXRpb1wiPlxuICB7I2VhY2ggQXJyYXkoMTUpIGFzIF91bnVzZWQsIGl9XG4gICAgPEl0ZW0+XG4gICAgICA8SW1hZ2VBc3BlY3RDb250YWluZXI+XG4gICAgICAgIDxJbWFnZVxuICAgICAgICAgIGNvbXBvbmVudD17RGl2fVxuICAgICAgICAgIHN0eWxlPVwiYmFja2dyb3VuZC1pbWFnZTogdXJsKGh0dHBzOi8vcGxhY2UtaG9sZC5pdC8xOTB4e2dldFVuZXZlbkltYWdlU2l6ZShcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICAxOTAsXG4gICAgICAgICAgICAxMFxuICAgICAgICAgICl9P3RleHQ9MTkweHtnZXRVbmV2ZW5JbWFnZVNpemUoaSwgMTkwLCAxMCl9JmZvbnRzaXplPTIzKTtcIlxuICAgICAgICAvPlxuICAgICAgPC9JbWFnZUFzcGVjdENvbnRhaW5lcj5cbiAgICAgIDxTdXBwb3J0aW5nPlxuICAgICAgICA8TGFiZWw+SW1hZ2Uge2kgKyAxfTwvTGFiZWw+XG4gICAgICA8L1N1cHBvcnRpbmc+XG4gICAgPC9JdGVtPlxuICB7L2VhY2h9XG48L0ltYWdlTGlzdD5cblxuPHNjcmlwdD5cbiAgaW1wb3J0IEltYWdlTGlzdCwge1xuICAgIEl0ZW0sXG4gICAgSW1hZ2VBc3BlY3RDb250YWluZXIsXG4gICAgSW1hZ2UsXG4gICAgU3VwcG9ydGluZyxcbiAgICBMYWJlbCxcbiAgfSBmcm9tICdAc211aS9pbWFnZS1saXN0JztcbiAgaW1wb3J0IERpdiBmcm9tICdAc211aS9jb21tb24vRGl2LnN2ZWx0ZSc7XG5cbiAgZnVuY3Rpb24gZ2V0VW5ldmVuSW1hZ2VTaXplKGNvdW50ZXIsIGJhc2UsIHZhcmlhbmNlLCBwcmVBZGQgPSAobnVtKSA9PiBudW0pIHtcbiAgICBjb25zdCBtaWQgPSAoY291bnRlciAlIDIgPyBNYXRoLmNvcyA6IE1hdGguc2luKShjb3VudGVyKSAqIHZhcmlhbmNlO1xuICAgIHJldHVybiBiYXNlICsgTWF0aC5mbG9vcihwcmVBZGQobWlkKSk7XG4gIH1cbjwvc2NyaXB0PlxuIiwiPHN2ZWx0ZTpoZWFkPlxuICA8dGl0bGU+SW1hZ2UgTGlzdHMgLSBTTVVJPC90aXRsZT5cbjwvc3ZlbHRlOmhlYWQ+XG5cbjxzZWN0aW9uPlxuICA8aDI+SW1hZ2UgTGlzdHM8L2gyPlxuXG4gIDxwcmUgY2xhc3M9XCJkZW1vLXNwYWNlZFwiPm5wbSBpIC1EIEBzbXVpL2ltYWdlLWxpc3Q8L3ByZT5cblxuICA8RGVtb1xuICAgIGNvbXBvbmVudD17U2ltcGxlfVxuICAgIGZpbGVzPXtbJ2ltYWdlLWxpc3QvX1NpbXBsZS5zdmVsdGUnLCAnaW1hZ2UtbGlzdC9fU2ltcGxlLnNjc3MnXX1cbiAgLz5cblxuICA8RGVtb1xuICAgIGNvbXBvbmVudD17Rm91ckJ5Rml2ZX1cbiAgICBmaWxlcz17WydpbWFnZS1saXN0L19Gb3VyQnlGaXZlLnN2ZWx0ZScsICdpbWFnZS1saXN0L19Gb3VyQnlGaXZlLnNjc3MnXX1cbiAgPlxuICAgIDR4NSBhc3BlY3QgcmF0aW8sIHdpdGggdGV4dCBwcm90ZWN0aW9uXG4gIDwvRGVtbz5cblxuICA8RGVtb1xuICAgIGNvbXBvbmVudD17TWFzb25yeX1cbiAgICBmaWxlcz17WydpbWFnZS1saXN0L19NYXNvbnJ5LnN2ZWx0ZScsICdpbWFnZS1saXN0L19NYXNvbnJ5LnNjc3MnXX1cbiAgPlxuICAgIE1hc29ucnksIHdpdGggcm91bmRlZCBzaGFwZXNcbiAgPC9EZW1vPlxuXG4gIDxEZW1vXG4gICAgY29tcG9uZW50PXtFbmZvcmNlQXNwZWN0UmF0aW99XG4gICAgZmlsZXM9e1tcbiAgICAgICdpbWFnZS1saXN0L19FbmZvcmNlQXNwZWN0UmF0aW8uc3ZlbHRlJyxcbiAgICAgICdpbWFnZS1saXN0L19FbmZvcmNlQXNwZWN0UmF0aW8uc2NzcycsXG4gICAgXX1cbiAgPlxuICAgIFVzaW5nIGEgPGNvZGU+ZGl2PC9jb2RlPiBpbnN0ZWFkIG9mIGFuIDxjb2RlPmltZzwvY29kZT4gdG8gZW5mb3JjZSBhc3BlY3QgcmF0aW9cbiAgPC9EZW1vPlxuPC9zZWN0aW9uPlxuXG48c2NyaXB0PlxuICBpbXBvcnQgRGVtbyBmcm9tICcuLi8uLi8uLi9jb21wb25lbnRzL0RlbW8uc3ZlbHRlJztcbiAgaW1wb3J0IFNpbXBsZSBmcm9tICcuL19TaW1wbGUuc3ZlbHRlJztcbiAgaW1wb3J0IEZvdXJCeUZpdmUgZnJvbSAnLi9fRm91ckJ5Rml2ZS5zdmVsdGUnO1xuICBpbXBvcnQgTWFzb25yeSBmcm9tICcuL19NYXNvbnJ5LnN2ZWx0ZSc7XG4gIGltcG9ydCBFbmZvcmNlQXNwZWN0UmF0aW8gZnJvbSAnLi9fRW5mb3JjZUFzcGVjdFJhdGlvLnN2ZWx0ZSc7XG48L3NjcmlwdD5cbiJdLCJuYW1lcyI6WyJnZXRVbmV2ZW5JbWFnZVNpemUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7b0NBSU0sR0FBVzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzhFQUZDLEdBQUc7Ozs7Ozs7Ozs7Ozs7O2lIQUVmLEdBQVc7b0lBRkMsR0FBRzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BU1IsR0FBRztPQUVSLGFBQWEsR0FBRyxvQkFBb0IsQ0FBQyxxQkFBcUI7S0FFNUQsT0FBTyxHQUFHLElBQUk7O1VBRUYsVUFBVTtTQUNqQixPQUFPOzs7OztHQWpCTCxPQUFPOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsyQkNFWixHQUFhLGdCQUFLLEdBQUc7OztVQUNwQixRQUFRO21CQUNaLEdBQVMsTUFBRyxJQUFJO0lBQ2pCLG1CQUFtQixjQUFFLEdBQU8sUUFBSyxRQUFRO0lBQ3pDLGdCQUFnQixjQUFFLEdBQU8sUUFBSyxLQUFLO0lBQ25DLHFCQUFxQixjQUFFLEdBQU8sUUFBSyxLQUFLO0lBQ3hDLHVCQUF1QixjQUFFLEdBQU8sUUFBSyxZQUFZO0lBQ2pELHFCQUFxQixjQUFFLEdBQU8sUUFBSyxVQUFVO0lBQzdDLGtCQUFrQixjQUFFLEdBQU8sUUFBSyxRQUFRO0lBQ3hDLDZCQUE2QixjQUFFLEdBQU8sUUFBSyxrQkFBa0I7SUFDN0QsZ0RBQWdELGNBQzlDLEdBQU8sUUFBSyx1QkFBdUI7SUFDckMsbUNBQW1DLGNBQ2pDLEdBQU8sUUFBSyxpQ0FBaUM7OztjQUU3QyxHQUFPLFFBQUssVUFBVTtNQUFLLGFBQWEsRUFBRSxPQUFPOzs7a0JBRWpELEdBQVc7OztrQ0FuQlQsR0FBUzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OEJBRVQsR0FBYSxnQkFBSyxHQUFHOzs7YUFDcEIsUUFBUTtzQkFDWixHQUFTLE1BQUcsSUFBSTtPQUNqQixtQkFBbUIsY0FBRSxHQUFPLFFBQUssUUFBUTtPQUN6QyxnQkFBZ0IsY0FBRSxHQUFPLFFBQUssS0FBSztPQUNuQyxxQkFBcUIsY0FBRSxHQUFPLFFBQUssS0FBSztPQUN4Qyx1QkFBdUIsY0FBRSxHQUFPLFFBQUssWUFBWTtPQUNqRCxxQkFBcUIsY0FBRSxHQUFPLFFBQUssVUFBVTtPQUM3QyxrQkFBa0IsY0FBRSxHQUFPLFFBQUssUUFBUTtPQUN4Qyw2QkFBNkIsY0FBRSxHQUFPLFFBQUssa0JBQWtCO09BQzdELGdEQUFnRCxjQUM5QyxHQUFPLFFBQUssdUJBQXVCO09BQ3JDLG1DQUFtQyxjQUNqQyxHQUFPLFFBQUssaUNBQWlDOzs7NkRBRTdDLEdBQU8sUUFBSyxVQUFVO1NBQUssYUFBYSxFQUFFLE9BQU87OztzRUFFakQsR0FBVzs7Ozs7Ozs7c0RBbkJULEdBQVM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQTRCVCxhQUFhLEdBQUcsb0JBQW9CLENBQUMscUJBQXFCO09BRXJELEdBQUc7Y0FDVixTQUFTLEdBQUcsRUFBRTtLQUdkLE9BQU87T0FFQSxTQUFTLEdBQUcsSUFBSTtPQUVyQixPQUFPLEdBQUcsVUFBVSxDQUFDLG9CQUFvQjtPQUN6QyxRQUFRLEdBQUcsVUFBVSxDQUFDLHFCQUFxQjs7VUFFakMsVUFBVTtTQUNqQixPQUFPLENBQUMsVUFBVTs7Ozs7R0F6Q2hCLE9BQU87Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MkJDSUUsR0FBQyxNQUFHLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztzQkFJTCxHQUFDLE1BQUcsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztrQkFUbEIsS0FBSyxDQUFDLEVBQUU7Ozs7Z0NBQWIsTUFBSTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztrQ0FBSixNQUFJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzJCQ0tjLEdBQUMsTUFBRyxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7c0JBSUwsR0FBQyxNQUFHLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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
