import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, aR as classMap, W as compute_rest_props, v as validate_slots, X as getContext, aP as forwardEventsBuilder, Y as get_current_component, Z as setContext, _ as onDestroy, $ as assign, a0 as exclude_internal_props, q as create_component, a1 as empty, A as claim_component, H as mount_component, F as insert_dev, a2 as get_spread_update, a3 as get_spread_object, a4 as group_outros, K as transition_out, M as destroy_component, a5 as check_outros, J as transition_in, u as detach_dev, a6 as binding_callbacks, a7 as create_slot, a8 as update_slot, as as IconButton, C as CommonIcon, p as element, o as space, x as claim_element, y as children, w as claim_space, B as set_style, D as add_location, G as append_dev, t as text, z as claim_text, E as attr_dev, ag as validate_each_argument, ba as A, aF as globals, aw as set_data_dev, aj as destroy_each, aQ as useActions, a9 as set_attributes, aa as action_destroyer, ab as is_function, ac as run_all, ak as bind, al as add_flush_callback, O as noop, ax as listen_dev, R as bubble, aA as writable, bb as now, bc as loop, bd as identity, r as query_selector_all } from './client.ec94238b.js';
import { D as Demo } from './Demo.9c515360.js';
import { B as Button_1 } from './Button.d66ce348.js';
import { F as Fab } from './Fab.5ce9de7b.js';
import { C as CommonLabel, S as Span } from './CommonLabel.e3297b41.js';
import { C as CommonLabel$1 } from './CommonLabel.6290f478.js';
import { D as Div } from './Div.92a8773b.js';
import { F as FormField } from './FormField.2971fa15.js';
import { R as Radio } from './Radio.52add3e3.js';
import { C as Checkbox } from './Checkbox.52871e38.js';

/* packages/common/ClassAdder.svelte generated by Svelte v3.37.0 */

// (1:0) <svelte:component   this={component}   bind:this={element}   use={[forwardEvents, ...use]}   class={classMap({     [className]: true,     [smuiClass]: true,     ...smuiClassMap,   })}   {...props}   {...$$restProps}>
function create_default_slot$c(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[10].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[12], null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		l: function claim(nodes) {
			if (default_slot) default_slot.l(nodes);
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 4096) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[12], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$c.name,
		type: "slot",
		source: "(1:0) <svelte:component   this={component}   bind:this={element}   use={[forwardEvents, ...use]}   class={classMap({     [className]: true,     [smuiClass]: true,     ...smuiClassMap,   })}   {...props}   {...$$restProps}>",
		ctx
	});

	return block;
}

function create_fragment$g(ctx) {
	let switch_instance;
	let switch_instance_anchor;
	let current;

	const switch_instance_spread_levels = [
		{
			use: [/*forwardEvents*/ ctx[7], .../*use*/ ctx[0]]
		},
		{
			class: classMap({
				[/*className*/ ctx[1]]: true,
				[/*smuiClass*/ ctx[5]]: true,
				.../*smuiClassMap*/ ctx[4]
			})
		},
		/*props*/ ctx[6],
		/*$$restProps*/ ctx[8]
	];

	var switch_value = /*component*/ ctx[2];

	function switch_props(ctx) {
		let switch_instance_props = {
			$$slots: { default: [create_default_slot$c] },
			$$scope: { ctx }
		};

		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
		}

		return {
			props: switch_instance_props,
			$$inline: true
		};
	}

	if (switch_value) {
		switch_instance = new switch_value(switch_props(ctx));
		/*switch_instance_binding*/ ctx[11](switch_instance);
	}

	const block = {
		c: function create() {
			if (switch_instance) create_component(switch_instance.$$.fragment);
			switch_instance_anchor = empty();
		},
		l: function claim(nodes) {
			if (switch_instance) claim_component(switch_instance.$$.fragment, nodes);
			switch_instance_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (switch_instance) {
				mount_component(switch_instance, target, anchor);
			}

			insert_dev(target, switch_instance_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const switch_instance_changes = (dirty & /*forwardEvents, use, classMap, className, smuiClass, smuiClassMap, props, $$restProps*/ 499)
			? get_spread_update(switch_instance_spread_levels, [
					dirty & /*forwardEvents, use*/ 129 && {
						use: [/*forwardEvents*/ ctx[7], .../*use*/ ctx[0]]
					},
					dirty & /*classMap, className, smuiClass, smuiClassMap*/ 50 && {
						class: classMap({
							[/*className*/ ctx[1]]: true,
							[/*smuiClass*/ ctx[5]]: true,
							.../*smuiClassMap*/ ctx[4]
						})
					},
					dirty & /*props*/ 64 && get_spread_object(/*props*/ ctx[6]),
					dirty & /*$$restProps*/ 256 && get_spread_object(/*$$restProps*/ ctx[8])
				])
			: {};

			if (dirty & /*$$scope*/ 4096) {
				switch_instance_changes.$$scope = { dirty, ctx };
			}

			if (switch_value !== (switch_value = /*component*/ ctx[2])) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props(ctx));
					/*switch_instance_binding*/ ctx[11](switch_instance);
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}
		},
		i: function intro(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			/*switch_instance_binding*/ ctx[11](null);
			if (detaching) detach_dev(switch_instance_anchor);
			if (switch_instance) destroy_component(switch_instance, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$g.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

const internals = {
	component: null,
	class: "",
	// The class map maps classes to contexts. The context
	// should resolve to a Svelte store, and the class
	// will be added if the Svelte store's value is true.
	classMap: {},
	contexts: {},
	props: {}
};

function instance$g($$self, $$props, $$invalidate) {
	const omit_props_names = ["use","class","component","getElement"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("ClassAdder", slots, ['default']);
	let { use = [] } = $$props;
	let { class: className = "" } = $$props;
	let element;
	const smuiClass = internals.class;
	const smuiClassMap = {};
	const smuiClassUnsubscribes = [];
	const contexts = internals.contexts;
	const props = internals.props;
	let { component = internals.component } = $$props;

	Object.entries(internals.classMap).forEach(([name, context]) => {
		const store = getContext(context);

		if (store && "subscribe" in store) {
			smuiClassUnsubscribes.push(store.subscribe(value => {
				$$invalidate(4, smuiClassMap[name] = value, smuiClassMap);
			}));
		}
	});

	const forwardEvents = forwardEventsBuilder(get_current_component());

	for (let context in contexts) {
		if (contexts.hasOwnProperty(context)) {
			setContext(context, contexts[context]);
		}
	}

	onDestroy(() => {
		for (const unsubscribe of smuiClassUnsubscribes) {
			unsubscribe();
		}
	});

	function getElement() {
		return element.getElement();
	}

	function switch_instance_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			element = $$value;
			$$invalidate(3, element);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("use" in $$new_props) $$invalidate(0, use = $$new_props.use);
		if ("class" in $$new_props) $$invalidate(1, className = $$new_props.class);
		if ("component" in $$new_props) $$invalidate(2, component = $$new_props.component);
		if ("$$scope" in $$new_props) $$invalidate(12, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		internals,
		onDestroy,
		getContext,
		setContext,
		get_current_component,
		forwardEventsBuilder,
		classMap,
		use,
		className,
		element,
		smuiClass,
		smuiClassMap,
		smuiClassUnsubscribes,
		contexts,
		props,
		component,
		forwardEvents,
		getElement
	});

	$$self.$inject_state = $$new_props => {
		if ("use" in $$props) $$invalidate(0, use = $$new_props.use);
		if ("className" in $$props) $$invalidate(1, className = $$new_props.className);
		if ("element" in $$props) $$invalidate(3, element = $$new_props.element);
		if ("component" in $$props) $$invalidate(2, component = $$new_props.component);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		use,
		className,
		component,
		element,
		smuiClassMap,
		smuiClass,
		props,
		forwardEvents,
		$$restProps,
		getElement,
		slots,
		switch_instance_binding,
		$$scope
	];
}

class ClassAdder extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$g, create_fragment$g, safe_not_equal, {
			use: 0,
			class: 1,
			component: 2,
			getElement: 9
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ClassAdder",
			options,
			id: create_fragment$g.name
		});
	}

	get use() {
		throw new Error("<ClassAdder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set use(value) {
		throw new Error("<ClassAdder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error("<ClassAdder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<ClassAdder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get component() {
		throw new Error("<ClassAdder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set component(value) {
		throw new Error("<ClassAdder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get getElement() {
		return this.$$.ctx[9];
	}

	set getElement(value) {
		throw new Error("<ClassAdder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

const defaults = { ...internals };

function classAdderBuilder(props) {
  function Component(...args) {
    Object.assign(internals, defaults, props);
    return new ClassAdder(...args);
  }

  Component.prototype = ClassAdder;

  // SSR support
  if (ClassAdder.$$render) {
    Component.$$render = (...args) =>
      Object.assign(internals, defaults, props) && ClassAdder.$$render(...args);
  }
  if (ClassAdder.render) {
    Component.render = (...args) =>
      Object.assign(internals, defaults, props) && ClassAdder.render(...args);
  }

  return Component;
}

function dispatch(
  element,
  eventType,
  detail = {},
  eventInit = { bubbles: true }
) {
  if (typeof Event !== 'undefined' && element) {
    const event = new Event(eventType, eventInit);
    event.detail = detail;
    const el = 'getElement' in element ? element.getElement() : element;
    el.dispatchEvent(event);
    return event;
  }
}

function exclude(obj, keys) {
  let names = Object.getOwnPropertyNames(obj);
  const newObj = {};

  for (let i = 0; i < names.length; i++) {
    const name = names[i];
    const cashIndex = name.indexOf('$');
    if (
      cashIndex !== -1 &&
      keys.indexOf(name.substring(0, cashIndex + 1)) !== -1
    ) {
      continue;
    }
    if (keys.indexOf(name) !== -1) {
      continue;
    }
    newObj[name] = obj[name];
  }

  return newObj;
}

function prefixFilter(obj, prefix) {
  let names = Object.getOwnPropertyNames(obj);
  const newObj = {};

  for (let i = 0; i < names.length; i++) {
    const name = names[i];
    if (name.substring(0, prefix.length) === prefix) {
      newObj[name.substring(prefix.length)] = obj[name];
    }
  }

  return newObj;
}

/* src/routes/demo/common/_CommonLabelIcon.svelte generated by Svelte v3.37.0 */
const file$e = "src/routes/demo/common/_CommonLabelIcon.svelte";

// (2:10) <Label>
function create_default_slot_7$2(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Button with a Label");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Button with a Label");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_7$2.name,
		type: "slot",
		source: "(2:10) <Label>",
		ctx
	});

	return block;
}

// (2:2) <Button>
function create_default_slot_6$2(ctx) {
	let label;
	let current;

	label = new CommonLabel({
			props: {
				$$slots: { default: [create_default_slot_7$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(label.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(label.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(label, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const label_changes = {};

			if (dirty & /*$$scope*/ 1) {
				label_changes.$$scope = { dirty, ctx };
			}

			label.$set(label_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(label.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(label.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(label, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_6$2.name,
		type: "slot",
		source: "(2:2) <Button>",
		ctx
	});

	return block;
}

// (4:16) <Label>
function create_default_slot_5$2(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Fab with a Label");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Fab with a Label");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_5$2.name,
		type: "slot",
		source: "(4:16) <Label>",
		ctx
	});

	return block;
}

// (4:2) <Fab extended>
function create_default_slot_4$3(ctx) {
	let label;
	let current;

	label = new CommonLabel({
			props: {
				$$slots: { default: [create_default_slot_5$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(label.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(label.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(label, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const label_changes = {};

			if (dirty & /*$$scope*/ 1) {
				label_changes.$$scope = { dirty, ctx };
			}

			label.$set(label_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(label.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(label.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(label, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_4$3.name,
		type: "slot",
		source: "(4:2) <Fab extended>",
		ctx
	});

	return block;
}

// (6:14) <Icon class="material-icons">
function create_default_slot_3$4(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("favorite");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "favorite");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3$4.name,
		type: "slot",
		source: "(6:14) <Icon class=\\\"material-icons\\\">",
		ctx
	});

	return block;
}

// (6:2) <IconButton>
function create_default_slot_2$4(ctx) {
	let icon;
	let current;

	icon = new CommonIcon({
			props: {
				class: "material-icons",
				$$slots: { default: [create_default_slot_3$4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(icon.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(icon.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(icon, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const icon_changes = {};

			if (dirty & /*$$scope*/ 1) {
				icon_changes.$$scope = { dirty, ctx };
			}

			icon.$set(icon_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(icon, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2$4.name,
		type: "slot",
		source: "(6:2) <IconButton>",
		ctx
	});

	return block;
}

// (8:7) <Icon class="material-icons">
function create_default_slot_1$5(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("favorite");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "favorite");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$5.name,
		type: "slot",
		source: "(8:7) <Icon class=\\\"material-icons\\\">",
		ctx
	});

	return block;
}

// (8:2) <Fab>
function create_default_slot$b(ctx) {
	let icon;
	let current;

	icon = new CommonIcon({
			props: {
				class: "material-icons",
				$$slots: { default: [create_default_slot_1$5] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(icon.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(icon.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(icon, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const icon_changes = {};

			if (dirty & /*$$scope*/ 1) {
				icon_changes.$$scope = { dirty, ctx };
			}

			icon.$set(icon_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(icon, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$b.name,
		type: "slot",
		source: "(8:2) <Fab>",
		ctx
	});

	return block;
}

function create_fragment$f(ctx) {
	let div;
	let button;
	let t0;
	let fab0;
	let t1;
	let iconbutton;
	let t2;
	let fab1;
	let current;

	button = new Button_1({
			props: {
				$$slots: { default: [create_default_slot_6$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	fab0 = new Fab({
			props: {
				extended: true,
				$$slots: { default: [create_default_slot_4$3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	iconbutton = new IconButton({
			props: {
				$$slots: { default: [create_default_slot_2$4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	fab1 = new Fab({
			props: {
				$$slots: { default: [create_default_slot$b] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			div = element("div");
			create_component(button.$$.fragment);
			t0 = space();
			create_component(fab0.$$.fragment);
			t1 = space();
			create_component(iconbutton.$$.fragment);
			t2 = space();
			create_component(fab1.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { style: true });
			var div_nodes = children(div);
			claim_component(button.$$.fragment, div_nodes);
			t0 = claim_space(div_nodes);
			claim_component(fab0.$$.fragment, div_nodes);
			t1 = claim_space(div_nodes);
			claim_component(iconbutton.$$.fragment, div_nodes);
			t2 = claim_space(div_nodes);
			claim_component(fab1.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_style(div, "display", "flex");
			set_style(div, "flex-wrap", "wrap");
			set_style(div, "align-items", "center");
			add_location(div, file$e, 0, 0, 0);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(button, div, null);
			append_dev(div, t0);
			mount_component(fab0, div, null);
			append_dev(div, t1);
			mount_component(iconbutton, div, null);
			append_dev(div, t2);
			mount_component(fab1, div, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const button_changes = {};

			if (dirty & /*$$scope*/ 1) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
			const fab0_changes = {};

			if (dirty & /*$$scope*/ 1) {
				fab0_changes.$$scope = { dirty, ctx };
			}

			fab0.$set(fab0_changes);
			const iconbutton_changes = {};

			if (dirty & /*$$scope*/ 1) {
				iconbutton_changes.$$scope = { dirty, ctx };
			}

			iconbutton.$set(iconbutton_changes);
			const fab1_changes = {};

			if (dirty & /*$$scope*/ 1) {
				fab1_changes.$$scope = { dirty, ctx };
			}

			fab1.$set(fab1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			transition_in(fab0.$$.fragment, local);
			transition_in(iconbutton.$$.fragment, local);
			transition_in(fab1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button.$$.fragment, local);
			transition_out(fab0.$$.fragment, local);
			transition_out(iconbutton.$$.fragment, local);
			transition_out(fab1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(button);
			destroy_component(fab0);
			destroy_component(iconbutton);
			destroy_component(fab1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$f.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$f($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("CommonLabelIcon", slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<CommonLabelIcon> was created with unknown prop '${key}'`);
	});

	$$self.$capture_state = () => ({ Button: Button_1, IconButton, Fab, Icon: CommonIcon, Label: CommonLabel });
	return [];
}

class CommonLabelIcon extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$f, create_fragment$f, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "CommonLabelIcon",
			options,
			id: create_fragment$f.name
		});
	}
}

/* src/routes/demo/common/_TargetingClasses.svelte generated by Svelte v3.37.0 */
const file$d = "src/routes/demo/common/_TargetingClasses.svelte";

// (12:26) <Label>
function create_default_slot_1$4(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("This button has a Class");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "This button has a Class");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$4.name,
		type: "slot",
		source: "(12:26) <Label>",
		ctx
	});

	return block;
}

// (12:2) <Button class="myClass">
function create_default_slot$a(ctx) {
	let label;
	let current;

	label = new CommonLabel$1({
			props: {
				$$slots: { default: [create_default_slot_1$4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(label.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(label.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(label, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const label_changes = {};

			if (dirty & /*$$scope*/ 1) {
				label_changes.$$scope = { dirty, ctx };
			}

			label.$set(label_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(label.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(label.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(label, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$a.name,
		type: "slot",
		source: "(12:2) <Button class=\\\"myClass\\\">",
		ctx
	});

	return block;
}

function create_fragment$e(ctx) {
	let div;
	let button;
	let current;

	button = new Button_1({
			props: {
				class: "myClass",
				$$slots: { default: [create_default_slot$a] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			div = element("div");
			create_component(button.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			claim_component(button.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "svelte-1qbx9if");
			add_location(div, file$d, 6, 0, 176);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(button, div, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const button_changes = {};

			if (dirty & /*$$scope*/ 1) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(button);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$e.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$e($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("TargetingClasses", slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<TargetingClasses> was created with unknown prop '${key}'`);
	});

	$$self.$capture_state = () => ({ Button: Button_1, Label: CommonLabel$1 });
	return [];
}

class TargetingClasses extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$e, create_fragment$e, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "TargetingClasses",
			options,
			id: create_fragment$e.name
		});
	}
}

/* src/routes/demo/common/_EventsAndModifiers.svelte generated by Svelte v3.37.0 */

const { console: console_1 } = globals;
const file$c = "src/routes/demo/common/_EventsAndModifiers.svelte";

function get_each_context$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[9] = list[i];
	return child_ctx;
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[9] = list[i];
	return child_ctx;
}

// (16:4) <Label>
function create_default_slot_4$2(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("This Button has Event Listeners");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "This Button has Event Listeners");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_4$2.name,
		type: "slot",
		source: "(16:4) <Label>",
		ctx
	});

	return block;
}

// (2:2) <Button     on:click={addEvent}     on:mousedown={addEvent}     on:mouseup={addEvent}     on:mouseover={addEvent}     on:mouseout={addEvent}     on:keypress={addEvent}     on:keydown={addEvent}     on:keyup={addEvent}     on:focus={addEvent}     on:blur={addEvent}     on:animationstart={addEvent}     on:animationend={addEvent}   >
function create_default_slot_3$3(ctx) {
	let label;
	let current;

	label = new CommonLabel$1({
			props: {
				$$slots: { default: [create_default_slot_4$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(label.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(label.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(label, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const label_changes = {};

			if (dirty & /*$$scope*/ 16384) {
				label_changes.$$scope = { dirty, ctx };
			}

			label.$set(label_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(label.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(label.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(label, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3$3.name,
		type: "slot",
		source: "(2:2) <Button     on:click={addEvent}     on:mousedown={addEvent}     on:mouseup={addEvent}     on:mouseover={addEvent}     on:mouseout={addEvent}     on:keypress={addEvent}     on:keydown={addEvent}     on:keyup={addEvent}     on:focus={addEvent}     on:blur={addEvent}     on:animationstart={addEvent}     on:animationend={addEvent}   >",
		ctx
	});

	return block;
}

// (23:2) {:else}
function create_else_block_1(ctx) {
	let p;
	let t;

	const block = {
		c: function create() {
			p = element("p");
			t = text("No events yet.");
			this.h();
		},
		l: function claim(nodes) {
			p = claim_element(nodes, "P", {});
			var p_nodes = children(p);
			t = claim_text(p_nodes, "No events yet.");
			p_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(p, file$c, 23, 4, 534);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			append_dev(p, t);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_1.name,
		type: "else",
		source: "(23:2) {:else}",
		ctx
	});

	return block;
}

// (21:2) {#each events as event}
function create_each_block_1(ctx) {
	let p;
	let t0;
	let t1_value = /*event*/ ctx[9].type + "";
	let t1;

	const block = {
		c: function create() {
			p = element("p");
			t0 = text("Caught ");
			t1 = text(t1_value);
			this.h();
		},
		l: function claim(nodes) {
			p = claim_element(nodes, "P", {});
			var p_nodes = children(p);
			t0 = claim_text(p_nodes, "Caught ");
			t1 = claim_text(p_nodes, t1_value);
			p_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(p, file$c, 21, 4, 493);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			append_dev(p, t0);
			append_dev(p, t1);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*events*/ 4 && t1_value !== (t1_value = /*event*/ ctx[9].type + "")) set_data_dev(t1, t1_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_1.name,
		type: "each",
		source: "(21:2) {#each events as event}",
		ctx
	});

	return block;
}

// (36:4) <Label>
function create_default_slot_2$3(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Capture and Bubble Phase Listeners");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Capture and Bubble Phase Listeners");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2$3.name,
		type: "slot",
		source: "(36:4) <Label>",
		ctx
	});

	return block;
}

// (35:2) <Button on:click$capture={addEventPhase} on:click={addEventPhase}>
function create_default_slot_1$3(ctx) {
	let label;
	let current;

	label = new CommonLabel$1({
			props: {
				$$slots: { default: [create_default_slot_2$3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(label.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(label.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(label, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const label_changes = {};

			if (dirty & /*$$scope*/ 16384) {
				label_changes.$$scope = { dirty, ctx };
			}

			label.$set(label_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(label.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(label.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(label, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$3.name,
		type: "slot",
		source: "(35:2) <Button on:click$capture={addEventPhase} on:click={addEventPhase}>",
		ctx
	});

	return block;
}

// (43:2) {:else}
function create_else_block(ctx) {
	let p;
	let t;

	const block = {
		c: function create() {
			p = element("p");
			t = text("No events yet.");
			this.h();
		},
		l: function claim(nodes) {
			p = claim_element(nodes, "P", {});
			var p_nodes = children(p);
			t = claim_text(p_nodes, "No events yet.");
			p_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(p, file$c, 43, 4, 1067);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			append_dev(p, t);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(43:2) {:else}",
		ctx
	});

	return block;
}

// (41:2) {#each eventPhases as event}
function create_each_block$1(ctx) {
	let p;
	let t0;
	let t1_value = /*event*/ ctx[9][0].type + "";
	let t1;
	let t2;
	let t3_value = /*event*/ ctx[9][1] + "";
	let t3;
	let t4;

	const block = {
		c: function create() {
			p = element("p");
			t0 = text("Caught ");
			t1 = text(t1_value);
			t2 = text(" in ");
			t3 = text(t3_value);
			t4 = text(" phase");
			this.h();
		},
		l: function claim(nodes) {
			p = claim_element(nodes, "P", {});
			var p_nodes = children(p);
			t0 = claim_text(p_nodes, "Caught ");
			t1 = claim_text(p_nodes, t1_value);
			t2 = claim_text(p_nodes, " in ");
			t3 = claim_text(p_nodes, t3_value);
			t4 = claim_text(p_nodes, " phase");
			p_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(p, file$c, 41, 4, 1003);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			append_dev(p, t0);
			append_dev(p, t1);
			append_dev(p, t2);
			append_dev(p, t3);
			append_dev(p, t4);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*eventPhases*/ 8 && t1_value !== (t1_value = /*event*/ ctx[9][0].type + "")) set_data_dev(t1, t1_value);
			if (dirty & /*eventPhases*/ 8 && t3_value !== (t3_value = /*event*/ ctx[9][1] + "")) set_data_dev(t3, t3_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$1.name,
		type: "each",
		source: "(41:2) {#each eventPhases as event}",
		ctx
	});

	return block;
}

// (49:2) <A     href="http://example.com"     on:click$preventDefault={() =>       console.log("You tried to go, but didn't make it.")}   >
function create_default_slot$9(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("A Link, with Default Prevented");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "A Link, with Default Prevented");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$9.name,
		type: "slot",
		source: "(49:2) <A     href=\\\"http://example.com\\\"     on:click$preventDefault={() =>       console.log(\\\"You tried to go, but didn't make it.\\\")}   >",
		ctx
	});

	return block;
}

function create_fragment$d(ctx) {
	let div0;
	let button0;
	let t0;
	let div1;
	let t1;
	let div2;
	let t2;
	let t3;
	let div3;
	let button1;
	let t4;
	let div4;
	let t5;
	let div5;
	let a;
	let current;

	button0 = new Button_1({
			props: {
				$$slots: { default: [create_default_slot_3$3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button0.$on("click", /*addEvent*/ ctx[4]);
	button0.$on("mousedown", /*addEvent*/ ctx[4]);
	button0.$on("mouseup", /*addEvent*/ ctx[4]);
	button0.$on("mouseover", /*addEvent*/ ctx[4]);
	button0.$on("mouseout", /*addEvent*/ ctx[4]);
	button0.$on("keypress", /*addEvent*/ ctx[4]);
	button0.$on("keydown", /*addEvent*/ ctx[4]);
	button0.$on("keyup", /*addEvent*/ ctx[4]);
	button0.$on("focus", /*addEvent*/ ctx[4]);
	button0.$on("blur", /*addEvent*/ ctx[4]);
	button0.$on("animationstart", /*addEvent*/ ctx[4]);
	button0.$on("animationend", /*addEvent*/ ctx[4]);
	let each_value_1 = /*events*/ ctx[2];
	validate_each_argument(each_value_1);
	let each_blocks_1 = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks_1[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	let each0_else = null;

	if (!each_value_1.length) {
		each0_else = create_else_block_1(ctx);
	}

	button1 = new Button_1({
			props: {
				$$slots: { default: [create_default_slot_1$3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button1.$on("click$capture", /*addEventPhase*/ ctx[5]);
	button1.$on("click", /*addEventPhase*/ ctx[5]);
	let each_value = /*eventPhases*/ ctx[3];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
	}

	let each1_else = null;

	if (!each_value.length) {
		each1_else = create_else_block(ctx);
	}

	a = new A({
			props: {
				href: "http://example.com",
				$$slots: { default: [create_default_slot$9] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	a.$on("click$preventDefault", /*click_preventDefault_handler*/ ctx[8]);

	const block = {
		c: function create() {
			div0 = element("div");
			create_component(button0.$$.fragment);
			t0 = space();
			div1 = element("div");

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].c();
			}

			if (each0_else) {
				each0_else.c();
			}

			t1 = space();
			div2 = element("div");
			t2 = text("Try clicking and using the Enter key to activate this next button. (The click\n  event's target is an element below the button while the key event's target is\n  the button.)");
			t3 = space();
			div3 = element("div");
			create_component(button1.$$.fragment);
			t4 = space();
			div4 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			if (each1_else) {
				each1_else.c();
			}

			t5 = space();
			div5 = element("div");
			create_component(a.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div0 = claim_element(nodes, "DIV", {});
			var div0_nodes = children(div0);
			claim_component(button0.$$.fragment, div0_nodes);
			div0_nodes.forEach(detach_dev);
			t0 = claim_space(nodes);
			div1 = claim_element(nodes, "DIV", { class: true });
			var div1_nodes = children(div1);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].l(div1_nodes);
			}

			if (each0_else) {
				each0_else.l(div1_nodes);
			}

			div1_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			div2 = claim_element(nodes, "DIV", {});
			var div2_nodes = children(div2);
			t2 = claim_text(div2_nodes, "Try clicking and using the Enter key to activate this next button. (The click\n  event's target is an element below the button while the key event's target is\n  the button.)");
			div2_nodes.forEach(detach_dev);
			t3 = claim_space(nodes);
			div3 = claim_element(nodes, "DIV", {});
			var div3_nodes = children(div3);
			claim_component(button1.$$.fragment, div3_nodes);
			div3_nodes.forEach(detach_dev);
			t4 = claim_space(nodes);
			div4 = claim_element(nodes, "DIV", { class: true });
			var div4_nodes = children(div4);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div4_nodes);
			}

			if (each1_else) {
				each1_else.l(div4_nodes);
			}

			div4_nodes.forEach(detach_dev);
			t5 = claim_space(nodes);
			div5 = claim_element(nodes, "DIV", {});
			var div5_nodes = children(div5);
			claim_component(a.$$.fragment, div5_nodes);
			div5_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(div0, file$c, 0, 0, 0);
			attr_dev(div1, "class", "event-output svelte-1nk5gaq");
			add_location(div1, file$c, 19, 0, 412);
			add_location(div2, file$c, 27, 0, 574);
			add_location(div3, file$c, 33, 0, 763);
			attr_dev(div4, "class", "event-output svelte-1nk5gaq");
			add_location(div4, file$c, 39, 0, 912);
			add_location(div5, file$c, 47, 0, 1107);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div0, anchor);
			mount_component(button0, div0, null);
			insert_dev(target, t0, anchor);
			insert_dev(target, div1, anchor);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].m(div1, null);
			}

			if (each0_else) {
				each0_else.m(div1, null);
			}

			/*div1_binding*/ ctx[6](div1);
			insert_dev(target, t1, anchor);
			insert_dev(target, div2, anchor);
			append_dev(div2, t2);
			insert_dev(target, t3, anchor);
			insert_dev(target, div3, anchor);
			mount_component(button1, div3, null);
			insert_dev(target, t4, anchor);
			insert_dev(target, div4, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div4, null);
			}

			if (each1_else) {
				each1_else.m(div4, null);
			}

			/*div4_binding*/ ctx[7](div4);
			insert_dev(target, t5, anchor);
			insert_dev(target, div5, anchor);
			mount_component(a, div5, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const button0_changes = {};

			if (dirty & /*$$scope*/ 16384) {
				button0_changes.$$scope = { dirty, ctx };
			}

			button0.$set(button0_changes);

			if (dirty & /*events*/ 4) {
				each_value_1 = /*events*/ ctx[2];
				validate_each_argument(each_value_1);
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks_1[i]) {
						each_blocks_1[i].p(child_ctx, dirty);
					} else {
						each_blocks_1[i] = create_each_block_1(child_ctx);
						each_blocks_1[i].c();
						each_blocks_1[i].m(div1, null);
					}
				}

				for (; i < each_blocks_1.length; i += 1) {
					each_blocks_1[i].d(1);
				}

				each_blocks_1.length = each_value_1.length;

				if (each_value_1.length) {
					if (each0_else) {
						each0_else.d(1);
						each0_else = null;
					}
				} else if (!each0_else) {
					each0_else = create_else_block_1(ctx);
					each0_else.c();
					each0_else.m(div1, null);
				}
			}

			const button1_changes = {};

			if (dirty & /*$$scope*/ 16384) {
				button1_changes.$$scope = { dirty, ctx };
			}

			button1.$set(button1_changes);

			if (dirty & /*eventPhases*/ 8) {
				each_value = /*eventPhases*/ ctx[3];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$1(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div4, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;

				if (each_value.length) {
					if (each1_else) {
						each1_else.d(1);
						each1_else = null;
					}
				} else if (!each1_else) {
					each1_else = create_else_block(ctx);
					each1_else.c();
					each1_else.m(div4, null);
				}
			}

			const a_changes = {};

			if (dirty & /*$$scope*/ 16384) {
				a_changes.$$scope = { dirty, ctx };
			}

			a.$set(a_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button0.$$.fragment, local);
			transition_in(button1.$$.fragment, local);
			transition_in(a.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button0.$$.fragment, local);
			transition_out(button1.$$.fragment, local);
			transition_out(a.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div0);
			destroy_component(button0);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(div1);
			destroy_each(each_blocks_1, detaching);
			if (each0_else) each0_else.d();
			/*div1_binding*/ ctx[6](null);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(div2);
			if (detaching) detach_dev(t3);
			if (detaching) detach_dev(div3);
			destroy_component(button1);
			if (detaching) detach_dev(t4);
			if (detaching) detach_dev(div4);
			destroy_each(each_blocks, detaching);
			if (each1_else) each1_else.d();
			/*div4_binding*/ ctx[7](null);
			if (detaching) detach_dev(t5);
			if (detaching) detach_dev(div5);
			destroy_component(a);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$d.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$d($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("EventsAndModifiers", slots, []);
	let eventOutput;
	let eventPhaseOutput;
	let events = [];
	let eventPhases = [];

	function addEvent(event) {
		events.push(event);
		$$invalidate(2, events);

		requestAnimationFrame(() => {
			$$invalidate(0, eventOutput.scrollTop = eventOutput.scrollHeight, eventOutput);
		});
	}

	function addEventPhase(event) {
		const phases = ["none", "capturing", "at-target", "bubbling"];
		eventPhases.push([event, phases[event.eventPhase]]);
		$$invalidate(3, eventPhases);

		requestAnimationFrame(() => {
			$$invalidate(1, eventPhaseOutput.scrollTop = eventPhaseOutput.scrollHeight, eventPhaseOutput);
		});
	}

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1.warn(`<EventsAndModifiers> was created with unknown prop '${key}'`);
	});

	function div1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			eventOutput = $$value;
			$$invalidate(0, eventOutput);
		});
	}

	function div4_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			eventPhaseOutput = $$value;
			$$invalidate(1, eventPhaseOutput);
		});
	}

	const click_preventDefault_handler = () => console.log("You tried to go, but didn't make it.");

	$$self.$capture_state = () => ({
		Button: Button_1,
		Label: CommonLabel$1,
		A,
		eventOutput,
		eventPhaseOutput,
		events,
		eventPhases,
		addEvent,
		addEventPhase
	});

	$$self.$inject_state = $$props => {
		if ("eventOutput" in $$props) $$invalidate(0, eventOutput = $$props.eventOutput);
		if ("eventPhaseOutput" in $$props) $$invalidate(1, eventPhaseOutput = $$props.eventPhaseOutput);
		if ("events" in $$props) $$invalidate(2, events = $$props.events);
		if ("eventPhases" in $$props) $$invalidate(3, eventPhases = $$props.eventPhases);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		eventOutput,
		eventPhaseOutput,
		events,
		eventPhases,
		addEvent,
		addEventPhase,
		div1_binding,
		div4_binding,
		click_preventDefault_handler
	];
}

class EventsAndModifiers extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$d, create_fragment$d, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "EventsAndModifiers",
			options,
			id: create_fragment$d.name
		});
	}
}

/* packages/common/Strong.svelte generated by Svelte v3.37.0 */
const file$b = "packages/common/Strong.svelte";

function create_fragment$c(ctx) {
	let strong;
	let useActions_action;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[6].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);
	let strong_levels = [/*$$restProps*/ ctx[3]];
	let strong_data = {};

	for (let i = 0; i < strong_levels.length; i += 1) {
		strong_data = assign(strong_data, strong_levels[i]);
	}

	const block = {
		c: function create() {
			strong = element("strong");
			if (default_slot) default_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			strong = claim_element(nodes, "STRONG", {});
			var strong_nodes = children(strong);
			if (default_slot) default_slot.l(strong_nodes);
			strong_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_attributes(strong, strong_data);
			add_location(strong, file$b, 0, 0, 0);
		},
		m: function mount(target, anchor) {
			insert_dev(target, strong, anchor);

			if (default_slot) {
				default_slot.m(strong, null);
			}

			/*strong_binding*/ ctx[7](strong);
			current = true;

			if (!mounted) {
				dispose = [
					action_destroyer(useActions_action = useActions.call(null, strong, /*use*/ ctx[0])),
					action_destroyer(/*forwardEvents*/ ctx[2].call(null, strong))
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 32) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[5], dirty, null, null);
				}
			}

			set_attributes(strong, strong_data = get_spread_update(strong_levels, [dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3]]));
			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(strong);
			if (default_slot) default_slot.d(detaching);
			/*strong_binding*/ ctx[7](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$c.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$c($$self, $$props, $$invalidate) {
	const omit_props_names = ["use","getElement"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Strong", slots, ['default']);
	let { use = [] } = $$props;
	const forwardEvents = forwardEventsBuilder(get_current_component());
	let element = null;

	function getElement() {
		return element;
	}

	function strong_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			element = $$value;
			$$invalidate(1, element);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("use" in $$new_props) $$invalidate(0, use = $$new_props.use);
		if ("$$scope" in $$new_props) $$invalidate(5, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		get_current_component,
		forwardEventsBuilder,
		useActions,
		use,
		forwardEvents,
		element,
		getElement
	});

	$$self.$inject_state = $$new_props => {
		if ("use" in $$props) $$invalidate(0, use = $$new_props.use);
		if ("element" in $$props) $$invalidate(1, element = $$new_props.element);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		use,
		element,
		forwardEvents,
		$$restProps,
		getElement,
		$$scope,
		slots,
		strong_binding
	];
}

class Strong extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$c, create_fragment$c, safe_not_equal, { use: 0, getElement: 4 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Strong",
			options,
			id: create_fragment$c.name
		});
	}

	get use() {
		throw new Error("<Strong>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set use(value) {
		throw new Error("<Strong>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get getElement() {
		return this.$$.ctx[4];
	}

	set getElement(value) {
		throw new Error("<Strong>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* packages/common/Em.svelte generated by Svelte v3.37.0 */
const file$a = "packages/common/Em.svelte";

function create_fragment$b(ctx) {
	let em;
	let useActions_action;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[6].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);
	let em_levels = [/*$$restProps*/ ctx[3]];
	let em_data = {};

	for (let i = 0; i < em_levels.length; i += 1) {
		em_data = assign(em_data, em_levels[i]);
	}

	const block = {
		c: function create() {
			em = element("em");
			if (default_slot) default_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			em = claim_element(nodes, "EM", {});
			var em_nodes = children(em);
			if (default_slot) default_slot.l(em_nodes);
			em_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_attributes(em, em_data);
			add_location(em, file$a, 0, 0, 0);
		},
		m: function mount(target, anchor) {
			insert_dev(target, em, anchor);

			if (default_slot) {
				default_slot.m(em, null);
			}

			/*em_binding*/ ctx[7](em);
			current = true;

			if (!mounted) {
				dispose = [
					action_destroyer(useActions_action = useActions.call(null, em, /*use*/ ctx[0])),
					action_destroyer(/*forwardEvents*/ ctx[2].call(null, em))
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 32) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[5], dirty, null, null);
				}
			}

			set_attributes(em, em_data = get_spread_update(em_levels, [dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3]]));
			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(em);
			if (default_slot) default_slot.d(detaching);
			/*em_binding*/ ctx[7](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$b.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$b($$self, $$props, $$invalidate) {
	const omit_props_names = ["use","getElement"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Em", slots, ['default']);
	let { use = [] } = $$props;
	const forwardEvents = forwardEventsBuilder(get_current_component());
	let element = null;

	function getElement() {
		return element;
	}

	function em_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			element = $$value;
			$$invalidate(1, element);
		});
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("use" in $$new_props) $$invalidate(0, use = $$new_props.use);
		if ("$$scope" in $$new_props) $$invalidate(5, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		get_current_component,
		forwardEventsBuilder,
		useActions,
		use,
		forwardEvents,
		element,
		getElement
	});

	$$self.$inject_state = $$new_props => {
		if ("use" in $$props) $$invalidate(0, use = $$new_props.use);
		if ("element" in $$props) $$invalidate(1, element = $$new_props.element);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		use,
		element,
		forwardEvents,
		$$restProps,
		getElement,
		$$scope,
		slots,
		em_binding
	];
}

class Em extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$b, create_fragment$b, safe_not_equal, { use: 0, getElement: 4 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Em",
			options,
			id: create_fragment$b.name
		});
	}

	get use() {
		throw new Error("<Em>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set use(value) {
		throw new Error("<Em>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get getElement() {
		return this.$$.ctx[4];
	}

	set getElement(value) {
		throw new Error("<Em>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/demo/common/_ElementalComponents.svelte generated by Svelte v3.37.0 */
const file$9 = "src/routes/demo/common/_ElementalComponents.svelte";

// (5:26) <Label>
function create_default_slot_7$1(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("I'm a <div /> Button");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "I'm a <div /> Button");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_7$1.name,
		type: "slot",
		source: "(5:26) <Label>",
		ctx
	});

	return block;
}

// (5:2) <Button component={Div}>
function create_default_slot_6$1(ctx) {
	let label;
	let current;

	label = new CommonLabel$1({
			props: {
				$$slots: { default: [create_default_slot_7$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(label.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(label.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(label, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const label_changes = {};

			if (dirty & /*$$scope*/ 1) {
				label_changes.$$scope = { dirty, ctx };
			}

			label.$set(label_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(label.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(label.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(label, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_6$1.name,
		type: "slot",
		source: "(5:2) <Button component={Div}>",
		ctx
	});

	return block;
}

// (6:27) <Label>
function create_default_slot_5$1(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("I'm a <span /> Button");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "I'm a <span /> Button");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_5$1.name,
		type: "slot",
		source: "(6:27) <Label>",
		ctx
	});

	return block;
}

// (6:2) <Button component={Span}>
function create_default_slot_4$1(ctx) {
	let label;
	let current;

	label = new CommonLabel$1({
			props: {
				$$slots: { default: [create_default_slot_5$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(label.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(label.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(label, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const label_changes = {};

			if (dirty & /*$$scope*/ 1) {
				label_changes.$$scope = { dirty, ctx };
			}

			label.$set(label_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(label.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(label.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(label, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_4$1.name,
		type: "slot",
		source: "(6:2) <Button component={Span}>",
		ctx
	});

	return block;
}

// (8:5) <Label>
function create_default_slot_3$2(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("I'm a <strong /> Button");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "I'm a <strong /> Button");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3$2.name,
		type: "slot",
		source: "(8:5) <Label>",
		ctx
	});

	return block;
}

// (7:2) <Button component={Strong}     >
function create_default_slot_2$2(ctx) {
	let label;
	let current;

	label = new CommonLabel$1({
			props: {
				$$slots: { default: [create_default_slot_3$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(label.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(label.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(label, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const label_changes = {};

			if (dirty & /*$$scope*/ 1) {
				label_changes.$$scope = { dirty, ctx };
			}

			label.$set(label_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(label.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(label.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(label, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2$2.name,
		type: "slot",
		source: "(7:2) <Button component={Strong}     >",
		ctx
	});

	return block;
}

// (10:25) <Label>
function create_default_slot_1$2(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("I'm a <em /> Button");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "I'm a <em /> Button");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$2.name,
		type: "slot",
		source: "(10:25) <Label>",
		ctx
	});

	return block;
}

// (10:2) <Button component={Em}>
function create_default_slot$8(ctx) {
	let label;
	let current;

	label = new CommonLabel$1({
			props: {
				$$slots: { default: [create_default_slot_1$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(label.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(label.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(label, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const label_changes = {};

			if (dirty & /*$$scope*/ 1) {
				label_changes.$$scope = { dirty, ctx };
			}

			label.$set(label_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(label.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(label.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(label, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$8.name,
		type: "slot",
		source: "(10:2) <Button component={Em}>",
		ctx
	});

	return block;
}

function create_fragment$a(ctx) {
	let div;
	let button0;
	let t0;
	let button1;
	let t1;
	let button2;
	let t2;
	let button3;
	let current;

	button0 = new Button_1({
			props: {
				component: Div,
				$$slots: { default: [create_default_slot_6$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button1 = new Button_1({
			props: {
				component: Span,
				$$slots: { default: [create_default_slot_4$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button2 = new Button_1({
			props: {
				component: Strong,
				$$slots: { default: [create_default_slot_2$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button3 = new Button_1({
			props: {
				component: Em,
				$$slots: { default: [create_default_slot$8] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			div = element("div");
			create_component(button0.$$.fragment);
			t0 = space();
			create_component(button1.$$.fragment);
			t1 = space();
			create_component(button2.$$.fragment);
			t2 = space();
			create_component(button3.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", {});
			var div_nodes = children(div);
			claim_component(button0.$$.fragment, div_nodes);
			t0 = claim_space(div_nodes);
			claim_component(button1.$$.fragment, div_nodes);
			t1 = claim_space(div_nodes);
			claim_component(button2.$$.fragment, div_nodes);
			t2 = claim_space(div_nodes);
			claim_component(button3.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(div, file$9, 3, 0, 70);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(button0, div, null);
			append_dev(div, t0);
			mount_component(button1, div, null);
			append_dev(div, t1);
			mount_component(button2, div, null);
			append_dev(div, t2);
			mount_component(button3, div, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const button0_changes = {};

			if (dirty & /*$$scope*/ 1) {
				button0_changes.$$scope = { dirty, ctx };
			}

			button0.$set(button0_changes);
			const button1_changes = {};

			if (dirty & /*$$scope*/ 1) {
				button1_changes.$$scope = { dirty, ctx };
			}

			button1.$set(button1_changes);
			const button2_changes = {};

			if (dirty & /*$$scope*/ 1) {
				button2_changes.$$scope = { dirty, ctx };
			}

			button2.$set(button2_changes);
			const button3_changes = {};

			if (dirty & /*$$scope*/ 1) {
				button3_changes.$$scope = { dirty, ctx };
			}

			button3.$set(button3_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button0.$$.fragment, local);
			transition_in(button1.$$.fragment, local);
			transition_in(button2.$$.fragment, local);
			transition_in(button3.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button0.$$.fragment, local);
			transition_out(button1.$$.fragment, local);
			transition_out(button2.$$.fragment, local);
			transition_out(button3.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(button0);
			destroy_component(button1);
			destroy_component(button2);
			destroy_component(button3);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$a.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$a($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("ElementalComponents", slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ElementalComponents> was created with unknown prop '${key}'`);
	});

	$$self.$capture_state = () => ({ Div, Span, Strong, Em, Button: Button_1, Label: CommonLabel$1 });
	return [];
}

class ElementalComponents extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$a, create_fragment$a, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ElementalComponents",
			options,
			id: create_fragment$a.name
		});
	}
}

var MyClassAdder = classAdderBuilder({
  class: 'my-added-class',
  component: Div,
});

/* src/routes/demo/common/_ClassAdderBuilder.svelte generated by Svelte v3.37.0 */
const file$8 = "src/routes/demo/common/_ClassAdderBuilder.svelte";

// (2:2) <MyClassAdder>
function create_default_slot$7(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("I'm a component with an added class!");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "I'm a component with an added class!");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$7.name,
		type: "slot",
		source: "(2:2) <MyClassAdder>",
		ctx
	});

	return block;
}

function create_fragment$9(ctx) {
	let div;
	let myclassadder;
	let current;

	myclassadder = new MyClassAdder({
			props: {
				$$slots: { default: [create_default_slot$7] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			div = element("div");
			create_component(myclassadder.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			claim_component(myclassadder.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "svelte-5kobxj");
			add_location(div, file$8, 0, 0, 0);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(myclassadder, div, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const myclassadder_changes = {};

			if (dirty & /*$$scope*/ 1) {
				myclassadder_changes.$$scope = { dirty, ctx };
			}

			myclassadder.$set(myclassadder_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(myclassadder.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(myclassadder.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(myclassadder);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$9.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$9($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("ClassAdderBuilder", slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ClassAdderBuilder> was created with unknown prop '${key}'`);
	});

	$$self.$capture_state = () => ({ MyClassAdder });
	return [];
}

class ClassAdderBuilder extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$9, create_fragment$9, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ClassAdderBuilder",
			options,
			id: create_fragment$9.name
		});
	}
}

/* src/routes/demo/common/_ClassMap.svelte generated by Svelte v3.37.0 */
const file$7 = "src/routes/demo/common/_ClassMap.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[4] = list[i];
	return child_ctx;
}

// (9:4) <Label>
function create_default_slot_3$1(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("I'm a Colored Button");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "I'm a Colored Button");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3$1.name,
		type: "slot",
		source: "(9:4) <Label>",
		ctx
	});

	return block;
}

// (2:2) <Button     class={classMap({       'my-button': true,       big: big,       [color]: true,     })}   >
function create_default_slot_2$1(ctx) {
	let label;
	let current;

	label = new CommonLabel({
			props: {
				$$slots: { default: [create_default_slot_3$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(label.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(label.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(label, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const label_changes = {};

			if (dirty & /*$$scope*/ 128) {
				label_changes.$$scope = { dirty, ctx };
			}

			label.$set(label_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(label.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(label.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(label, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2$1.name,
		type: "slot",
		source: "(2:2) <Button     class={classMap({       'my-button': true,       big: big,       [color]: true,     })}   >",
		ctx
	});

	return block;
}

// (14:2) <FormField style="margin-right: 1em;">
function create_default_slot_1$1(ctx) {
	let checkbox;
	let updating_checked;
	let current;

	function checkbox_checked_binding(value) {
		/*checkbox_checked_binding*/ ctx[2](value);
	}

	let checkbox_props = {};

	if (/*big*/ ctx[0] !== void 0) {
		checkbox_props.checked = /*big*/ ctx[0];
	}

	checkbox = new Checkbox({ props: checkbox_props, $$inline: true });
	binding_callbacks.push(() => bind(checkbox, "checked", checkbox_checked_binding));

	const block = {
		c: function create() {
			create_component(checkbox.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(checkbox.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(checkbox, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const checkbox_changes = {};

			if (!updating_checked && dirty & /*big*/ 1) {
				updating_checked = true;
				checkbox_changes.checked = /*big*/ ctx[0];
				add_flush_callback(() => updating_checked = false);
			}

			checkbox.$set(checkbox_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(checkbox.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(checkbox.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(checkbox, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$1.name,
		type: "slot",
		source: "(14:2) <FormField style=\\\"margin-right: 1em;\\\">",
		ctx
	});

	return block;
}

// (16:4) 
function create_label_slot_1(ctx) {
	let span;
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text("Big");
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { slot: true, class: true });
			var span_nodes = children(span);
			t = claim_text(span_nodes, "Big");
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "slot", "label");
			attr_dev(span, "class", "svelte-3uxzje");
			add_location(span, file$7, 15, 4, 259);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_label_slot_1.name,
		type: "slot",
		source: "(16:4) ",
		ctx
	});

	return block;
}

// (19:4) <FormField style="margin-right: 1em;">
function create_default_slot$6(ctx) {
	let radio;
	let updating_group;
	let t;
	let current;

	function radio_group_binding(value) {
		/*radio_group_binding*/ ctx[3](value);
	}

	let radio_props = { value: /*option*/ ctx[4] };

	if (/*color*/ ctx[1] !== void 0) {
		radio_props.group = /*color*/ ctx[1];
	}

	radio = new Radio({ props: radio_props, $$inline: true });
	binding_callbacks.push(() => bind(radio, "group", radio_group_binding));

	const block = {
		c: function create() {
			create_component(radio.$$.fragment);
			t = space();
		},
		l: function claim(nodes) {
			claim_component(radio.$$.fragment, nodes);
			t = claim_space(nodes);
		},
		m: function mount(target, anchor) {
			mount_component(radio, target, anchor);
			insert_dev(target, t, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const radio_changes = {};

			if (!updating_group && dirty & /*color*/ 2) {
				updating_group = true;
				radio_changes.group = /*color*/ ctx[1];
				add_flush_callback(() => updating_group = false);
			}

			radio.$set(radio_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(radio.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(radio.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(radio, detaching);
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$6.name,
		type: "slot",
		source: "(19:4) <FormField style=\\\"margin-right: 1em;\\\">",
		ctx
	});

	return block;
}

// (21:6) 
function create_label_slot(ctx) {
	let span;
	let t_value = `${/*option*/ ctx[4][0].toUpperCase()}${/*option*/ ctx[4].slice(1)}` + "";
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text(t_value);
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { slot: true, class: true });
			var span_nodes = children(span);
			t = claim_text(span_nodes, t_value);
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "slot", "label");
			attr_dev(span, "class", "svelte-3uxzje");
			add_location(span, file$7, 20, 6, 448);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_label_slot.name,
		type: "slot",
		source: "(21:6) ",
		ctx
	});

	return block;
}

// (18:2) {#each ['red', 'blue', 'green'] as option}
function create_each_block(ctx) {
	let formfield;
	let current;

	formfield = new FormField({
			props: {
				style: "margin-right: 1em;",
				$$slots: {
					label: [create_label_slot],
					default: [create_default_slot$6]
				},
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(formfield.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(formfield.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(formfield, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const formfield_changes = {};

			if (dirty & /*$$scope, color*/ 130) {
				formfield_changes.$$scope = { dirty, ctx };
			}

			formfield.$set(formfield_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(formfield.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(formfield.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(formfield, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(18:2) {#each ['red', 'blue', 'green'] as option}",
		ctx
	});

	return block;
}

function create_fragment$8(ctx) {
	let div0;
	let button;
	let t0;
	let div1;
	let formfield;
	let t1;
	let current;

	button = new Button_1({
			props: {
				class: classMap({
					"my-button": true,
					big: /*big*/ ctx[0],
					[/*color*/ ctx[1]]: true
				}),
				$$slots: { default: [create_default_slot_2$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	formfield = new FormField({
			props: {
				style: "margin-right: 1em;",
				$$slots: {
					label: [create_label_slot_1],
					default: [create_default_slot_1$1]
				},
				$$scope: { ctx }
			},
			$$inline: true
		});

	let each_value = ["red", "blue", "green"];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < 3; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			div0 = element("div");
			create_component(button.$$.fragment);
			t0 = space();
			div1 = element("div");
			create_component(formfield.$$.fragment);
			t1 = space();

			for (let i = 0; i < 3; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l: function claim(nodes) {
			div0 = claim_element(nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			claim_component(button.$$.fragment, div0_nodes);
			div0_nodes.forEach(detach_dev);
			t0 = claim_space(nodes);
			div1 = claim_element(nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			claim_component(formfield.$$.fragment, div1_nodes);
			t1 = claim_space(div1_nodes);

			for (let i = 0; i < 3; i += 1) {
				each_blocks[i].l(div1_nodes);
			}

			div1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "class", "svelte-3uxzje");
			add_location(div0, file$7, 0, 0, 0);
			attr_dev(div1, "class", "svelte-3uxzje");
			add_location(div1, file$7, 12, 0, 172);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div0, anchor);
			mount_component(button, div0, null);
			insert_dev(target, t0, anchor);
			insert_dev(target, div1, anchor);
			mount_component(formfield, div1, null);
			append_dev(div1, t1);

			for (let i = 0; i < 3; i += 1) {
				each_blocks[i].m(div1, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			const button_changes = {};

			if (dirty & /*big, color*/ 3) button_changes.class = classMap({
				"my-button": true,
				big: /*big*/ ctx[0],
				[/*color*/ ctx[1]]: true
			});

			if (dirty & /*$$scope*/ 128) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
			const formfield_changes = {};

			if (dirty & /*$$scope, big*/ 129) {
				formfield_changes.$$scope = { dirty, ctx };
			}

			formfield.$set(formfield_changes);

			if (dirty & /*color*/ 2) {
				each_value = ["red", "blue", "green"];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < 3; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(div1, null);
					}
				}

				group_outros();

				for (i = 3; i < 3; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			transition_in(formfield.$$.fragment, local);

			for (let i = 0; i < 3; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			transition_out(button.$$.fragment, local);
			transition_out(formfield.$$.fragment, local);
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < 3; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div0);
			destroy_component(button);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(div1);
			destroy_component(formfield);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$8.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$8($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("ClassMap", slots, []);
	let big = false;
	let color = "red";
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ClassMap> was created with unknown prop '${key}'`);
	});

	function checkbox_checked_binding(value) {
		big = value;
		$$invalidate(0, big);
	}

	function radio_group_binding(value) {
		color = value;
		$$invalidate(1, color);
	}

	$$self.$capture_state = () => ({
		classMap,
		Label: CommonLabel,
		Button: Button_1,
		FormField,
		Radio,
		Checkbox,
		big,
		color
	});

	$$self.$inject_state = $$props => {
		if ("big" in $$props) $$invalidate(0, big = $$props.big);
		if ("color" in $$props) $$invalidate(1, color = $$props.color);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [big, color, checkbox_checked_binding, radio_group_binding];
}

class ClassMap extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$8, create_fragment$8, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ClassMap",
			options,
			id: create_fragment$8.name
		});
	}
}

/* src/routes/demo/common/_Dispatch.svelte generated by Svelte v3.37.0 */
const file$6 = "src/routes/demo/common/_Dispatch.svelte";

// (14:0) <Button on:click={dispatchEvent}>
function create_default_slot$5(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Dispatch Event");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Dispatch Event");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$5.name,
		type: "slot",
		source: "(14:0) <Button on:click={dispatchEvent}>",
		ctx
	});

	return block;
}

function create_fragment$7(ctx) {
	let div3;
	let t0;
	let div2;
	let div1;
	let div0;
	let t1;
	let t2;
	let br;
	let t3;
	let button;
	let t4;
	let pre;
	let t5;
	let t6_value = (/*event*/ ctx[1] && JSON.stringify(/*event*/ ctx[1].detail)) + "";
	let t6;
	let current;
	let mounted;
	let dispose;

	button = new Button_1({
			props: {
				$$slots: { default: [create_default_slot$5] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button.$on("click", /*dispatchEvent*/ ctx[2]);

	const block = {
		c: function create() {
			div3 = element("div");
			t0 = text("I'm the event listener.\n\n  ");
			div2 = element("div");
			div1 = element("div");
			div0 = element("div");
			t1 = text("I'm the event target.");
			t2 = space();
			br = element("br");
			t3 = space();
			create_component(button.$$.fragment);
			t4 = space();
			pre = element("pre");
			t5 = text("Caught Event Detail: ");
			t6 = text(t6_value);
			this.h();
		},
		l: function claim(nodes) {
			div3 = claim_element(nodes, "DIV", { class: true });
			var div3_nodes = children(div3);
			t0 = claim_text(div3_nodes, "I'm the event listener.\n\n  ");
			div2 = claim_element(div3_nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			div1 = claim_element(div2_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			t1 = claim_text(div0_nodes, "I'm the event target.");
			div0_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			div2_nodes.forEach(detach_dev);
			div3_nodes.forEach(detach_dev);
			t2 = claim_space(nodes);
			br = claim_element(nodes, "BR", {});
			t3 = claim_space(nodes);
			claim_component(button.$$.fragment, nodes);
			t4 = claim_space(nodes);
			pre = claim_element(nodes, "PRE", { class: true });
			var pre_nodes = children(pre);
			t5 = claim_text(pre_nodes, "Caught Event Detail: ");
			t6 = claim_text(pre_nodes, t6_value);
			pre_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "class", "event svelte-1szpskr");
			add_location(div0, file$6, 6, 6, 201);
			attr_dev(div1, "class", "event svelte-1szpskr");
			add_location(div1, file$6, 5, 4, 175);
			attr_dev(div2, "class", "event svelte-1szpskr");
			add_location(div2, file$6, 4, 2, 151);
			attr_dev(div3, "class", "event svelte-1szpskr");
			add_location(div3, file$6, 1, 0, 70);
			add_location(br, file$6, 11, 0, 295);
			attr_dev(pre, "class", "status");
			add_location(pre, file$6, 15, 0, 361);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div3, anchor);
			append_dev(div3, t0);
			append_dev(div3, div2);
			append_dev(div2, div1);
			append_dev(div1, div0);
			append_dev(div0, t1);
			/*div0_binding*/ ctx[3](div0);
			insert_dev(target, t2, anchor);
			insert_dev(target, br, anchor);
			insert_dev(target, t3, anchor);
			mount_component(button, target, anchor);
			insert_dev(target, t4, anchor);
			insert_dev(target, pre, anchor);
			append_dev(pre, t5);
			append_dev(pre, t6);
			current = true;

			if (!mounted) {
				dispose = listen_dev(div3, "MyEvent", /*MyEvent_handler*/ ctx[4], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			const button_changes = {};

			if (dirty & /*$$scope*/ 32) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
			if ((!current || dirty & /*event*/ 2) && t6_value !== (t6_value = (/*event*/ ctx[1] && JSON.stringify(/*event*/ ctx[1].detail)) + "")) set_data_dev(t6, t6_value);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div3);
			/*div0_binding*/ ctx[3](null);
			if (detaching) detach_dev(t2);
			if (detaching) detach_dev(br);
			if (detaching) detach_dev(t3);
			destroy_component(button, detaching);
			if (detaching) detach_dev(t4);
			if (detaching) detach_dev(pre);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$7.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$7($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Dispatch", slots, []);
	let target;
	let event;

	function dispatchEvent() {
		dispatch(
			target,
			"MyEvent",
			{
				// This is the event.details object.
				time: new Date().toLocaleTimeString()
			},
			{
				// This is the eventInit object.
				bubbles: true, // this is the default when no eventInit object is provided.
				cancelable: true, // you can make it cancelable like this.
				
			}
		);
	}

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Dispatch> was created with unknown prop '${key}'`);
	});

	function div0_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			target = $$value;
			$$invalidate(0, target);
		});
	}

	const MyEvent_handler = e => $$invalidate(1, event = e);

	$$self.$capture_state = () => ({
		dispatch,
		Button: Button_1,
		target,
		event,
		dispatchEvent
	});

	$$self.$inject_state = $$props => {
		if ("target" in $$props) $$invalidate(0, target = $$props.target);
		if ("event" in $$props) $$invalidate(1, event = $$props.event);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [target, event, dispatchEvent, div0_binding, MyEvent_handler];
}

class Dispatch extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$7, create_fragment$7, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Dispatch",
			options,
			id: create_fragment$7.name
		});
	}
}

/* src/routes/demo/common/_ExcludeAndPrefixFilterComponent.svelte generated by Svelte v3.37.0 */
const file$5 = "src/routes/demo/common/_ExcludeAndPrefixFilterComponent.svelte";

// (2:2) <Button     on:click     class="button {button$class}"     {...prefixFilter($$restProps, 'button$')}   >
function create_default_slot$4(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[3].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		l: function claim(nodes) {
			if (default_slot) default_slot.l(nodes);
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 32) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[5], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$4.name,
		type: "slot",
		source: "(2:2) <Button     on:click     class=\\\"button {button$class}\\\"     {...prefixFilter($$restProps, 'button$')}   >",
		ctx
	});

	return block;
}

function create_fragment$6(ctx) {
	let div;
	let button;
	let div_class_value;
	let current;

	const button_spread_levels = [
		{
			class: "button " + /*button$class*/ ctx[1]
		},
		prefixFilter(/*$$restProps*/ ctx[2], "button$")
	];

	let button_props = {
		$$slots: { default: [create_default_slot$4] },
		$$scope: { ctx }
	};

	for (let i = 0; i < button_spread_levels.length; i += 1) {
		button_props = assign(button_props, button_spread_levels[i]);
	}

	button = new Button_1({ props: button_props, $$inline: true });
	button.$on("click", /*click_handler*/ ctx[4]);

	let div_levels = [
		{
			class: div_class_value = "my-component " + /*className*/ ctx[0]
		},
		exclude(/*$$restProps*/ ctx[2], ["button$"])
	];

	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			create_component(button.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			claim_component(button.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_attributes(div, div_data);
			add_location(div, file$5, 0, 0, 0);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(button, div, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const button_changes = (dirty & /*button$class, prefixFilter, $$restProps*/ 6)
			? get_spread_update(button_spread_levels, [
					dirty & /*button$class*/ 2 && {
						class: "button " + /*button$class*/ ctx[1]
					},
					dirty & /*prefixFilter, $$restProps*/ 4 && get_spread_object(prefixFilter(/*$$restProps*/ ctx[2], "button$"))
				])
			: {};

			if (dirty & /*$$scope*/ 32) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*className*/ 1 && div_class_value !== (div_class_value = "my-component " + /*className*/ ctx[0])) && { class: div_class_value },
				dirty & /*$$restProps*/ 4 && exclude(/*$$restProps*/ ctx[2], ["button$"])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(button);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$6.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$6($$self, $$props, $$invalidate) {
	const omit_props_names = ["class","button$class"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("ExcludeAndPrefixFilterComponent", slots, ['default']);
	let { class: className = "" } = $$props;
	let { button$class = "" } = $$props;

	function click_handler(event) {
		bubble($$self, event);
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(0, className = $$new_props.class);
		if ("button$class" in $$new_props) $$invalidate(1, button$class = $$new_props.button$class);
		if ("$$scope" in $$new_props) $$invalidate(5, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		exclude,
		prefixFilter,
		Button: Button_1,
		className,
		button$class
	});

	$$self.$inject_state = $$new_props => {
		if ("className" in $$props) $$invalidate(0, className = $$new_props.className);
		if ("button$class" in $$props) $$invalidate(1, button$class = $$new_props.button$class);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [className, button$class, $$restProps, slots, click_handler, $$scope];
}

class ExcludeAndPrefixFilterComponent extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$6, create_fragment$6, safe_not_equal, { class: 0, button$class: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ExcludeAndPrefixFilterComponent",
			options,
			id: create_fragment$6.name
		});
	}

	get class() {
		throw new Error("<ExcludeAndPrefixFilterComponent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<ExcludeAndPrefixFilterComponent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get button$class() {
		throw new Error("<ExcludeAndPrefixFilterComponent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set button$class(value) {
		throw new Error("<ExcludeAndPrefixFilterComponent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/demo/common/_ExcludeAndPrefixFilter.svelte generated by Svelte v3.37.0 */

// (1:0) <MyComponent   class="my-class"   button$disabled={disabled}   on:click={() => (disabled = true)} >
function create_default_slot$3(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Click Me Only Once");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Click Me Only Once");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$3.name,
		type: "slot",
		source: "(1:0) <MyComponent   class=\\\"my-class\\\"   button$disabled={disabled}   on:click={() => (disabled = true)} >",
		ctx
	});

	return block;
}

function create_fragment$5(ctx) {
	let mycomponent;
	let current;

	mycomponent = new ExcludeAndPrefixFilterComponent({
			props: {
				class: "my-class",
				button$disabled: /*disabled*/ ctx[0],
				$$slots: { default: [create_default_slot$3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	mycomponent.$on("click", /*click_handler*/ ctx[1]);

	const block = {
		c: function create() {
			create_component(mycomponent.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(mycomponent.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(mycomponent, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const mycomponent_changes = {};
			if (dirty & /*disabled*/ 1) mycomponent_changes.button$disabled = /*disabled*/ ctx[0];

			if (dirty & /*$$scope*/ 4) {
				mycomponent_changes.$$scope = { dirty, ctx };
			}

			mycomponent.$set(mycomponent_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(mycomponent.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(mycomponent.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(mycomponent, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$5.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$5($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("ExcludeAndPrefixFilter", slots, []);
	let disabled = false;
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ExcludeAndPrefixFilter> was created with unknown prop '${key}'`);
	});

	const click_handler = () => $$invalidate(0, disabled = true);
	$$self.$capture_state = () => ({ MyComponent: ExcludeAndPrefixFilterComponent, disabled });

	$$self.$inject_state = $$props => {
		if ("disabled" in $$props) $$invalidate(0, disabled = $$props.disabled);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [disabled, click_handler];
}

class ExcludeAndPrefixFilter extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$5, create_fragment$5, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ExcludeAndPrefixFilter",
			options,
			id: create_fragment$5.name
		});
	}
}

/* src/routes/demo/common/_ForwardEventsBuilderComponent.svelte generated by Svelte v3.37.0 */
const file$4 = "src/routes/demo/common/_ForwardEventsBuilderComponent.svelte";

function create_fragment$4(ctx) {
	let div;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[2].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[1], null);

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { tabindex: true });
			var div_nodes = children(div);
			if (default_slot) default_slot.l(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "tabindex", "0");
			add_location(div, file$4, 0, 0, 0);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;

			if (!mounted) {
				dispose = action_destroyer(/*forwardEvents*/ ctx[0].call(null, div));
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 2) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[1], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("ForwardEventsBuilderComponent", slots, ['default']);
	const forwardEvents = forwardEventsBuilder(get_current_component());
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ForwardEventsBuilderComponent> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ("$$scope" in $$props) $$invalidate(1, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({
		forwardEventsBuilder,
		get_current_component,
		forwardEvents
	});

	return [forwardEvents, $$scope, slots];
}

class ForwardEventsBuilderComponent extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4, create_fragment$4, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ForwardEventsBuilderComponent",
			options,
			id: create_fragment$4.name
		});
	}
}

/* src/routes/demo/common/_ForwardEventsBuilder.svelte generated by Svelte v3.37.0 */
const file$3 = "src/routes/demo/common/_ForwardEventsBuilder.svelte";

// (1:0) <MyComponent   on:click={() => clicked++}   on:keypress$preventDefault={(event) => (key = event.key)}   on:focus={() => (focused = true)}   on:blur={() => (focused = false)} >
function create_default_slot$2(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Click me, key press me, focus me, blur me, use me however you want.");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Click me, key press me, focus me, blur me, use me however you want.");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$2.name,
		type: "slot",
		source: "(1:0) <MyComponent   on:click={() => clicked++}   on:keypress$preventDefault={(event) => (key = event.key)}   on:focus={() => (focused = true)}   on:blur={() => (focused = false)} >",
		ctx
	});

	return block;
}

function create_fragment$3(ctx) {
	let mycomponent;
	let t0;
	let pre;
	let t1;
	let t2;
	let t3;
	let t4_value = (/*key*/ ctx[1] === " " ? "Space" : /*key*/ ctx[1]) + "";
	let t4;
	let t5;
	let t6;
	let current;

	mycomponent = new ForwardEventsBuilderComponent({
			props: {
				$$slots: { default: [create_default_slot$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	mycomponent.$on("click", /*click_handler*/ ctx[3]);
	mycomponent.$on("keypress$preventDefault", /*keypress_preventDefault_handler*/ ctx[4]);
	mycomponent.$on("focus", /*focus_handler*/ ctx[5]);
	mycomponent.$on("blur", /*blur_handler*/ ctx[6]);

	const block = {
		c: function create() {
			create_component(mycomponent.$$.fragment);
			t0 = space();
			pre = element("pre");
			t1 = text("Clicked: ");
			t2 = text(/*clicked*/ ctx[0]);
			t3 = text(", Key Pressed: ");
			t4 = text(t4_value);
			t5 = text(", Focused: ");
			t6 = text(/*focused*/ ctx[2]);
			this.h();
		},
		l: function claim(nodes) {
			claim_component(mycomponent.$$.fragment, nodes);
			t0 = claim_space(nodes);
			pre = claim_element(nodes, "PRE", { class: true });
			var pre_nodes = children(pre);
			t1 = claim_text(pre_nodes, "Clicked: ");
			t2 = claim_text(pre_nodes, /*clicked*/ ctx[0]);
			t3 = claim_text(pre_nodes, ", Key Pressed: ");
			t4 = claim_text(pre_nodes, t4_value);
			t5 = claim_text(pre_nodes, ", Focused: ");
			t6 = claim_text(pre_nodes, /*focused*/ ctx[2]);
			pre_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(pre, "class", "status");
			add_location(pre, file$3, 9, 0, 262);
		},
		m: function mount(target, anchor) {
			mount_component(mycomponent, target, anchor);
			insert_dev(target, t0, anchor);
			insert_dev(target, pre, anchor);
			append_dev(pre, t1);
			append_dev(pre, t2);
			append_dev(pre, t3);
			append_dev(pre, t4);
			append_dev(pre, t5);
			append_dev(pre, t6);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const mycomponent_changes = {};

			if (dirty & /*$$scope*/ 128) {
				mycomponent_changes.$$scope = { dirty, ctx };
			}

			mycomponent.$set(mycomponent_changes);
			if (!current || dirty & /*clicked*/ 1) set_data_dev(t2, /*clicked*/ ctx[0]);
			if ((!current || dirty & /*key*/ 2) && t4_value !== (t4_value = (/*key*/ ctx[1] === " " ? "Space" : /*key*/ ctx[1]) + "")) set_data_dev(t4, t4_value);
			if (!current || dirty & /*focused*/ 4) set_data_dev(t6, /*focused*/ ctx[2]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(mycomponent.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(mycomponent.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(mycomponent, detaching);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(pre);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("ForwardEventsBuilder", slots, []);
	let clicked = 0;
	let key = "None";
	let focused = false;
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ForwardEventsBuilder> was created with unknown prop '${key}'`);
	});

	const click_handler = () => $$invalidate(0, clicked++, clicked);
	const keypress_preventDefault_handler = event => $$invalidate(1, key = event.key);
	const focus_handler = () => $$invalidate(2, focused = true);
	const blur_handler = () => $$invalidate(2, focused = false);
	$$self.$capture_state = () => ({ MyComponent: ForwardEventsBuilderComponent, clicked, key, focused });

	$$self.$inject_state = $$props => {
		if ("clicked" in $$props) $$invalidate(0, clicked = $$props.clicked);
		if ("key" in $$props) $$invalidate(1, key = $$props.key);
		if ("focused" in $$props) $$invalidate(2, focused = $$props.focused);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		clicked,
		key,
		focused,
		click_handler,
		keypress_preventDefault_handler,
		focus_handler,
		blur_handler
	];
}

class ForwardEventsBuilder extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3, create_fragment$3, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ForwardEventsBuilder",
			options,
			id: create_fragment$3.name
		});
	}
}

/* src/routes/demo/common/_UseActionsComponent.svelte generated by Svelte v3.37.0 */
const file$2 = "src/routes/demo/common/_UseActionsComponent.svelte";

function create_fragment$2(ctx) {
	let div;
	let span;
	let useActions_action;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[2].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[1], null);

	const block = {
		c: function create() {
			div = element("div");
			span = element("span");
			if (default_slot) default_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			span = claim_element(div_nodes, "SPAN", { style: true });
			var span_nodes = children(span);
			if (default_slot) default_slot.l(span_nodes);
			span_nodes.forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_style(span, "user-select", "none");
			add_location(span, file$2, 1, 2, 44);
			attr_dev(div, "class", "target svelte-1xr4yot");
			add_location(div, file$2, 0, 0, 0);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, span);

			if (default_slot) {
				default_slot.m(span, null);
			}

			current = true;

			if (!mounted) {
				dispose = action_destroyer(useActions_action = useActions.call(null, div, /*use*/ ctx[0]));
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 2) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[1], dirty, null, null);
				}
			}

			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("UseActionsComponent", slots, ['default']);
	let { use = [] } = $$props;
	const writable_props = ["use"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<UseActionsComponent> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ("use" in $$props) $$invalidate(0, use = $$props.use);
		if ("$$scope" in $$props) $$invalidate(1, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({ useActions, use });

	$$self.$inject_state = $$props => {
		if ("use" in $$props) $$invalidate(0, use = $$props.use);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [use, $$scope, slots];
}

class UseActionsComponent extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2, create_fragment$2, safe_not_equal, { use: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "UseActionsComponent",
			options,
			id: create_fragment$2.name
		});
	}

	get use() {
		throw new Error("<UseActionsComponent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set use(value) {
		throw new Error("<UseActionsComponent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/**
 * TinyGesture.js
 *
 * This service uses passive listeners, so you can't call event.preventDefault()
 * on any of the events.
 *
 * Adapted from https://gist.github.com/SleepWalker/da5636b1abcbaff48c4d
 * and https://github.com/uxitten/xwiper
 */
class TinyGesture {
  constructor (element, options) {
    options = Object.assign({}, TinyGesture.defaults, options);
    this.element = element;
    this.opts = options;
    this.touchStartX = null;
    this.touchStartY = null;
    this.touchEndX = null;
    this.touchEndY = null;
    this.velocityX = null;
    this.velocityY = null;
    this.longPressTimer = null;
    this.doubleTapWaiting = false;
    this.handlers = {
      'panstart': [],
      'panmove': [],
      'panend': [],
      'swipeleft': [],
      'swiperight': [],
      'swipeup': [],
      'swipedown': [],
      'tap': [],
      'doubletap': [],
      'longpress': []
    };

    this._onTouchStart = this.onTouchStart.bind(this);
    this._onTouchMove = this.onTouchMove.bind(this);
    this._onTouchEnd = this.onTouchEnd.bind(this);

    this.element.addEventListener('touchstart', this._onTouchStart, passiveIfSupported);
    this.element.addEventListener('touchmove', this._onTouchMove, passiveIfSupported);
    this.element.addEventListener('touchend', this._onTouchEnd, passiveIfSupported);

    if (this.opts.mouseSupport && !('ontouchstart' in window)) {
      this.element.addEventListener('mousedown', this._onTouchStart, passiveIfSupported);
      document.addEventListener('mousemove', this._onTouchMove, passiveIfSupported);
      document.addEventListener('mouseup', this._onTouchEnd, passiveIfSupported);
    }
  }

  destroy () {
    this.element.removeEventListener('touchstart', this._onTouchStart);
    this.element.removeEventListener('touchmove', this._onTouchMove);
    this.element.removeEventListener('touchend', this._onTouchEnd);
    this.element.removeEventListener('mousedown', this._onTouchStart);
    document.removeEventListener('mousemove', this._onTouchMove);
    document.removeEventListener('mouseup', this._onTouchEnd);
    clearTimeout(this.longPressTimer);
    clearTimeout(this.doubleTapTimer);
  }

  on (type, fn) {
    if (this.handlers[type]) {
      this.handlers[type].push(fn);
      return {
        type,
        fn,
        cancel: () => this.off(type, fn)
      };
    }
  }

  off (type, fn) {
    if (this.handlers[type]) {
      const idx = this.handlers[type].indexOf(fn);
      if (idx !== -1) {
        this.handlers[type].splice(idx, 1);
      }
    }
  }

  fire (type, event) {
    for (let i = 0; i < this.handlers[type].length; i++) {
      this.handlers[type][i](event);
    }
  }

  onTouchStart (event) {
    this.thresholdX = this.opts.threshold('x', this);
    this.thresholdY = this.opts.threshold('y', this);
    this.disregardVelocityThresholdX = this.opts.disregardVelocityThreshold('x', this);
    this.disregardVelocityThresholdY = this.opts.disregardVelocityThreshold('y', this);
    this.touchStartX = (event.type === 'mousedown' ? event.screenX : event.changedTouches[0].screenX);
    this.touchStartY = (event.type === 'mousedown' ? event.screenY : event.changedTouches[0].screenY);
    this.touchMoveX = null;
    this.touchMoveY = null;
    this.touchEndX = null;
    this.touchEndY = null;
    // Long press.
    this.longPressTimer = setTimeout(() => this.fire('longpress', event), this.opts.longPressTime);
    this.fire('panstart', event);
  }

  onTouchMove (event) {
    if (event.type === 'mousemove' && (!this.touchStartX || this.touchEndX !== null)) {
      return;
    }
    const touchMoveX = (event.type === 'mousemove' ? event.screenX : event.changedTouches[0].screenX) - this.touchStartX;
    this.velocityX = touchMoveX - this.touchMoveX;
    this.touchMoveX = touchMoveX;
    const touchMoveY = (event.type === 'mousemove' ? event.screenY : event.changedTouches[0].screenY) - this.touchStartY;
    this.velocityY = touchMoveY - this.touchMoveY;
    this.touchMoveY = touchMoveY;
    const absTouchMoveX = Math.abs(this.touchMoveX);
    const absTouchMoveY = Math.abs(this.touchMoveY);
    this.swipingHorizontal = absTouchMoveX > this.thresholdX;
    this.swipingVertical = absTouchMoveY > this.thresholdY;
    this.swipingDirection = absTouchMoveX > absTouchMoveY
      ? (this.swipingHorizontal ? 'horizontal' : 'pre-horizontal')
      : (this.swipingVertical ? 'vertical' : 'pre-vertical');
    if (Math.max(absTouchMoveX, absTouchMoveY) > this.opts.pressThreshold) {
      clearTimeout(this.longPressTimer);
    }
    this.fire('panmove', event);
  }

  onTouchEnd (event) {
    if (event.type === 'mouseup' && (!this.touchStartX || this.touchEndX !== null)) {
      return;
    }
    this.touchEndX = (event.type === 'mouseup' ? event.screenX : event.changedTouches[0].screenX);
    this.touchEndY = (event.type === 'mouseup' ? event.screenY : event.changedTouches[0].screenY);
    this.fire('panend', event);
    clearTimeout(this.longPressTimer);

    const x = this.touchEndX - this.touchStartX;
    const absX = Math.abs(x);
    const y = this.touchEndY - this.touchStartY;
    const absY = Math.abs(y);

    if (absX > this.thresholdX || absY > this.thresholdY) {
      this.swipedHorizontal = this.opts.diagonalSwipes ? Math.abs(x / y) <= this.opts.diagonalLimit : absX >= absY && absX > this.thresholdX;
      this.swipedVertical = this.opts.diagonalSwipes ? Math.abs(y / x) <= this.opts.diagonalLimit : absY > absX && absY > this.thresholdY;
      if (this.swipedHorizontal) {
        if (x < 0) {
          // Left swipe.
          if (this.velocityX < -this.opts.velocityThreshold || x < -this.disregardVelocityThresholdX) {
            this.fire('swipeleft', event);
          }
        } else {
          // Right swipe.
          if (this.velocityX > this.opts.velocityThreshold || x > this.disregardVelocityThresholdX) {
            this.fire('swiperight', event);
          }
        }
      }
      if (this.swipedVertical) {
        if (y < 0) {
          // Upward swipe.
          if (this.velocityY < -this.opts.velocityThreshold || y < -this.disregardVelocityThresholdY) {
            this.fire('swipeup', event);
          }
        } else {
          // Downward swipe.
          if (this.velocityY > this.opts.velocityThreshold || y > this.disregardVelocityThresholdY) {
            this.fire('swipedown', event);
          }
        }
      }
    } else if (absX < this.opts.pressThreshold && absY < this.opts.pressThreshold) {
      // Tap.
      if (this.doubleTapWaiting) {
        this.doubleTapWaiting = false;
        clearTimeout(this.doubleTapTimer);
        this.fire('doubletap', event);
      } else {
        this.doubleTapWaiting = true;
        this.doubleTapTimer = setTimeout(() => this.doubleTapWaiting = false, this.opts.doubleTapTime);
        this.fire('tap', event);
      }
    }
  }
}

TinyGesture.defaults = {
  threshold: (type, self) => Math.max(25, Math.floor(0.15 * (type === 'x' ? window.innerWidth || document.body.clientWidth : window.innerHeight || document.body.clientHeight))),
  velocityThreshold: 10,
  disregardVelocityThreshold: (type, self) => Math.floor(0.5 * (type === 'x' ? self.element.clientWidth : self.element.clientHeight)),
  pressThreshold: 8,
  diagonalSwipes: false,
  diagonalLimit: Math.tan(45 * 1.5 / 180 * Math.PI),
  longPressTime: 500,
  doubleTapTime: 300,
  mouseSupport: true
};

// Passive feature detection.
let passiveIfSupported = false;

try {
  window.addEventListener('test', null, Object.defineProperty({}, 'passive', { get: function() { passiveIfSupported = { passive: true }; } }));
} catch(err) {}

function cubicInOut(t) {
    return t < 0.5 ? 4.0 * t * t * t : 0.5 * Math.pow(2.0 * t - 2.0, 3.0) + 1.0;
}

function is_date(obj) {
    return Object.prototype.toString.call(obj) === '[object Date]';
}

function get_interpolator(a, b) {
    if (a === b || a !== a)
        return () => a;
    const type = typeof a;
    if (type !== typeof b || Array.isArray(a) !== Array.isArray(b)) {
        throw new Error('Cannot interpolate values of different type');
    }
    if (Array.isArray(a)) {
        const arr = b.map((bi, i) => {
            return get_interpolator(a[i], bi);
        });
        return t => arr.map(fn => fn(t));
    }
    if (type === 'object') {
        if (!a || !b)
            throw new Error('Object cannot be null');
        if (is_date(a) && is_date(b)) {
            a = a.getTime();
            b = b.getTime();
            const delta = b - a;
            return t => new Date(a + t * delta);
        }
        const keys = Object.keys(b);
        const interpolators = {};
        keys.forEach(key => {
            interpolators[key] = get_interpolator(a[key], b[key]);
        });
        return t => {
            const result = {};
            keys.forEach(key => {
                result[key] = interpolators[key](t);
            });
            return result;
        };
    }
    if (type === 'number') {
        const delta = b - a;
        return t => a + t * delta;
    }
    throw new Error(`Cannot interpolate ${type} values`);
}
function tweened(value, defaults = {}) {
    const store = writable(value);
    let task;
    let target_value = value;
    function set(new_value, opts) {
        if (value == null) {
            store.set(value = new_value);
            return Promise.resolve();
        }
        target_value = new_value;
        let previous_task = task;
        let started = false;
        let { delay = 0, duration = 400, easing = identity, interpolate = get_interpolator } = assign(assign({}, defaults), opts);
        if (duration === 0) {
            if (previous_task) {
                previous_task.abort();
                previous_task = null;
            }
            store.set(value = target_value);
            return Promise.resolve();
        }
        const start = now() + delay;
        let fn;
        task = loop(now => {
            if (now < start)
                return true;
            if (!started) {
                fn = interpolate(value, new_value);
                if (typeof duration === 'function')
                    duration = duration(value, new_value);
                started = true;
            }
            if (previous_task) {
                previous_task.abort();
                previous_task = null;
            }
            const elapsed = now - start;
            if (elapsed > duration) {
                store.set(value = new_value);
                return false;
            }
            // @ts-ignore
            store.set(value = fn(easing(elapsed / duration)));
            return true;
        });
        return task.promise;
    }
    return {
        set,
        update: (fn, opts) => set(fn(target_value, value), opts),
        subscribe: store.subscribe
    };
}

function Pannable(node) {
  const gesture = new TinyGesture(node);
  let animationFrame = null;
  const preventDefault = (event) => {
    event.preventDefault();
  };

  const left = tweened(0, {
    duration: 300,
    easing: cubicInOut,
  });
  const top = tweened(0, {
    duration: 300,
    easing: cubicInOut,
  });

  const leftUnsub = left.subscribe((value) => {
    node.style.left = value + 'px';
  });
  const topUnsub = top.subscribe((value) => {
    node.style.top = value + 'px';
  });

  node.style.transition =
    (node.style.transition ? node.style.transition + ', ' : '') +
    'opacity ease .3s';

  node.addEventListener('touchstart', preventDefault, { passive: false });

  gesture.on('panmove', () => {
    if (animationFrame) {
      return;
    }
    animationFrame = window.requestAnimationFrame(() => {
      if (!gesture.swipingDirection.startsWith('pre-')) {
        node.style.opacity = '0.7';
      } else {
        node.style.opacity = '1';
      }
      node.style.transform =
        'rotate(' + (gesture.touchMoveX / 8 + gesture.touchMoveY / 8) + 'deg)';
      left.set(gesture.touchMoveX, { duration: 0 });
      top.set(gesture.touchMoveY, { duration: 0 });
      animationFrame = null;
    });
  });

  gesture.on('panend', () => {
    window.cancelAnimationFrame(animationFrame);
    animationFrame = null;
    node.style.transform = null;
    left.set(0);
    top.set(0);
    node.style.opacity = '1';
  });

  return {
    destroy() {
      node.removeEventListener('touchstart', preventDefault, {
        passive: false,
      });
      window.cancelAnimationFrame(animationFrame);
      leftUnsub();
      topUnsub();
      gesture.destroy();
    },
  };
}

function Swipeable(node) {
  const gesture = new TinyGesture(node);
  let timeout;
  const preventDefault = (event) => {
    event.preventDefault();
  };

  node.style.transition =
    (node.style.transition ? node.style.transition + ', ' : '') +
    'transform ease 0.3s';

  node.addEventListener('touchstart', preventDefault, { passive: false });

  gesture.on('swiperight', () => {
    node.style.transform = 'perspective(1000px) translate3d(2000px, 0, 0)';
    clearTimeout(timeout);
    setTimeout(() => (node.style.transform = null), 1000);
  });
  gesture.on('swipeleft', () => {
    node.style.transform = 'perspective(1000px) translate3d(-2000px, 0, 0)';
    clearTimeout(timeout);
    setTimeout(() => (node.style.transform = null), 1000);
  });
  gesture.on('swipeup', () => {
    node.style.transform = 'perspective(1000px) translate3d(0, -2000px, 0)';
    clearTimeout(timeout);
    setTimeout(() => (node.style.transform = null), 1000);
  });
  gesture.on('swipedown', () => {
    node.style.transform = 'perspective(1000px) translate3d(0, 2000px, 0)';
    clearTimeout(timeout);
    setTimeout(() => (node.style.transform = null), 1000);
  });

  return {
    destroy() {
      node.removeEventListener('touchstart', preventDefault, {
        passive: false,
      });
      clearTimeout(timeout);
      gesture.destroy();
    },
  };
}

function Tappable(node, options) {
  const gesture = new TinyGesture(node);
  let tapTimeout;
  let pressTimeout;
  let pressed = false;

  node.style.transition =
    (node.style.transition ? node.style.transition + ', ' : '') +
    'background-color ease 0.3s, color ease 0.3s';

  gesture.on('tap', () => {
    if (!pressed) {
      node.style.transform = 'perspective(1000px) translate3d(0, 0, 100px)';
      clearTimeout(tapTimeout);
      tapTimeout = setTimeout(() => (node.style.transform = null), 300);
    }
    pressed = false;
  });
  gesture.on('doubletap', () => {
    node.style.transform = 'perspective(1000px) translate3d(0, 0, 400px)';
    clearTimeout(tapTimeout);
    tapTimeout = setTimeout(() => (node.style.transform = null), 300);
  });
  gesture.on('longpress', () => {
    pressed = true;
    node.style.backgroundColor = options.bgColor;
    node.style.color = options.color;
    clearTimeout(pressTimeout);
  });

  gesture.on('panend', () => {
    pressTimeout = setTimeout(() => {
      node.style.backgroundColor = null;
      node.style.color = null;
    }, 300);
  });

  return {
    destroy() {
      clearTimeout(tapTimeout);
      clearTimeout(pressTimeout);
      gesture.destroy();
    },
  };
}

/* src/routes/demo/common/_UseActions.svelte generated by Svelte v3.37.0 */
const file$1 = "src/routes/demo/common/_UseActions.svelte";

// (2:2) <MyComponent     use={[       Pannable,       Swipeable,       [         Tappable,         {           bgColor: 'var(--mdc-theme-secondary)',           color: 'var(--mdc-theme-on-secondary)',         },       ],     ]}   >
function create_default_slot$1(ctx) {
	let t0;
	let br0;
	let t1;
	let br1;
	let t2;

	const block = {
		c: function create() {
			t0 = text("Swipe me.");
			br0 = element("br");
			t1 = text("\n    Tap me.");
			br1 = element("br");
			t2 = text("\n    Press me.");
			this.h();
		},
		l: function claim(nodes) {
			t0 = claim_text(nodes, "Swipe me.");
			br0 = claim_element(nodes, "BR", {});
			t1 = claim_text(nodes, "\n    Tap me.");
			br1 = claim_element(nodes, "BR", {});
			t2 = claim_text(nodes, "\n    Press me.");
			this.h();
		},
		h: function hydrate() {
			add_location(br0, file$1, 14, 13, 262);
			add_location(br1, file$1, 15, 11, 280);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			insert_dev(target, br0, anchor);
			insert_dev(target, t1, anchor);
			insert_dev(target, br1, anchor);
			insert_dev(target, t2, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(br0);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(br1);
			if (detaching) detach_dev(t2);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$1.name,
		type: "slot",
		source: "(2:2) <MyComponent     use={[       Pannable,       Swipeable,       [         Tappable,         {           bgColor: 'var(--mdc-theme-secondary)',           color: 'var(--mdc-theme-on-secondary)',         },       ],     ]}   >",
		ctx
	});

	return block;
}

function create_fragment$1(ctx) {
	let div;
	let mycomponent;
	let current;

	mycomponent = new UseActionsComponent({
			props: {
				use: [
					Pannable,
					Swipeable,
					[
						Tappable,
						{
							bgColor: "var(--mdc-theme-secondary)",
							color: "var(--mdc-theme-on-secondary)"
						}
					]
				],
				$$slots: { default: [create_default_slot$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			div = element("div");
			create_component(mycomponent.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			claim_component(mycomponent.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "container svelte-i78oca");
			add_location(div, file$1, 0, 0, 0);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(mycomponent, div, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const mycomponent_changes = {};

			if (dirty & /*$$scope*/ 1) {
				mycomponent_changes.$$scope = { dirty, ctx };
			}

			mycomponent.$set(mycomponent_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(mycomponent.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(mycomponent.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(mycomponent);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("UseActions", slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<UseActions> was created with unknown prop '${key}'`);
	});

	$$self.$capture_state = () => ({
		MyComponent: UseActionsComponent,
		Pannable,
		Swipeable,
		Tappable
	});

	return [];
}

class UseActions extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$1, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "UseActions",
			options,
			id: create_fragment$1.name
		});
	}
}

/* src/routes/demo/common/index.svelte generated by Svelte v3.37.0 */
const file = "src/routes/demo/common/index.svelte";

// (11:2) <Demo component={CommonLabelIcon} file="common/_CommonLabelIcon.svelte">
function create_default_slot_9(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Common Label and Icon");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Common Label and Icon");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_9.name,
		type: "slot",
		source: "(11:2) <Demo component={CommonLabelIcon} file=\\\"common/_CommonLabelIcon.svelte\\\">",
		ctx
	});

	return block;
}

// (13:4) <svelte:fragment slot="subtitle">
function create_subtitle_slot_9(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("The common label and icon are also exported from each package that uses\n      them.");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "The common label and icon are also exported from each package that uses\n      them.");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_subtitle_slot_9.name,
		type: "slot",
		source: "(13:4) <svelte:fragment slot=\\\"subtitle\\\">",
		ctx
	});

	return block;
}

// (21:2) <Demo component={TargetingClasses} file="common/_TargetingClasses.svelte">
function create_default_slot_8(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Targeting Classes");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Targeting Classes");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_8.name,
		type: "slot",
		source: "(21:2) <Demo component={TargetingClasses} file=\\\"common/_TargetingClasses.svelte\\\">",
		ctx
	});

	return block;
}

// (23:4) <svelte:fragment slot="subtitle">
function create_subtitle_slot_8(ctx) {
	let t0;
	let em;
	let t1;
	let t2;

	const block = {
		c: function create() {
			t0 = text("Because Svelte limits your CSS to ");
			em = element("em");
			t1 = text("only");
			t2 = text(" the current component, you\n      need to use a \":global\" selector to target SMUI elements.");
			this.h();
		},
		l: function claim(nodes) {
			t0 = claim_text(nodes, "Because Svelte limits your CSS to ");
			em = claim_element(nodes, "EM", {});
			var em_nodes = children(em);
			t1 = claim_text(em_nodes, "only");
			em_nodes.forEach(detach_dev);
			t2 = claim_text(nodes, " the current component, you\n      need to use a \":global\" selector to target SMUI elements.");
			this.h();
		},
		h: function hydrate() {
			add_location(em, file, 23, 40, 709);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			insert_dev(target, em, anchor);
			append_dev(em, t1);
			insert_dev(target, t2, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(em);
			if (detaching) detach_dev(t2);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_subtitle_slot_8.name,
		type: "slot",
		source: "(23:4) <svelte:fragment slot=\\\"subtitle\\\">",
		ctx
	});

	return block;
}

// (29:2) <Demo component={EventsAndModifiers} file="common/_EventsAndModifiers.svelte">
function create_default_slot_7(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Events and Modifiers");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Events and Modifiers");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_7.name,
		type: "slot",
		source: "(29:2) <Demo component={EventsAndModifiers} file=\\\"common/_EventsAndModifiers.svelte\\\">",
		ctx
	});

	return block;
}

// (31:4) <svelte:fragment slot="subtitle">
function create_subtitle_slot_7(ctx) {
	let t0;
	let strong;
	let t1;
	let t2;

	const block = {
		c: function create() {
			t0 = text("SMUI supports listening to ");
			strong = element("strong");
			t1 = text("all");
			t2 = text(" events. You can also use modifiers\n      with the \"$\" syntax.");
			this.h();
		},
		l: function claim(nodes) {
			t0 = claim_text(nodes, "SMUI supports listening to ");
			strong = claim_element(nodes, "STRONG", {});
			var strong_nodes = children(strong);
			t1 = claim_text(strong_nodes, "all");
			strong_nodes.forEach(detach_dev);
			t2 = claim_text(nodes, " events. You can also use modifiers\n      with the \"$\" syntax.");
			this.h();
		},
		h: function hydrate() {
			add_location(strong, file, 31, 33, 1025);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			insert_dev(target, strong, anchor);
			append_dev(strong, t1);
			insert_dev(target, t2, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(strong);
			if (detaching) detach_dev(t2);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_subtitle_slot_7.name,
		type: "slot",
		source: "(31:4) <svelte:fragment slot=\\\"subtitle\\\">",
		ctx
	});

	return block;
}

// (37:2) <Demo     component={ElementalComponents}     file="common/_ElementalComponents.svelte"   >
function create_default_slot_6(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Elemental Components");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Elemental Components");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_6.name,
		type: "slot",
		source: "(37:2) <Demo     component={ElementalComponents}     file=\\\"common/_ElementalComponents.svelte\\\"   >",
		ctx
	});

	return block;
}

// (42:4) <svelte:fragment slot="subtitle">
function create_subtitle_slot_6(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Many SMUI components let you customize which DOM element is used to render\n      them.");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Many SMUI components let you customize which DOM element is used to render\n      them.");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_subtitle_slot_6.name,
		type: "slot",
		source: "(42:4) <svelte:fragment slot=\\\"subtitle\\\">",
		ctx
	});

	return block;
}

// (50:2) <Demo     component={ClassAdderBuilder}     files={[       'common/_ClassAdderBuilder.svelte',       'common/_ClassAdderBuilderComponent.js',     ]}   >
function create_default_slot_5(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Class Adder Builder");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Class Adder Builder");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_5.name,
		type: "slot",
		source: "(50:2) <Demo     component={ClassAdderBuilder}     files={[       'common/_ClassAdderBuilder.svelte',       'common/_ClassAdderBuilderComponent.js',     ]}   >",
		ctx
	});

	return block;
}

// (58:4) <svelte:fragment slot="subtitle">
function create_subtitle_slot_5(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Use this to build a ClassAdder component. ClassAdder components are useful\n      for reducing the size of your bundle. If you have tons of simple\n      components that just need to add classes/props or set a context, using\n      ClassAdder components means there's only one \"big\" Svelte component in\n      your bundle for all of these many tiny components.");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Use this to build a ClassAdder component. ClassAdder components are useful\n      for reducing the size of your bundle. If you have tons of simple\n      components that just need to add classes/props or set a context, using\n      ClassAdder components means there's only one \"big\" Svelte component in\n      your bundle for all of these many tiny components.");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_subtitle_slot_5.name,
		type: "slot",
		source: "(58:4) <svelte:fragment slot=\\\"subtitle\\\">",
		ctx
	});

	return block;
}

// (67:2) <Demo component={ClassMap} file="common/_ClassMap.svelte">
function create_default_slot_4(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Class Map");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Class Map");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_4.name,
		type: "slot",
		source: "(67:2) <Demo component={ClassMap} file=\\\"common/_ClassMap.svelte\\\">",
		ctx
	});

	return block;
}

// (69:4) <svelte:fragment slot="subtitle">
function create_subtitle_slot_4(ctx) {
	let t0;
	let code0;
	let t1;
	let t2;
	let code1;
	let t3;
	let t4;

	const block = {
		c: function create() {
			t0 = text("Build a class string from a map of class names to conditions. This is\n      useful when you need to add classes to a component, since Svelte's\n      \"class:\" directives don't work on components. (It's also useful for\n      actions that take ");
			code0 = element("code");
			t1 = text("addClass");
			t2 = text(" and ");
			code1 = element("code");
			t3 = text("removeClass");
			t4 = text(" functions.)");
			this.h();
		},
		l: function claim(nodes) {
			t0 = claim_text(nodes, "Build a class string from a map of class names to conditions. This is\n      useful when you need to add classes to a component, since Svelte's\n      \"class:\" directives don't work on components. (It's also useful for\n      actions that take ");
			code0 = claim_element(nodes, "CODE", {});
			var code0_nodes = children(code0);
			t1 = claim_text(code0_nodes, "addClass");
			code0_nodes.forEach(detach_dev);
			t2 = claim_text(nodes, " and ");
			code1 = claim_element(nodes, "CODE", {});
			var code1_nodes = children(code1);
			t3 = claim_text(code1_nodes, "removeClass");
			code1_nodes.forEach(detach_dev);
			t4 = claim_text(nodes, " functions.)");
			this.h();
		},
		h: function hydrate() {
			add_location(code0, file, 72, 24, 2429);
			add_location(code1, file, 72, 50, 2455);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			insert_dev(target, code0, anchor);
			append_dev(code0, t1);
			insert_dev(target, t2, anchor);
			insert_dev(target, code1, anchor);
			append_dev(code1, t3);
			insert_dev(target, t4, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(code0);
			if (detaching) detach_dev(t2);
			if (detaching) detach_dev(code1);
			if (detaching) detach_dev(t4);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_subtitle_slot_4.name,
		type: "slot",
		source: "(69:4) <svelte:fragment slot=\\\"subtitle\\\">",
		ctx
	});

	return block;
}

// (77:2) <Demo component={Dispatch} file="common/_Dispatch.svelte">
function create_default_slot_3(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Dispatch");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Dispatch");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3.name,
		type: "slot",
		source: "(77:2) <Demo component={Dispatch} file=\\\"common/_Dispatch.svelte\\\">",
		ctx
	});

	return block;
}

// (79:4) <svelte:fragment slot="subtitle">
function create_subtitle_slot_3(ctx) {
	let t0;
	let code0;
	let t1;
	let t2;
	let code1;
	let t3;
	let t4;

	const block = {
		c: function create() {
			t0 = text("Dispatch a custom event. This differs from Svelte's component event\n      system, because these events require a DOM element as a target, can bubble\n      (and do by default), and are cancelable with ");
			code0 = element("code");
			t1 = text("event.preventDefault()");
			t2 = text(". All SMUI/MDC events are dispatched with this instead of Svelte's\n      ");
			code1 = element("code");
			t3 = text("createEventDispatcher");
			t4 = text(".");
			this.h();
		},
		l: function claim(nodes) {
			t0 = claim_text(nodes, "Dispatch a custom event. This differs from Svelte's component event\n      system, because these events require a DOM element as a target, can bubble\n      (and do by default), and are cancelable with ");
			code0 = claim_element(nodes, "CODE", {});
			var code0_nodes = children(code0);
			t1 = claim_text(code0_nodes, "event.preventDefault()");
			code0_nodes.forEach(detach_dev);
			t2 = claim_text(nodes, ". All SMUI/MDC events are dispatched with this instead of Svelte's\n      ");
			code1 = claim_element(nodes, "CODE", {});
			var code1_nodes = children(code1);
			t3 = claim_text(code1_nodes, "createEventDispatcher");
			code1_nodes.forEach(detach_dev);
			t4 = claim_text(nodes, ".");
			this.h();
		},
		h: function hydrate() {
			add_location(code0, file, 81, 51, 2844);
			add_location(code1, file, 84, 6, 2968);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			insert_dev(target, code0, anchor);
			append_dev(code0, t1);
			insert_dev(target, t2, anchor);
			insert_dev(target, code1, anchor);
			append_dev(code1, t3);
			insert_dev(target, t4, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(code0);
			if (detaching) detach_dev(t2);
			if (detaching) detach_dev(code1);
			if (detaching) detach_dev(t4);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_subtitle_slot_3.name,
		type: "slot",
		source: "(79:4) <svelte:fragment slot=\\\"subtitle\\\">",
		ctx
	});

	return block;
}

// (89:2) <Demo     component={ExcludeAndPrefixFilter}     files={[       'common/_ExcludeAndPrefixFilter.svelte',       'common/_ExcludeAndPrefixFilterComponent.svelte',     ]}   >
function create_default_slot_2(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Exclude and Prefix Filter");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Exclude and Prefix Filter");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2.name,
		type: "slot",
		source: "(89:2) <Demo     component={ExcludeAndPrefixFilter}     files={[       'common/_ExcludeAndPrefixFilter.svelte',       'common/_ExcludeAndPrefixFilterComponent.svelte',     ]}   >",
		ctx
	});

	return block;
}

// (97:4) <svelte:fragment slot="subtitle">
function create_subtitle_slot_2(ctx) {
	let t0;
	let code;
	let t1;
	let t2;

	const block = {
		c: function create() {
			t0 = text("Exclude differs from normal ");
			code = element("code");
			t1 = text("omit");
			t2 = text(" functions by also excluding all\n      properties that begin with a given string if that string ends with \"$\". Prefix\n      Filter filters an object for only properties with a certain prefix. They are\n      usually used together to allow props to be given to multiple elements within\n      a component.");
			this.h();
		},
		l: function claim(nodes) {
			t0 = claim_text(nodes, "Exclude differs from normal ");
			code = claim_element(nodes, "CODE", {});
			var code_nodes = children(code);
			t1 = claim_text(code_nodes, "omit");
			code_nodes.forEach(detach_dev);
			t2 = claim_text(nodes, " functions by also excluding all\n      properties that begin with a given string if that string ends with \"$\". Prefix\n      Filter filters an object for only properties with a certain prefix. They are\n      usually used together to allow props to be given to multiple elements within\n      a component.");
			this.h();
		},
		h: function hydrate() {
			add_location(code, file, 97, 34, 3314);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			insert_dev(target, code, anchor);
			append_dev(code, t1);
			insert_dev(target, t2, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(code);
			if (detaching) detach_dev(t2);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_subtitle_slot_2.name,
		type: "slot",
		source: "(97:4) <svelte:fragment slot=\\\"subtitle\\\">",
		ctx
	});

	return block;
}

// (106:2) <Demo     component={ForwardEventsBuilder}     files={[       'common/_ForwardEventsBuilder.svelte',       'common/_ForwardEventsBuilderComponent.svelte',     ]}   >
function create_default_slot_1(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Forward Events Builder");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Forward Events Builder");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1.name,
		type: "slot",
		source: "(106:2) <Demo     component={ForwardEventsBuilder}     files={[       'common/_ForwardEventsBuilder.svelte',       'common/_ForwardEventsBuilderComponent.svelte',     ]}   >",
		ctx
	});

	return block;
}

// (114:4) <svelte:fragment slot="subtitle">
function create_subtitle_slot_1(ctx) {
	let t0;
	let ul;
	let li0;
	let t1;
	let code0;
	let t2;
	let t3;
	let code1;
	let t4;
	let t5;
	let code2;
	let t6;
	let t7;
	let t8;
	let li1;
	let t9;
	let code3;
	let t10;
	let t11;

	const block = {
		c: function create() {
			t0 = text("Build an action to allow **all** events to be forwarded from a Svelte\n      component, with support for event modifiers using the \"$\" syntax.\n      ");
			ul = element("ul");
			li0 = element("li");
			t1 = text("This is especially useful for UI library components, as it is\n          generally unknown which events will be required from them for all\n          desired use cases. For example, if a Button component only forwards a ");
			code0 = element("code");
			t2 = text("click");
			t3 = text("\n          event, then no use case that requires the ");
			code1 = element("code");
			t4 = text("mouseover");
			t5 = text(" or\n          the\n          ");
			code2 = element("code");
			t6 = text("keypress");
			t7 = text("\n          event can be used with it.");
			t8 = space();
			li1 = element("li");
			t9 = text("In addition, a component that uses Svelte's built in event forwarding\n          system cannot allow event listeners on the \"capture\" phase of the\n          event lifecycle. It also cannot allow events to be cancelable with the\n          browser's built in\n          ");
			code3 = element("code");
			t10 = text("preventDefault");
			t11 = text("\n          function. In fact, the one big advantage to Svelte's event system, the\n          fact that you don't need an element as an event target, doesn't even apply\n          to UI library components.");
			this.h();
		},
		l: function claim(nodes) {
			t0 = claim_text(nodes, "Build an action to allow **all** events to be forwarded from a Svelte\n      component, with support for event modifiers using the \"$\" syntax.\n      ");
			ul = claim_element(nodes, "UL", {});
			var ul_nodes = children(ul);
			li0 = claim_element(ul_nodes, "LI", {});
			var li0_nodes = children(li0);
			t1 = claim_text(li0_nodes, "This is especially useful for UI library components, as it is\n          generally unknown which events will be required from them for all\n          desired use cases. For example, if a Button component only forwards a ");
			code0 = claim_element(li0_nodes, "CODE", {});
			var code0_nodes = children(code0);
			t2 = claim_text(code0_nodes, "click");
			code0_nodes.forEach(detach_dev);
			t3 = claim_text(li0_nodes, "\n          event, then no use case that requires the ");
			code1 = claim_element(li0_nodes, "CODE", {});
			var code1_nodes = children(code1);
			t4 = claim_text(code1_nodes, "mouseover");
			code1_nodes.forEach(detach_dev);
			t5 = claim_text(li0_nodes, " or\n          the\n          ");
			code2 = claim_element(li0_nodes, "CODE", {});
			var code2_nodes = children(code2);
			t6 = claim_text(code2_nodes, "keypress");
			code2_nodes.forEach(detach_dev);
			t7 = claim_text(li0_nodes, "\n          event can be used with it.");
			li0_nodes.forEach(detach_dev);
			t8 = claim_space(ul_nodes);
			li1 = claim_element(ul_nodes, "LI", {});
			var li1_nodes = children(li1);
			t9 = claim_text(li1_nodes, "In addition, a component that uses Svelte's built in event forwarding\n          system cannot allow event listeners on the \"capture\" phase of the\n          event lifecycle. It also cannot allow events to be cancelable with the\n          browser's built in\n          ");
			code3 = claim_element(li1_nodes, "CODE", {});
			var code3_nodes = children(code3);
			t10 = claim_text(code3_nodes, "preventDefault");
			code3_nodes.forEach(detach_dev);
			t11 = claim_text(li1_nodes, "\n          function. In fact, the one big advantage to Svelte's event system, the\n          fact that you don't need an element as an event target, doesn't even apply\n          to UI library components.");
			li1_nodes.forEach(detach_dev);
			ul_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(code0, file, 120, 80, 4301);
			add_location(code1, file, 123, 52, 4396);
			add_location(code2, file, 125, 10, 4446);
			add_location(li0, file, 117, 8, 4068);
			add_location(code3, file, 133, 10, 4808);
			add_location(li1, file, 128, 8, 4527);
			add_location(ul, file, 116, 6, 4055);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			insert_dev(target, ul, anchor);
			append_dev(ul, li0);
			append_dev(li0, t1);
			append_dev(li0, code0);
			append_dev(code0, t2);
			append_dev(li0, t3);
			append_dev(li0, code1);
			append_dev(code1, t4);
			append_dev(li0, t5);
			append_dev(li0, code2);
			append_dev(code2, t6);
			append_dev(li0, t7);
			append_dev(ul, t8);
			append_dev(ul, li1);
			append_dev(li1, t9);
			append_dev(li1, code3);
			append_dev(code3, t10);
			append_dev(li1, t11);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(ul);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_subtitle_slot_1.name,
		type: "slot",
		source: "(114:4) <svelte:fragment slot=\\\"subtitle\\\">",
		ctx
	});

	return block;
}

// (143:2) <Demo     component={UseActions}     files={[       'common/_UseActions.svelte',       'common/_UseActionsComponent.svelte',       'common/_UseActionsPannable.js',       'common/_UseActionsSwipeable.js',       'common/_UseActionsTappable.js',     ]}   >
function create_default_slot(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Use Actions");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "Use Actions");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(143:2) <Demo     component={UseActions}     files={[       'common/_UseActions.svelte',       'common/_UseActionsComponent.svelte',       'common/_UseActionsPannable.js',       'common/_UseActionsSwipeable.js',       'common/_UseActionsTappable.js',     ]}   >",
		ctx
	});

	return block;
}

// (154:4) <svelte:fragment slot="subtitle">
function create_subtitle_slot(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("An action that takes actions and runs them on the element. Used to allow\n      actions on components, and forward actions from one component to another,\n      until the ultimate component finally renders the DOM element.");
		},
		l: function claim(nodes) {
			t = claim_text(nodes, "An action that takes actions and runs them on the element. Used to allow\n      actions on components, and forward actions from one component to another,\n      until the ultimate component finally renders the DOM element.");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_subtitle_slot.name,
		type: "slot",
		source: "(154:4) <svelte:fragment slot=\\\"subtitle\\\">",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let t0;
	let section;
	let h2;
	let t1;
	let t2;
	let p;
	let t3;
	let t4;
	let pre;
	let t5;
	let t6;
	let demo0;
	let t7;
	let h40;
	let t8;
	let t9;
	let demo1;
	let t10;
	let demo2;
	let t11;
	let demo3;
	let t12;
	let h41;
	let t13;
	let t14;
	let demo4;
	let t15;
	let demo5;
	let t16;
	let demo6;
	let t17;
	let demo7;
	let t18;
	let demo8;
	let t19;
	let demo9;
	let current;

	demo0 = new Demo({
			props: {
				component: CommonLabelIcon,
				file: "common/_CommonLabelIcon.svelte",
				$$slots: {
					subtitle: [create_subtitle_slot_9],
					default: [create_default_slot_9]
				},
				$$scope: { ctx }
			},
			$$inline: true
		});

	demo1 = new Demo({
			props: {
				component: TargetingClasses,
				file: "common/_TargetingClasses.svelte",
				$$slots: {
					subtitle: [create_subtitle_slot_8],
					default: [create_default_slot_8]
				},
				$$scope: { ctx }
			},
			$$inline: true
		});

	demo2 = new Demo({
			props: {
				component: EventsAndModifiers,
				file: "common/_EventsAndModifiers.svelte",
				$$slots: {
					subtitle: [create_subtitle_slot_7],
					default: [create_default_slot_7]
				},
				$$scope: { ctx }
			},
			$$inline: true
		});

	demo3 = new Demo({
			props: {
				component: ElementalComponents,
				file: "common/_ElementalComponents.svelte",
				$$slots: {
					subtitle: [create_subtitle_slot_6],
					default: [create_default_slot_6]
				},
				$$scope: { ctx }
			},
			$$inline: true
		});

	demo4 = new Demo({
			props: {
				component: ClassAdderBuilder,
				files: [
					"common/_ClassAdderBuilder.svelte",
					"common/_ClassAdderBuilderComponent.js"
				],
				$$slots: {
					subtitle: [create_subtitle_slot_5],
					default: [create_default_slot_5]
				},
				$$scope: { ctx }
			},
			$$inline: true
		});

	demo5 = new Demo({
			props: {
				component: ClassMap,
				file: "common/_ClassMap.svelte",
				$$slots: {
					subtitle: [create_subtitle_slot_4],
					default: [create_default_slot_4]
				},
				$$scope: { ctx }
			},
			$$inline: true
		});

	demo6 = new Demo({
			props: {
				component: Dispatch,
				file: "common/_Dispatch.svelte",
				$$slots: {
					subtitle: [create_subtitle_slot_3],
					default: [create_default_slot_3]
				},
				$$scope: { ctx }
			},
			$$inline: true
		});

	demo7 = new Demo({
			props: {
				component: ExcludeAndPrefixFilter,
				files: [
					"common/_ExcludeAndPrefixFilter.svelte",
					"common/_ExcludeAndPrefixFilterComponent.svelte"
				],
				$$slots: {
					subtitle: [create_subtitle_slot_2],
					default: [create_default_slot_2]
				},
				$$scope: { ctx }
			},
			$$inline: true
		});

	demo8 = new Demo({
			props: {
				component: ForwardEventsBuilder,
				files: [
					"common/_ForwardEventsBuilder.svelte",
					"common/_ForwardEventsBuilderComponent.svelte"
				],
				$$slots: {
					subtitle: [create_subtitle_slot_1],
					default: [create_default_slot_1]
				},
				$$scope: { ctx }
			},
			$$inline: true
		});

	demo9 = new Demo({
			props: {
				component: UseActions,
				files: [
					"common/_UseActions.svelte",
					"common/_UseActionsComponent.svelte",
					"common/_UseActionsPannable.js",
					"common/_UseActionsSwipeable.js",
					"common/_UseActionsTappable.js"
				],
				$$slots: {
					subtitle: [create_subtitle_slot],
					default: [create_default_slot]
				},
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			t0 = space();
			section = element("section");
			h2 = element("h2");
			t1 = text("Common");
			t2 = space();
			p = element("p");
			t3 = text("A common Label and Icon, helper utilities, and elemental components.");
			t4 = space();
			pre = element("pre");
			t5 = text("npm i -D @smui/common");
			t6 = space();
			create_component(demo0.$$.fragment);
			t7 = space();
			h40 = element("h4");
			t8 = text("Common Features and Use Patterns");
			t9 = space();
			create_component(demo1.$$.fragment);
			t10 = space();
			create_component(demo2.$$.fragment);
			t11 = space();
			create_component(demo3.$$.fragment);
			t12 = space();
			h41 = element("h4");
			t13 = text("Helper Utilities");
			t14 = space();
			create_component(demo4.$$.fragment);
			t15 = space();
			create_component(demo5.$$.fragment);
			t16 = space();
			create_component(demo6.$$.fragment);
			t17 = space();
			create_component(demo7.$$.fragment);
			t18 = space();
			create_component(demo8.$$.fragment);
			t19 = space();
			create_component(demo9.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			const head_nodes = query_selector_all("[data-svelte=\"svelte-10avws1\"]", document.head);
			head_nodes.forEach(detach_dev);
			t0 = claim_space(nodes);
			section = claim_element(nodes, "SECTION", {});
			var section_nodes = children(section);
			h2 = claim_element(section_nodes, "H2", {});
			var h2_nodes = children(h2);
			t1 = claim_text(h2_nodes, "Common");
			h2_nodes.forEach(detach_dev);
			t2 = claim_space(section_nodes);
			p = claim_element(section_nodes, "P", {});
			var p_nodes = children(p);
			t3 = claim_text(p_nodes, "A common Label and Icon, helper utilities, and elemental components.");
			p_nodes.forEach(detach_dev);
			t4 = claim_space(section_nodes);
			pre = claim_element(section_nodes, "PRE", { class: true });
			var pre_nodes = children(pre);
			t5 = claim_text(pre_nodes, "npm i -D @smui/common");
			pre_nodes.forEach(detach_dev);
			t6 = claim_space(section_nodes);
			claim_component(demo0.$$.fragment, section_nodes);
			t7 = claim_space(section_nodes);
			h40 = claim_element(section_nodes, "H4", {});
			var h40_nodes = children(h40);
			t8 = claim_text(h40_nodes, "Common Features and Use Patterns");
			h40_nodes.forEach(detach_dev);
			t9 = claim_space(section_nodes);
			claim_component(demo1.$$.fragment, section_nodes);
			t10 = claim_space(section_nodes);
			claim_component(demo2.$$.fragment, section_nodes);
			t11 = claim_space(section_nodes);
			claim_component(demo3.$$.fragment, section_nodes);
			t12 = claim_space(section_nodes);
			h41 = claim_element(section_nodes, "H4", {});
			var h41_nodes = children(h41);
			t13 = claim_text(h41_nodes, "Helper Utilities");
			h41_nodes.forEach(detach_dev);
			t14 = claim_space(section_nodes);
			claim_component(demo4.$$.fragment, section_nodes);
			t15 = claim_space(section_nodes);
			claim_component(demo5.$$.fragment, section_nodes);
			t16 = claim_space(section_nodes);
			claim_component(demo6.$$.fragment, section_nodes);
			t17 = claim_space(section_nodes);
			claim_component(demo7.$$.fragment, section_nodes);
			t18 = claim_space(section_nodes);
			claim_component(demo8.$$.fragment, section_nodes);
			t19 = claim_space(section_nodes);
			claim_component(demo9.$$.fragment, section_nodes);
			section_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			document.title = "Common - SMUI";
			add_location(h2, file, 5, 2, 73);
			add_location(p, file, 6, 2, 91);
			attr_dev(pre, "class", "demo-spaced");
			add_location(pre, file, 8, 2, 170);
			add_location(h40, file, 18, 2, 489);
			add_location(h41, file, 47, 2, 1428);
			add_location(section, file, 4, 0, 61);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			insert_dev(target, section, anchor);
			append_dev(section, h2);
			append_dev(h2, t1);
			append_dev(section, t2);
			append_dev(section, p);
			append_dev(p, t3);
			append_dev(section, t4);
			append_dev(section, pre);
			append_dev(pre, t5);
			append_dev(section, t6);
			mount_component(demo0, section, null);
			append_dev(section, t7);
			append_dev(section, h40);
			append_dev(h40, t8);
			append_dev(section, t9);
			mount_component(demo1, section, null);
			append_dev(section, t10);
			mount_component(demo2, section, null);
			append_dev(section, t11);
			mount_component(demo3, section, null);
			append_dev(section, t12);
			append_dev(section, h41);
			append_dev(h41, t13);
			append_dev(section, t14);
			mount_component(demo4, section, null);
			append_dev(section, t15);
			mount_component(demo5, section, null);
			append_dev(section, t16);
			mount_component(demo6, section, null);
			append_dev(section, t17);
			mount_component(demo7, section, null);
			append_dev(section, t18);
			mount_component(demo8, section, null);
			append_dev(section, t19);
			mount_component(demo9, section, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const demo0_changes = {};

			if (dirty & /*$$scope*/ 1) {
				demo0_changes.$$scope = { dirty, ctx };
			}

			demo0.$set(demo0_changes);
			const demo1_changes = {};

			if (dirty & /*$$scope*/ 1) {
				demo1_changes.$$scope = { dirty, ctx };
			}

			demo1.$set(demo1_changes);
			const demo2_changes = {};

			if (dirty & /*$$scope*/ 1) {
				demo2_changes.$$scope = { dirty, ctx };
			}

			demo2.$set(demo2_changes);
			const demo3_changes = {};

			if (dirty & /*$$scope*/ 1) {
				demo3_changes.$$scope = { dirty, ctx };
			}

			demo3.$set(demo3_changes);
			const demo4_changes = {};

			if (dirty & /*$$scope*/ 1) {
				demo4_changes.$$scope = { dirty, ctx };
			}

			demo4.$set(demo4_changes);
			const demo5_changes = {};

			if (dirty & /*$$scope*/ 1) {
				demo5_changes.$$scope = { dirty, ctx };
			}

			demo5.$set(demo5_changes);
			const demo6_changes = {};

			if (dirty & /*$$scope*/ 1) {
				demo6_changes.$$scope = { dirty, ctx };
			}

			demo6.$set(demo6_changes);
			const demo7_changes = {};

			if (dirty & /*$$scope*/ 1) {
				demo7_changes.$$scope = { dirty, ctx };
			}

			demo7.$set(demo7_changes);
			const demo8_changes = {};

			if (dirty & /*$$scope*/ 1) {
				demo8_changes.$$scope = { dirty, ctx };
			}

			demo8.$set(demo8_changes);
			const demo9_changes = {};

			if (dirty & /*$$scope*/ 1) {
				demo9_changes.$$scope = { dirty, ctx };
			}

			demo9.$set(demo9_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(demo0.$$.fragment, local);
			transition_in(demo1.$$.fragment, local);
			transition_in(demo2.$$.fragment, local);
			transition_in(demo3.$$.fragment, local);
			transition_in(demo4.$$.fragment, local);
			transition_in(demo5.$$.fragment, local);
			transition_in(demo6.$$.fragment, local);
			transition_in(demo7.$$.fragment, local);
			transition_in(demo8.$$.fragment, local);
			transition_in(demo9.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(demo0.$$.fragment, local);
			transition_out(demo1.$$.fragment, local);
			transition_out(demo2.$$.fragment, local);
			transition_out(demo3.$$.fragment, local);
			transition_out(demo4.$$.fragment, local);
			transition_out(demo5.$$.fragment, local);
			transition_out(demo6.$$.fragment, local);
			transition_out(demo7.$$.fragment, local);
			transition_out(demo8.$$.fragment, local);
			transition_out(demo9.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(section);
			destroy_component(demo0);
			destroy_component(demo1);
			destroy_component(demo2);
			destroy_component(demo3);
			destroy_component(demo4);
			destroy_component(demo5);
			destroy_component(demo6);
			destroy_component(demo7);
			destroy_component(demo8);
			destroy_component(demo9);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Common", slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Common> was created with unknown prop '${key}'`);
	});

	$$self.$capture_state = () => ({
		Demo,
		CommonLabelIcon,
		TargetingClasses,
		EventsAndModifiers,
		ElementalComponents,
		ClassAdderBuilder,
		ClassMap,
		Dispatch,
		ExcludeAndPrefixFilter,
		ForwardEventsBuilder,
		UseActions
	});

	return [];
}

class Common extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Common",
			options,
			id: create_fragment.name
		});
	}
}

export default Common;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguNGVkNjMyNGYuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3BhY2thZ2VzL2NvbW1vbi9DbGFzc0FkZGVyLnN2ZWx0ZSIsIi4uLy4uLy4uL3BhY2thZ2VzL2NvbW1vbi9jbGFzc0FkZGVyQnVpbGRlci5qcyIsIi4uLy4uLy4uL3BhY2thZ2VzL2NvbW1vbi9kaXNwYXRjaC5qcyIsIi4uLy4uLy4uL3BhY2thZ2VzL2NvbW1vbi9leGNsdWRlLmpzIiwiLi4vLi4vLi4vcGFja2FnZXMvY29tbW9uL3ByZWZpeEZpbHRlci5qcyIsIi4uLy4uLy4uL3NyYy9yb3V0ZXMvZGVtby9jb21tb24vX0V2ZW50c0FuZE1vZGlmaWVycy5zdmVsdGUiLCIuLi8uLi8uLi9wYWNrYWdlcy9jb21tb24vU3Ryb25nLnN2ZWx0ZSIsIi4uLy4uLy4uL3BhY2thZ2VzL2NvbW1vbi9FbS5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvcm91dGVzL2RlbW8vY29tbW9uL19FbGVtZW50YWxDb21wb25lbnRzLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9yb3V0ZXMvZGVtby9jb21tb24vX0NsYXNzQWRkZXJCdWlsZGVyQ29tcG9uZW50LmpzIiwiLi4vLi4vLi4vc3JjL3JvdXRlcy9kZW1vL2NvbW1vbi9fQ2xhc3NNYXAuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL3JvdXRlcy9kZW1vL2NvbW1vbi9fRGlzcGF0Y2guc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL3JvdXRlcy9kZW1vL2NvbW1vbi9fRXhjbHVkZUFuZFByZWZpeEZpbHRlckNvbXBvbmVudC5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvcm91dGVzL2RlbW8vY29tbW9uL19FeGNsdWRlQW5kUHJlZml4RmlsdGVyLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9yb3V0ZXMvZGVtby9jb21tb24vX0ZvcndhcmRFdmVudHNCdWlsZGVyQ29tcG9uZW50LnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9yb3V0ZXMvZGVtby9jb21tb24vX0ZvcndhcmRFdmVudHNCdWlsZGVyLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9yb3V0ZXMvZGVtby9jb21tb24vX1VzZUFjdGlvbnNDb21wb25lbnQuc3ZlbHRlIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3RpbnlnZXN0dXJlL1RpbnlHZXN0dXJlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9lYXNpbmcvaW5kZXgubWpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9tb3Rpb24vaW5kZXgubWpzIiwiLi4vLi4vLi4vc3JjL3JvdXRlcy9kZW1vL2NvbW1vbi9fVXNlQWN0aW9uc1Bhbm5hYmxlLmpzIiwiLi4vLi4vLi4vc3JjL3JvdXRlcy9kZW1vL2NvbW1vbi9fVXNlQWN0aW9uc1N3aXBlYWJsZS5qcyIsIi4uLy4uLy4uL3NyYy9yb3V0ZXMvZGVtby9jb21tb24vX1VzZUFjdGlvbnNUYXBwYWJsZS5qcyIsIi4uLy4uLy4uL3NyYy9yb3V0ZXMvZGVtby9jb21tb24vX1VzZUFjdGlvbnMuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL3JvdXRlcy9kZW1vL2NvbW1vbi9pbmRleC5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPHN2ZWx0ZTpjb21wb25lbnRcbiAgdGhpcz17Y29tcG9uZW50fVxuICBiaW5kOnRoaXM9e2VsZW1lbnR9XG4gIHVzZT17W2ZvcndhcmRFdmVudHMsIC4uLnVzZV19XG4gIGNsYXNzPXtjbGFzc01hcCh7XG4gICAgW2NsYXNzTmFtZV06IHRydWUsXG4gICAgW3NtdWlDbGFzc106IHRydWUsXG4gICAgLi4uc211aUNsYXNzTWFwLFxuICB9KX1cbiAgey4uLnByb3BzfVxuICB7Li4uJCRyZXN0UHJvcHN9PjxzbG90IC8+PC9zdmVsdGU6Y29tcG9uZW50XG4+XG5cbjxzY3JpcHQgY29udGV4dD1cIm1vZHVsZVwiPlxuICBleHBvcnQgY29uc3QgaW50ZXJuYWxzID0ge1xuICAgIGNvbXBvbmVudDogbnVsbCxcbiAgICBjbGFzczogJycsXG4gICAgLy8gVGhlIGNsYXNzIG1hcCBtYXBzIGNsYXNzZXMgdG8gY29udGV4dHMuIFRoZSBjb250ZXh0XG4gICAgLy8gc2hvdWxkIHJlc29sdmUgdG8gYSBTdmVsdGUgc3RvcmUsIGFuZCB0aGUgY2xhc3NcbiAgICAvLyB3aWxsIGJlIGFkZGVkIGlmIHRoZSBTdmVsdGUgc3RvcmUncyB2YWx1ZSBpcyB0cnVlLlxuICAgIGNsYXNzTWFwOiB7fSxcbiAgICBjb250ZXh0czoge30sXG4gICAgcHJvcHM6IHt9LFxuICB9O1xuPC9zY3JpcHQ+XG5cbjxzY3JpcHQ+XG4gIGltcG9ydCB7IG9uRGVzdHJveSwgZ2V0Q29udGV4dCwgc2V0Q29udGV4dCB9IGZyb20gJ3N2ZWx0ZSc7XG4gIGltcG9ydCB7IGdldF9jdXJyZW50X2NvbXBvbmVudCB9IGZyb20gJ3N2ZWx0ZS9pbnRlcm5hbCc7XG4gIGltcG9ydCB7IGZvcndhcmRFdmVudHNCdWlsZGVyIH0gZnJvbSAnLi9mb3J3YXJkRXZlbnRzQnVpbGRlci5qcyc7XG4gIGltcG9ydCB7IGNsYXNzTWFwIH0gZnJvbSAnLi9jbGFzc01hcC5qcyc7XG5cbiAgZXhwb3J0IGxldCB1c2UgPSBbXTtcbiAgbGV0IGNsYXNzTmFtZSA9ICcnO1xuICBleHBvcnQgeyBjbGFzc05hbWUgYXMgY2xhc3MgfTtcblxuICBsZXQgZWxlbWVudDtcbiAgY29uc3Qgc211aUNsYXNzID0gaW50ZXJuYWxzLmNsYXNzO1xuICBjb25zdCBzbXVpQ2xhc3NNYXAgPSB7fTtcbiAgY29uc3Qgc211aUNsYXNzVW5zdWJzY3JpYmVzID0gW107XG4gIGNvbnN0IGNvbnRleHRzID0gaW50ZXJuYWxzLmNvbnRleHRzO1xuICBjb25zdCBwcm9wcyA9IGludGVybmFscy5wcm9wcztcblxuICBleHBvcnQgbGV0IGNvbXBvbmVudCA9IGludGVybmFscy5jb21wb25lbnQ7XG5cbiAgT2JqZWN0LmVudHJpZXMoaW50ZXJuYWxzLmNsYXNzTWFwKS5mb3JFYWNoKChbbmFtZSwgY29udGV4dF0pID0+IHtcbiAgICBjb25zdCBzdG9yZSA9IGdldENvbnRleHQoY29udGV4dCk7XG5cbiAgICBpZiAoc3RvcmUgJiYgJ3N1YnNjcmliZScgaW4gc3RvcmUpIHtcbiAgICAgIHNtdWlDbGFzc1Vuc3Vic2NyaWJlcy5wdXNoKFxuICAgICAgICBzdG9yZS5zdWJzY3JpYmUoKHZhbHVlKSA9PiB7XG4gICAgICAgICAgc211aUNsYXNzTWFwW25hbWVdID0gdmFsdWU7XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cbiAgfSk7XG5cbiAgY29uc3QgZm9yd2FyZEV2ZW50cyA9IGZvcndhcmRFdmVudHNCdWlsZGVyKGdldF9jdXJyZW50X2NvbXBvbmVudCgpKTtcblxuICBmb3IgKGxldCBjb250ZXh0IGluIGNvbnRleHRzKSB7XG4gICAgaWYgKGNvbnRleHRzLmhhc093blByb3BlcnR5KGNvbnRleHQpKSB7XG4gICAgICBzZXRDb250ZXh0KGNvbnRleHQsIGNvbnRleHRzW2NvbnRleHRdKTtcbiAgICB9XG4gIH1cblxuICBvbkRlc3Ryb3koKCkgPT4ge1xuICAgIGZvciAoY29uc3QgdW5zdWJzY3JpYmUgb2Ygc211aUNsYXNzVW5zdWJzY3JpYmVzKSB7XG4gICAgICB1bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgfSk7XG5cbiAgZXhwb3J0IGZ1bmN0aW9uIGdldEVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQuZ2V0RWxlbWVudCgpO1xuICB9XG48L3NjcmlwdD5cbiIsImltcG9ydCBDbGFzc0FkZGVyLCB7IGludGVybmFscyB9IGZyb20gJy4vQ2xhc3NBZGRlci5zdmVsdGUnO1xuXG5jb25zdCBkZWZhdWx0cyA9IHsgLi4uaW50ZXJuYWxzIH07XG5cbmV4cG9ydCBmdW5jdGlvbiBjbGFzc0FkZGVyQnVpbGRlcihwcm9wcykge1xuICBmdW5jdGlvbiBDb21wb25lbnQoLi4uYXJncykge1xuICAgIE9iamVjdC5hc3NpZ24oaW50ZXJuYWxzLCBkZWZhdWx0cywgcHJvcHMpO1xuICAgIHJldHVybiBuZXcgQ2xhc3NBZGRlciguLi5hcmdzKTtcbiAgfVxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUgPSBDbGFzc0FkZGVyO1xuXG4gIC8vIFNTUiBzdXBwb3J0XG4gIGlmIChDbGFzc0FkZGVyLiQkcmVuZGVyKSB7XG4gICAgQ29tcG9uZW50LiQkcmVuZGVyID0gKC4uLmFyZ3MpID0+XG4gICAgICBPYmplY3QuYXNzaWduKGludGVybmFscywgZGVmYXVsdHMsIHByb3BzKSAmJiBDbGFzc0FkZGVyLiQkcmVuZGVyKC4uLmFyZ3MpO1xuICB9XG4gIGlmIChDbGFzc0FkZGVyLnJlbmRlcikge1xuICAgIENvbXBvbmVudC5yZW5kZXIgPSAoLi4uYXJncykgPT5cbiAgICAgIE9iamVjdC5hc3NpZ24oaW50ZXJuYWxzLCBkZWZhdWx0cywgcHJvcHMpICYmIENsYXNzQWRkZXIucmVuZGVyKC4uLmFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIENvbXBvbmVudDtcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiBkaXNwYXRjaChcbiAgZWxlbWVudCxcbiAgZXZlbnRUeXBlLFxuICBkZXRhaWwgPSB7fSxcbiAgZXZlbnRJbml0ID0geyBidWJibGVzOiB0cnVlIH1cbikge1xuICBpZiAodHlwZW9mIEV2ZW50ICE9PSAndW5kZWZpbmVkJyAmJiBlbGVtZW50KSB7XG4gICAgY29uc3QgZXZlbnQgPSBuZXcgRXZlbnQoZXZlbnRUeXBlLCBldmVudEluaXQpO1xuICAgIGV2ZW50LmRldGFpbCA9IGRldGFpbDtcbiAgICBjb25zdCBlbCA9ICdnZXRFbGVtZW50JyBpbiBlbGVtZW50ID8gZWxlbWVudC5nZXRFbGVtZW50KCkgOiBlbGVtZW50O1xuICAgIGVsLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgIHJldHVybiBldmVudDtcbiAgfVxufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIGV4Y2x1ZGUob2JqLCBrZXlzKSB7XG4gIGxldCBuYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaik7XG4gIGNvbnN0IG5ld09iaiA9IHt9O1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBuYW1lID0gbmFtZXNbaV07XG4gICAgY29uc3QgY2FzaEluZGV4ID0gbmFtZS5pbmRleE9mKCckJyk7XG4gICAgaWYgKFxuICAgICAgY2FzaEluZGV4ICE9PSAtMSAmJlxuICAgICAga2V5cy5pbmRleE9mKG5hbWUuc3Vic3RyaW5nKDAsIGNhc2hJbmRleCArIDEpKSAhPT0gLTFcbiAgICApIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoa2V5cy5pbmRleE9mKG5hbWUpICE9PSAtMSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIG5ld09ialtuYW1lXSA9IG9ialtuYW1lXTtcbiAgfVxuXG4gIHJldHVybiBuZXdPYmo7XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gcHJlZml4RmlsdGVyKG9iaiwgcHJlZml4KSB7XG4gIGxldCBuYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaik7XG4gIGNvbnN0IG5ld09iaiA9IHt9O1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBuYW1lID0gbmFtZXNbaV07XG4gICAgaWYgKG5hbWUuc3Vic3RyaW5nKDAsIHByZWZpeC5sZW5ndGgpID09PSBwcmVmaXgpIHtcbiAgICAgIG5ld09ialtuYW1lLnN1YnN0cmluZyhwcmVmaXgubGVuZ3RoKV0gPSBvYmpbbmFtZV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ld09iajtcbn1cbiIsIjxkaXY+XG4gIDxCdXR0b25cbiAgICBvbjpjbGljaz17YWRkRXZlbnR9XG4gICAgb246bW91c2Vkb3duPXthZGRFdmVudH1cbiAgICBvbjptb3VzZXVwPXthZGRFdmVudH1cbiAgICBvbjptb3VzZW92ZXI9e2FkZEV2ZW50fVxuICAgIG9uOm1vdXNlb3V0PXthZGRFdmVudH1cbiAgICBvbjprZXlwcmVzcz17YWRkRXZlbnR9XG4gICAgb246a2V5ZG93bj17YWRkRXZlbnR9XG4gICAgb246a2V5dXA9e2FkZEV2ZW50fVxuICAgIG9uOmZvY3VzPXthZGRFdmVudH1cbiAgICBvbjpibHVyPXthZGRFdmVudH1cbiAgICBvbjphbmltYXRpb25zdGFydD17YWRkRXZlbnR9XG4gICAgb246YW5pbWF0aW9uZW5kPXthZGRFdmVudH1cbiAgPlxuICAgIDxMYWJlbD5UaGlzIEJ1dHRvbiBoYXMgRXZlbnQgTGlzdGVuZXJzPC9MYWJlbD5cbiAgPC9CdXR0b24+XG48L2Rpdj5cblxuPGRpdiBjbGFzcz1cImV2ZW50LW91dHB1dFwiIGJpbmQ6dGhpcz17ZXZlbnRPdXRwdXR9PlxuICB7I2VhY2ggZXZlbnRzIGFzIGV2ZW50fVxuICAgIDxwPkNhdWdodCB7ZXZlbnQudHlwZX08L3A+XG4gIHs6ZWxzZX1cbiAgICA8cD5ObyBldmVudHMgeWV0LjwvcD5cbiAgey9lYWNofVxuPC9kaXY+XG5cbjxkaXY+XG4gIFRyeSBjbGlja2luZyBhbmQgdXNpbmcgdGhlIEVudGVyIGtleSB0byBhY3RpdmF0ZSB0aGlzIG5leHQgYnV0dG9uLiAoVGhlIGNsaWNrXG4gIGV2ZW50J3MgdGFyZ2V0IGlzIGFuIGVsZW1lbnQgYmVsb3cgdGhlIGJ1dHRvbiB3aGlsZSB0aGUga2V5IGV2ZW50J3MgdGFyZ2V0IGlzXG4gIHRoZSBidXR0b24uKVxuPC9kaXY+XG5cbjxkaXY+XG4gIDxCdXR0b24gb246Y2xpY2skY2FwdHVyZT17YWRkRXZlbnRQaGFzZX0gb246Y2xpY2s9e2FkZEV2ZW50UGhhc2V9PlxuICAgIDxMYWJlbD5DYXB0dXJlIGFuZCBCdWJibGUgUGhhc2UgTGlzdGVuZXJzPC9MYWJlbD5cbiAgPC9CdXR0b24+XG48L2Rpdj5cblxuPGRpdiBjbGFzcz1cImV2ZW50LW91dHB1dFwiIGJpbmQ6dGhpcz17ZXZlbnRQaGFzZU91dHB1dH0+XG4gIHsjZWFjaCBldmVudFBoYXNlcyBhcyBldmVudH1cbiAgICA8cD5DYXVnaHQge2V2ZW50WzBdLnR5cGV9IGluIHtldmVudFsxXX0gcGhhc2U8L3A+XG4gIHs6ZWxzZX1cbiAgICA8cD5ObyBldmVudHMgeWV0LjwvcD5cbiAgey9lYWNofVxuPC9kaXY+XG5cbjxkaXY+XG4gIDxBXG4gICAgaHJlZj1cImh0dHA6Ly9leGFtcGxlLmNvbVwiXG4gICAgb246Y2xpY2skcHJldmVudERlZmF1bHQ9eygpID0+XG4gICAgICBjb25zb2xlLmxvZyhcIllvdSB0cmllZCB0byBnbywgYnV0IGRpZG4ndCBtYWtlIGl0LlwiKX1cbiAgPlxuICAgIEEgTGluaywgd2l0aCBEZWZhdWx0IFByZXZlbnRlZFxuICA8L0E+XG48L2Rpdj5cblxuPHNjcmlwdD5cbiAgaW1wb3J0IEJ1dHRvbiwgeyBMYWJlbCB9IGZyb20gJ0BzbXVpL2J1dHRvbic7XG4gIGltcG9ydCBBIGZyb20gJ0BzbXVpL2NvbW1vbi9BLnN2ZWx0ZSc7XG5cbiAgbGV0IGV2ZW50T3V0cHV0O1xuICBsZXQgZXZlbnRQaGFzZU91dHB1dDtcbiAgbGV0IGV2ZW50cyA9IFtdO1xuICBsZXQgZXZlbnRQaGFzZXMgPSBbXTtcblxuICBmdW5jdGlvbiBhZGRFdmVudChldmVudCkge1xuICAgIGV2ZW50cy5wdXNoKGV2ZW50KTtcbiAgICBldmVudHMgPSBldmVudHM7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIGV2ZW50T3V0cHV0LnNjcm9sbFRvcCA9IGV2ZW50T3V0cHV0LnNjcm9sbEhlaWdodDtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZEV2ZW50UGhhc2UoZXZlbnQpIHtcbiAgICBjb25zdCBwaGFzZXMgPSBbJ25vbmUnLCAnY2FwdHVyaW5nJywgJ2F0LXRhcmdldCcsICdidWJibGluZyddO1xuICAgIGV2ZW50UGhhc2VzLnB1c2goW2V2ZW50LCBwaGFzZXNbZXZlbnQuZXZlbnRQaGFzZV1dKTtcbiAgICBldmVudFBoYXNlcyA9IGV2ZW50UGhhc2VzO1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICBldmVudFBoYXNlT3V0cHV0LnNjcm9sbFRvcCA9IGV2ZW50UGhhc2VPdXRwdXQuc2Nyb2xsSGVpZ2h0O1xuICAgIH0pO1xuICB9XG48L3NjcmlwdD5cblxuPHN0eWxlPlxuICAuZXZlbnQtb3V0cHV0IHtcbiAgICBmb250LWZhbWlseTogJ1JvYm90byBNb25vJywgbW9ub3NwYWNlICFpbXBvcnRhbnQ7XG4gICAgaGVpZ2h0OiAyMDBweDtcbiAgICBvdmVyZmxvdzogYXV0bztcbiAgfVxuPC9zdHlsZT5cbiIsIjxzdHJvbmdcbiAgYmluZDp0aGlzPXtlbGVtZW50fVxuICB1c2U6dXNlQWN0aW9ucz17dXNlfVxuICB1c2U6Zm9yd2FyZEV2ZW50c1xuICB7Li4uJCRyZXN0UHJvcHN9PjxzbG90IC8+PC9zdHJvbmdcbj5cblxuPHNjcmlwdD5cbiAgaW1wb3J0IHsgZ2V0X2N1cnJlbnRfY29tcG9uZW50IH0gZnJvbSAnc3ZlbHRlL2ludGVybmFsJztcbiAgaW1wb3J0IHsgZm9yd2FyZEV2ZW50c0J1aWxkZXIsIHVzZUFjdGlvbnMgfSBmcm9tICcuL2ludGVybmFsLmpzJztcblxuICBleHBvcnQgbGV0IHVzZSA9IFtdO1xuXG4gIGNvbnN0IGZvcndhcmRFdmVudHMgPSBmb3J3YXJkRXZlbnRzQnVpbGRlcihnZXRfY3VycmVudF9jb21wb25lbnQoKSk7XG5cbiAgbGV0IGVsZW1lbnQgPSBudWxsO1xuXG4gIGV4cG9ydCBmdW5jdGlvbiBnZXRFbGVtZW50KCkge1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG48L3NjcmlwdD5cbiIsIjxlbSBiaW5kOnRoaXM9e2VsZW1lbnR9IHVzZTp1c2VBY3Rpb25zPXt1c2V9IHVzZTpmb3J3YXJkRXZlbnRzIHsuLi4kJHJlc3RQcm9wc31cbiAgPjxzbG90IC8+PC9lbVxuPlxuXG48c2NyaXB0PlxuICBpbXBvcnQgeyBnZXRfY3VycmVudF9jb21wb25lbnQgfSBmcm9tICdzdmVsdGUvaW50ZXJuYWwnO1xuICBpbXBvcnQgeyBmb3J3YXJkRXZlbnRzQnVpbGRlciwgdXNlQWN0aW9ucyB9IGZyb20gJy4vaW50ZXJuYWwuanMnO1xuXG4gIGV4cG9ydCBsZXQgdXNlID0gW107XG5cbiAgY29uc3QgZm9yd2FyZEV2ZW50cyA9IGZvcndhcmRFdmVudHNCdWlsZGVyKGdldF9jdXJyZW50X2NvbXBvbmVudCgpKTtcblxuICBsZXQgZWxlbWVudCA9IG51bGw7XG5cbiAgZXhwb3J0IGZ1bmN0aW9uIGdldEVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbjwvc2NyaXB0PlxuIiwiPCEtLVxuICBOb3RlOiBub3QgYWxsIFNNVUkgY29tcG9uZW50cyBjYW4gdGFrZSBhIGBjb21wb25lbnRgIHByb3AuXG4tLT5cbjxkaXY+XG4gIDxCdXR0b24gY29tcG9uZW50PXtEaXZ9PjxMYWJlbD5JJ20gYSAmbHQ7ZGl2IC8mZ3Q7IEJ1dHRvbjwvTGFiZWw+PC9CdXR0b24+XG4gIDxCdXR0b24gY29tcG9uZW50PXtTcGFufT48TGFiZWw+SSdtIGEgJmx0O3NwYW4gLyZndDsgQnV0dG9uPC9MYWJlbD48L0J1dHRvbj5cbiAgPEJ1dHRvbiBjb21wb25lbnQ9e1N0cm9uZ31cbiAgICA+PExhYmVsPkknbSBhICZsdDtzdHJvbmcgLyZndDsgQnV0dG9uPC9MYWJlbD48L0J1dHRvblxuICA+XG4gIDxCdXR0b24gY29tcG9uZW50PXtFbX0+PExhYmVsPkknbSBhICZsdDtlbSAvJmd0OyBCdXR0b248L0xhYmVsPjwvQnV0dG9uPlxuPC9kaXY+XG5cbjxzY3JpcHQ+XG4gIGltcG9ydCBEaXYgZnJvbSAnQHNtdWkvY29tbW9uL0Rpdi5zdmVsdGUnO1xuICBpbXBvcnQgU3BhbiBmcm9tICdAc211aS9jb21tb24vU3Bhbi5zdmVsdGUnO1xuICBpbXBvcnQgU3Ryb25nIGZyb20gJ0BzbXVpL2NvbW1vbi9TdHJvbmcuc3ZlbHRlJztcbiAgaW1wb3J0IEVtIGZyb20gJ0BzbXVpL2NvbW1vbi9FbS5zdmVsdGUnO1xuICBpbXBvcnQgQnV0dG9uLCB7IExhYmVsIH0gZnJvbSAnQHNtdWkvYnV0dG9uJztcbjwvc2NyaXB0PlxuIiwiaW1wb3J0IHsgY2xhc3NBZGRlckJ1aWxkZXIgfSBmcm9tICdAc211aS9jb21tb24vaW50ZXJuYWwuanMnO1xuaW1wb3J0IERpdiBmcm9tICdAc211aS9jb21tb24vRGl2LnN2ZWx0ZSc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzQWRkZXJCdWlsZGVyKHtcbiAgY2xhc3M6ICdteS1hZGRlZC1jbGFzcycsXG4gIGNvbXBvbmVudDogRGl2LFxufSk7XG4iLCI8ZGl2PlxuICA8QnV0dG9uXG4gICAgY2xhc3M9e2NsYXNzTWFwKHtcbiAgICAgICdteS1idXR0b24nOiB0cnVlLFxuICAgICAgYmlnOiBiaWcsXG4gICAgICBbY29sb3JdOiB0cnVlLFxuICAgIH0pfVxuICA+XG4gICAgPExhYmVsPkknbSBhIENvbG9yZWQgQnV0dG9uPC9MYWJlbD5cbiAgPC9CdXR0b24+XG48L2Rpdj5cblxuPGRpdj5cbiAgPEZvcm1GaWVsZCBzdHlsZT1cIm1hcmdpbi1yaWdodDogMWVtO1wiPlxuICAgIDxDaGVja2JveCBiaW5kOmNoZWNrZWQ9e2JpZ30gLz5cbiAgICA8c3BhbiBzbG90PVwibGFiZWxcIj5CaWc8L3NwYW4+XG4gIDwvRm9ybUZpZWxkPlxuICB7I2VhY2ggWydyZWQnLCAnYmx1ZScsICdncmVlbiddIGFzIG9wdGlvbn1cbiAgICA8Rm9ybUZpZWxkIHN0eWxlPVwibWFyZ2luLXJpZ2h0OiAxZW07XCI+XG4gICAgICA8UmFkaW8gYmluZDpncm91cD17Y29sb3J9IHZhbHVlPXtvcHRpb259IC8+XG4gICAgICA8c3BhbiBzbG90PVwibGFiZWxcIj57YCR7b3B0aW9uWzBdLnRvVXBwZXJDYXNlKCl9JHtvcHRpb24uc2xpY2UoMSl9YH08L3NwYW4+XG4gICAgPC9Gb3JtRmllbGQ+XG4gIHsvZWFjaH1cbjwvZGl2PlxuXG48c2NyaXB0PlxuICBpbXBvcnQgeyBjbGFzc01hcCB9IGZyb20gJ0BzbXVpL2NvbW1vbi9pbnRlcm5hbC5qcyc7XG4gIGltcG9ydCB7IExhYmVsIH0gZnJvbSAnQHNtdWkvY29tbW9uJztcbiAgaW1wb3J0IEJ1dHRvbiBmcm9tICdAc211aS9idXR0b24nO1xuICBpbXBvcnQgRm9ybUZpZWxkIGZyb20gJ0BzbXVpL2Zvcm0tZmllbGQnO1xuICBpbXBvcnQgUmFkaW8gZnJvbSAnQHNtdWkvcmFkaW8nO1xuICBpbXBvcnQgQ2hlY2tib3ggZnJvbSAnQHNtdWkvY2hlY2tib3gnO1xuXG4gIGxldCBiaWcgPSBmYWxzZTtcbiAgbGV0IGNvbG9yID0gJ3JlZCc7XG48L3NjcmlwdD5cblxuPHN0eWxlPlxuICAqIDpnbG9iYWwoLm15LWJ1dHRvbikge1xuICAgIG1hcmdpbjogMC41ZW07XG4gIH1cblxuICAqIDpnbG9iYWwoLnJlZCkge1xuICAgIGNvbG9yOiByZWQ7XG4gIH1cbiAgKiA6Z2xvYmFsKC5ibHVlKSB7XG4gICAgY29sb3I6IGJsdWU7XG4gIH1cbiAgKiA6Z2xvYmFsKC5ncmVlbikge1xuICAgIGNvbG9yOiBncmVlbjtcbiAgfVxuXG4gICogOmdsb2JhbCguYmlnKSB7XG4gICAgZm9udC1zaXplOiAxLjVlbTtcbiAgfVxuPC9zdHlsZT5cbiIsIjwhLS0gVGhpcyBldmVudCB3aWxsIGNvbnRpbnVlIHRvIGJ1YmJsZSB1cCBiZXlvbmQgdGhpcyBjb21wb25lbnQuIC0tPlxuPGRpdiBjbGFzcz1cImV2ZW50XCIgb246TXlFdmVudD17KGUpID0+IChldmVudCA9IGUpfT5cbiAgSSdtIHRoZSBldmVudCBsaXN0ZW5lci5cblxuICA8ZGl2IGNsYXNzPVwiZXZlbnRcIj5cbiAgICA8ZGl2IGNsYXNzPVwiZXZlbnRcIj5cbiAgICAgIDxkaXYgY2xhc3M9XCJldmVudFwiIGJpbmQ6dGhpcz17dGFyZ2V0fT5JJ20gdGhlIGV2ZW50IHRhcmdldC48L2Rpdj5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG48L2Rpdj5cblxuPGJyIC8+XG5cbjxCdXR0b24gb246Y2xpY2s9e2Rpc3BhdGNoRXZlbnR9PkRpc3BhdGNoIEV2ZW50PC9CdXR0b24+XG5cbjxwcmVcbiAgY2xhc3M9XCJzdGF0dXNcIj5DYXVnaHQgRXZlbnQgRGV0YWlsOiB7ZXZlbnQgJiYgSlNPTi5zdHJpbmdpZnkoZXZlbnQuZGV0YWlsKX08L3ByZT5cblxuPHNjcmlwdD5cbiAgaW1wb3J0IHsgZGlzcGF0Y2ggfSBmcm9tICdAc211aS9jb21tb24vaW50ZXJuYWwuanMnO1xuICBpbXBvcnQgQnV0dG9uIGZyb20gJ0BzbXVpL2J1dHRvbic7XG5cbiAgbGV0IHRhcmdldDtcbiAgbGV0IGV2ZW50O1xuXG4gIGZ1bmN0aW9uIGRpc3BhdGNoRXZlbnQoKSB7XG4gICAgZGlzcGF0Y2goXG4gICAgICB0YXJnZXQsXG4gICAgICAnTXlFdmVudCcsXG4gICAgICB7XG4gICAgICAgIC8vIFRoaXMgaXMgdGhlIGV2ZW50LmRldGFpbHMgb2JqZWN0LlxuICAgICAgICB0aW1lOiBuZXcgRGF0ZSgpLnRvTG9jYWxlVGltZVN0cmluZygpLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgLy8gVGhpcyBpcyB0aGUgZXZlbnRJbml0IG9iamVjdC5cbiAgICAgICAgYnViYmxlczogdHJ1ZSwgLy8gdGhpcyBpcyB0aGUgZGVmYXVsdCB3aGVuIG5vIGV2ZW50SW5pdCBvYmplY3QgaXMgcHJvdmlkZWQuXG4gICAgICAgIGNhbmNlbGFibGU6IHRydWUsIC8vIHlvdSBjYW4gbWFrZSBpdCBjYW5jZWxhYmxlIGxpa2UgdGhpcy5cbiAgICAgIH1cbiAgICApO1xuICB9XG48L3NjcmlwdD5cblxuPHN0eWxlPlxuICAuZXZlbnQge1xuICAgIHBhZGRpbmc6IDFlbTtcbiAgICBib3JkZXI6IDFweCBzb2xpZCBjdXJyZW50Q29sb3I7XG4gIH1cbjwvc3R5bGU+XG4iLCI8ZGl2IGNsYXNzPVwibXktY29tcG9uZW50IHtjbGFzc05hbWV9XCIgey4uLmV4Y2x1ZGUoJCRyZXN0UHJvcHMsIFsnYnV0dG9uJCddKX0+XG4gIDxCdXR0b25cbiAgICBvbjpjbGlja1xuICAgIGNsYXNzPVwiYnV0dG9uIHtidXR0b24kY2xhc3N9XCJcbiAgICB7Li4ucHJlZml4RmlsdGVyKCQkcmVzdFByb3BzLCAnYnV0dG9uJCcpfVxuICA+XG4gICAgPHNsb3QgLz5cbiAgPC9CdXR0b24+XG48L2Rpdj5cblxuPHNjcmlwdD5cbiAgaW1wb3J0IHsgZXhjbHVkZSwgcHJlZml4RmlsdGVyIH0gZnJvbSAnQHNtdWkvY29tbW9uL2ludGVybmFsLmpzJztcbiAgaW1wb3J0IEJ1dHRvbiBmcm9tICdAc211aS9idXR0b24nO1xuXG4gIGxldCBjbGFzc05hbWUgPSAnJztcbiAgZXhwb3J0IHsgY2xhc3NOYW1lIGFzIGNsYXNzIH07XG4gIGV4cG9ydCBsZXQgYnV0dG9uJGNsYXNzID0gJyc7XG48L3NjcmlwdD5cbiIsIjxNeUNvbXBvbmVudFxuICBjbGFzcz1cIm15LWNsYXNzXCJcbiAgYnV0dG9uJGRpc2FibGVkPXtkaXNhYmxlZH1cbiAgb246Y2xpY2s9eygpID0+IChkaXNhYmxlZCA9IHRydWUpfVxuPlxuICBDbGljayBNZSBPbmx5IE9uY2VcbjwvTXlDb21wb25lbnQ+XG5cbjxzY3JpcHQ+XG4gIGltcG9ydCBNeUNvbXBvbmVudCBmcm9tICcuL19FeGNsdWRlQW5kUHJlZml4RmlsdGVyQ29tcG9uZW50LnN2ZWx0ZSc7XG5cbiAgbGV0IGRpc2FibGVkID0gZmFsc2U7XG48L3NjcmlwdD5cbiIsIjxkaXYgdXNlOmZvcndhcmRFdmVudHMgdGFiaW5kZXg9XCIwXCI+XG4gIDxzbG90IC8+XG48L2Rpdj5cblxuPHNjcmlwdD5cbiAgaW1wb3J0IHsgZm9yd2FyZEV2ZW50c0J1aWxkZXIgfSBmcm9tICdAc211aS9jb21tb24vaW50ZXJuYWwuanMnO1xuICBpbXBvcnQgeyBnZXRfY3VycmVudF9jb21wb25lbnQgfSBmcm9tICdzdmVsdGUvaW50ZXJuYWwnO1xuXG4gIGNvbnN0IGZvcndhcmRFdmVudHMgPSBmb3J3YXJkRXZlbnRzQnVpbGRlcihnZXRfY3VycmVudF9jb21wb25lbnQoKSk7XG48L3NjcmlwdD5cbiIsIjxNeUNvbXBvbmVudFxuICBvbjpjbGljaz17KCkgPT4gY2xpY2tlZCsrfVxuICBvbjprZXlwcmVzcyRwcmV2ZW50RGVmYXVsdD17KGV2ZW50KSA9PiAoa2V5ID0gZXZlbnQua2V5KX1cbiAgb246Zm9jdXM9eygpID0+IChmb2N1c2VkID0gdHJ1ZSl9XG4gIG9uOmJsdXI9eygpID0+IChmb2N1c2VkID0gZmFsc2UpfVxuPlxuICBDbGljayBtZSwga2V5IHByZXNzIG1lLCBmb2N1cyBtZSwgYmx1ciBtZSwgdXNlIG1lIGhvd2V2ZXIgeW91IHdhbnQuXG48L015Q29tcG9uZW50PlxuXG48cHJlXG4gIGNsYXNzPVwic3RhdHVzXCI+Q2xpY2tlZDoge2NsaWNrZWR9LCBLZXkgUHJlc3NlZDoge2tleSA9PT0gJyAnID8gJ1NwYWNlJyA6IGtleX0sIEZvY3VzZWQ6IHtmb2N1c2VkfTwvcHJlPlxuXG48c2NyaXB0PlxuICBpbXBvcnQgTXlDb21wb25lbnQgZnJvbSAnLi9fRm9yd2FyZEV2ZW50c0J1aWxkZXJDb21wb25lbnQuc3ZlbHRlJztcblxuICBsZXQgY2xpY2tlZCA9IDA7XG4gIGxldCBrZXkgPSAnTm9uZSc7XG4gIGxldCBmb2N1c2VkID0gZmFsc2U7XG48L3NjcmlwdD5cbiIsIjxkaXYgY2xhc3M9XCJ0YXJnZXRcIiB1c2U6dXNlQWN0aW9ucz17dXNlfT5cbiAgPHNwYW4gc3R5bGU9XCJ1c2VyLXNlbGVjdDogbm9uZTtcIj5cbiAgICA8c2xvdCAvPlxuICA8L3NwYW4+XG48L2Rpdj5cblxuPHNjcmlwdD5cbiAgaW1wb3J0IHsgdXNlQWN0aW9ucyB9IGZyb20gJ0BzbXVpL2NvbW1vbi9pbnRlcm5hbC5qcyc7XG5cbiAgZXhwb3J0IGxldCB1c2UgPSBbXTtcbjwvc2NyaXB0PlxuXG48c3R5bGU+XG4gIC50YXJnZXQge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBib3JkZXItcmFkaXVzOiAxZW07XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICB3aWR0aDogMTIwcHg7XG4gICAgaGVpZ2h0OiAxMjBweDtcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDAsIDAsIDApO1xuICAgIHotaW5kZXg6IDA7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tbWRjLXRoZW1lLXByaW1hcnkpO1xuICAgIGNvbG9yOiB2YXIoLS1tZGMtdGhlbWUtb24tcHJpbWFyeSk7XG4gIH1cbjwvc3R5bGU+XG4iLCIvKipcbiAqIFRpbnlHZXN0dXJlLmpzXG4gKlxuICogVGhpcyBzZXJ2aWNlIHVzZXMgcGFzc2l2ZSBsaXN0ZW5lcnMsIHNvIHlvdSBjYW4ndCBjYWxsIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAqIG9uIGFueSBvZiB0aGUgZXZlbnRzLlxuICpcbiAqIEFkYXB0ZWQgZnJvbSBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9TbGVlcFdhbGtlci9kYTU2MzZiMWFiY2JhZmY0OGM0ZFxuICogYW5kIGh0dHBzOi8vZ2l0aHViLmNvbS91eGl0dGVuL3h3aXBlclxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUaW55R2VzdHVyZSB7XG4gIGNvbnN0cnVjdG9yIChlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIFRpbnlHZXN0dXJlLmRlZmF1bHRzLCBvcHRpb25zKTtcbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMub3B0cyA9IG9wdGlvbnM7XG4gICAgdGhpcy50b3VjaFN0YXJ0WCA9IG51bGw7XG4gICAgdGhpcy50b3VjaFN0YXJ0WSA9IG51bGw7XG4gICAgdGhpcy50b3VjaEVuZFggPSBudWxsO1xuICAgIHRoaXMudG91Y2hFbmRZID0gbnVsbDtcbiAgICB0aGlzLnZlbG9jaXR5WCA9IG51bGw7XG4gICAgdGhpcy52ZWxvY2l0eVkgPSBudWxsO1xuICAgIHRoaXMubG9uZ1ByZXNzVGltZXIgPSBudWxsO1xuICAgIHRoaXMuZG91YmxlVGFwV2FpdGluZyA9IGZhbHNlO1xuICAgIHRoaXMuaGFuZGxlcnMgPSB7XG4gICAgICAncGFuc3RhcnQnOiBbXSxcbiAgICAgICdwYW5tb3ZlJzogW10sXG4gICAgICAncGFuZW5kJzogW10sXG4gICAgICAnc3dpcGVsZWZ0JzogW10sXG4gICAgICAnc3dpcGVyaWdodCc6IFtdLFxuICAgICAgJ3N3aXBldXAnOiBbXSxcbiAgICAgICdzd2lwZWRvd24nOiBbXSxcbiAgICAgICd0YXAnOiBbXSxcbiAgICAgICdkb3VibGV0YXAnOiBbXSxcbiAgICAgICdsb25ncHJlc3MnOiBbXVxuICAgIH07XG5cbiAgICB0aGlzLl9vblRvdWNoU3RhcnQgPSB0aGlzLm9uVG91Y2hTdGFydC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uVG91Y2hNb3ZlID0gdGhpcy5vblRvdWNoTW92ZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uVG91Y2hFbmQgPSB0aGlzLm9uVG91Y2hFbmQuYmluZCh0aGlzKTtcblxuICAgIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5fb25Ub3VjaFN0YXJ0LCBwYXNzaXZlSWZTdXBwb3J0ZWQpO1xuICAgIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLl9vblRvdWNoTW92ZSwgcGFzc2l2ZUlmU3VwcG9ydGVkKTtcbiAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLl9vblRvdWNoRW5kLCBwYXNzaXZlSWZTdXBwb3J0ZWQpO1xuXG4gICAgaWYgKHRoaXMub3B0cy5tb3VzZVN1cHBvcnQgJiYgISgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cpKSB7XG4gICAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5fb25Ub3VjaFN0YXJ0LCBwYXNzaXZlSWZTdXBwb3J0ZWQpO1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5fb25Ub3VjaE1vdmUsIHBhc3NpdmVJZlN1cHBvcnRlZCk7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5fb25Ub3VjaEVuZCwgcGFzc2l2ZUlmU3VwcG9ydGVkKTtcbiAgICB9XG4gIH1cblxuICBkZXN0cm95ICgpIHtcbiAgICB0aGlzLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMuX29uVG91Y2hTdGFydCk7XG4gICAgdGhpcy5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuX29uVG91Y2hNb3ZlKTtcbiAgICB0aGlzLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLl9vblRvdWNoRW5kKTtcbiAgICB0aGlzLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5fb25Ub3VjaFN0YXJ0KTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9vblRvdWNoTW92ZSk7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX29uVG91Y2hFbmQpO1xuICAgIGNsZWFyVGltZW91dCh0aGlzLmxvbmdQcmVzc1RpbWVyKTtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5kb3VibGVUYXBUaW1lcik7XG4gIH1cblxuICBvbiAodHlwZSwgZm4pIHtcbiAgICBpZiAodGhpcy5oYW5kbGVyc1t0eXBlXSkge1xuICAgICAgdGhpcy5oYW5kbGVyc1t0eXBlXS5wdXNoKGZuKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGUsXG4gICAgICAgIGZuLFxuICAgICAgICBjYW5jZWw6ICgpID0+IHRoaXMub2ZmKHR5cGUsIGZuKVxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICBvZmYgKHR5cGUsIGZuKSB7XG4gICAgaWYgKHRoaXMuaGFuZGxlcnNbdHlwZV0pIHtcbiAgICAgIGNvbnN0IGlkeCA9IHRoaXMuaGFuZGxlcnNbdHlwZV0uaW5kZXhPZihmbik7XG4gICAgICBpZiAoaWR4ICE9PSAtMSkge1xuICAgICAgICB0aGlzLmhhbmRsZXJzW3R5cGVdLnNwbGljZShpZHgsIDEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZpcmUgKHR5cGUsIGV2ZW50KSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmhhbmRsZXJzW3R5cGVdLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLmhhbmRsZXJzW3R5cGVdW2ldKGV2ZW50KTtcbiAgICB9XG4gIH1cblxuICBvblRvdWNoU3RhcnQgKGV2ZW50KSB7XG4gICAgdGhpcy50aHJlc2hvbGRYID0gdGhpcy5vcHRzLnRocmVzaG9sZCgneCcsIHRoaXMpO1xuICAgIHRoaXMudGhyZXNob2xkWSA9IHRoaXMub3B0cy50aHJlc2hvbGQoJ3knLCB0aGlzKTtcbiAgICB0aGlzLmRpc3JlZ2FyZFZlbG9jaXR5VGhyZXNob2xkWCA9IHRoaXMub3B0cy5kaXNyZWdhcmRWZWxvY2l0eVRocmVzaG9sZCgneCcsIHRoaXMpO1xuICAgIHRoaXMuZGlzcmVnYXJkVmVsb2NpdHlUaHJlc2hvbGRZID0gdGhpcy5vcHRzLmRpc3JlZ2FyZFZlbG9jaXR5VGhyZXNob2xkKCd5JywgdGhpcyk7XG4gICAgdGhpcy50b3VjaFN0YXJ0WCA9IChldmVudC50eXBlID09PSAnbW91c2Vkb3duJyA/IGV2ZW50LnNjcmVlblggOiBldmVudC5jaGFuZ2VkVG91Y2hlc1swXS5zY3JlZW5YKTtcbiAgICB0aGlzLnRvdWNoU3RhcnRZID0gKGV2ZW50LnR5cGUgPT09ICdtb3VzZWRvd24nID8gZXZlbnQuc2NyZWVuWSA6IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLnNjcmVlblkpO1xuICAgIHRoaXMudG91Y2hNb3ZlWCA9IG51bGw7XG4gICAgdGhpcy50b3VjaE1vdmVZID0gbnVsbDtcbiAgICB0aGlzLnRvdWNoRW5kWCA9IG51bGw7XG4gICAgdGhpcy50b3VjaEVuZFkgPSBudWxsO1xuICAgIC8vIExvbmcgcHJlc3MuXG4gICAgdGhpcy5sb25nUHJlc3NUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5maXJlKCdsb25ncHJlc3MnLCBldmVudCksIHRoaXMub3B0cy5sb25nUHJlc3NUaW1lKTtcbiAgICB0aGlzLmZpcmUoJ3BhbnN0YXJ0JywgZXZlbnQpO1xuICB9XG5cbiAgb25Ub3VjaE1vdmUgKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdtb3VzZW1vdmUnICYmICghdGhpcy50b3VjaFN0YXJ0WCB8fCB0aGlzLnRvdWNoRW5kWCAhPT0gbnVsbCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdG91Y2hNb3ZlWCA9IChldmVudC50eXBlID09PSAnbW91c2Vtb3ZlJyA/IGV2ZW50LnNjcmVlblggOiBldmVudC5jaGFuZ2VkVG91Y2hlc1swXS5zY3JlZW5YKSAtIHRoaXMudG91Y2hTdGFydFg7XG4gICAgdGhpcy52ZWxvY2l0eVggPSB0b3VjaE1vdmVYIC0gdGhpcy50b3VjaE1vdmVYO1xuICAgIHRoaXMudG91Y2hNb3ZlWCA9IHRvdWNoTW92ZVg7XG4gICAgY29uc3QgdG91Y2hNb3ZlWSA9IChldmVudC50eXBlID09PSAnbW91c2Vtb3ZlJyA/IGV2ZW50LnNjcmVlblkgOiBldmVudC5jaGFuZ2VkVG91Y2hlc1swXS5zY3JlZW5ZKSAtIHRoaXMudG91Y2hTdGFydFk7XG4gICAgdGhpcy52ZWxvY2l0eVkgPSB0b3VjaE1vdmVZIC0gdGhpcy50b3VjaE1vdmVZO1xuICAgIHRoaXMudG91Y2hNb3ZlWSA9IHRvdWNoTW92ZVk7XG4gICAgY29uc3QgYWJzVG91Y2hNb3ZlWCA9IE1hdGguYWJzKHRoaXMudG91Y2hNb3ZlWCk7XG4gICAgY29uc3QgYWJzVG91Y2hNb3ZlWSA9IE1hdGguYWJzKHRoaXMudG91Y2hNb3ZlWSk7XG4gICAgdGhpcy5zd2lwaW5nSG9yaXpvbnRhbCA9IGFic1RvdWNoTW92ZVggPiB0aGlzLnRocmVzaG9sZFg7XG4gICAgdGhpcy5zd2lwaW5nVmVydGljYWwgPSBhYnNUb3VjaE1vdmVZID4gdGhpcy50aHJlc2hvbGRZO1xuICAgIHRoaXMuc3dpcGluZ0RpcmVjdGlvbiA9IGFic1RvdWNoTW92ZVggPiBhYnNUb3VjaE1vdmVZXG4gICAgICA/ICh0aGlzLnN3aXBpbmdIb3Jpem9udGFsID8gJ2hvcml6b250YWwnIDogJ3ByZS1ob3Jpem9udGFsJylcbiAgICAgIDogKHRoaXMuc3dpcGluZ1ZlcnRpY2FsID8gJ3ZlcnRpY2FsJyA6ICdwcmUtdmVydGljYWwnKTtcbiAgICBpZiAoTWF0aC5tYXgoYWJzVG91Y2hNb3ZlWCwgYWJzVG91Y2hNb3ZlWSkgPiB0aGlzLm9wdHMucHJlc3NUaHJlc2hvbGQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLmxvbmdQcmVzc1RpbWVyKTtcbiAgICB9XG4gICAgdGhpcy5maXJlKCdwYW5tb3ZlJywgZXZlbnQpO1xuICB9XG5cbiAgb25Ub3VjaEVuZCAoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ21vdXNldXAnICYmICghdGhpcy50b3VjaFN0YXJ0WCB8fCB0aGlzLnRvdWNoRW5kWCAhPT0gbnVsbCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy50b3VjaEVuZFggPSAoZXZlbnQudHlwZSA9PT0gJ21vdXNldXAnID8gZXZlbnQuc2NyZWVuWCA6IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLnNjcmVlblgpO1xuICAgIHRoaXMudG91Y2hFbmRZID0gKGV2ZW50LnR5cGUgPT09ICdtb3VzZXVwJyA/IGV2ZW50LnNjcmVlblkgOiBldmVudC5jaGFuZ2VkVG91Y2hlc1swXS5zY3JlZW5ZKTtcbiAgICB0aGlzLmZpcmUoJ3BhbmVuZCcsIGV2ZW50KTtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5sb25nUHJlc3NUaW1lcik7XG5cbiAgICBjb25zdCB4ID0gdGhpcy50b3VjaEVuZFggLSB0aGlzLnRvdWNoU3RhcnRYO1xuICAgIGNvbnN0IGFic1ggPSBNYXRoLmFicyh4KTtcbiAgICBjb25zdCB5ID0gdGhpcy50b3VjaEVuZFkgLSB0aGlzLnRvdWNoU3RhcnRZO1xuICAgIGNvbnN0IGFic1kgPSBNYXRoLmFicyh5KTtcblxuICAgIGlmIChhYnNYID4gdGhpcy50aHJlc2hvbGRYIHx8IGFic1kgPiB0aGlzLnRocmVzaG9sZFkpIHtcbiAgICAgIHRoaXMuc3dpcGVkSG9yaXpvbnRhbCA9IHRoaXMub3B0cy5kaWFnb25hbFN3aXBlcyA/IE1hdGguYWJzKHggLyB5KSA8PSB0aGlzLm9wdHMuZGlhZ29uYWxMaW1pdCA6IGFic1ggPj0gYWJzWSAmJiBhYnNYID4gdGhpcy50aHJlc2hvbGRYO1xuICAgICAgdGhpcy5zd2lwZWRWZXJ0aWNhbCA9IHRoaXMub3B0cy5kaWFnb25hbFN3aXBlcyA/IE1hdGguYWJzKHkgLyB4KSA8PSB0aGlzLm9wdHMuZGlhZ29uYWxMaW1pdCA6IGFic1kgPiBhYnNYICYmIGFic1kgPiB0aGlzLnRocmVzaG9sZFk7XG4gICAgICBpZiAodGhpcy5zd2lwZWRIb3Jpem9udGFsKSB7XG4gICAgICAgIGlmICh4IDwgMCkge1xuICAgICAgICAgIC8vIExlZnQgc3dpcGUuXG4gICAgICAgICAgaWYgKHRoaXMudmVsb2NpdHlYIDwgLXRoaXMub3B0cy52ZWxvY2l0eVRocmVzaG9sZCB8fCB4IDwgLXRoaXMuZGlzcmVnYXJkVmVsb2NpdHlUaHJlc2hvbGRYKSB7XG4gICAgICAgICAgICB0aGlzLmZpcmUoJ3N3aXBlbGVmdCcsIGV2ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gUmlnaHQgc3dpcGUuXG4gICAgICAgICAgaWYgKHRoaXMudmVsb2NpdHlYID4gdGhpcy5vcHRzLnZlbG9jaXR5VGhyZXNob2xkIHx8IHggPiB0aGlzLmRpc3JlZ2FyZFZlbG9jaXR5VGhyZXNob2xkWCkge1xuICAgICAgICAgICAgdGhpcy5maXJlKCdzd2lwZXJpZ2h0JywgZXZlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc3dpcGVkVmVydGljYWwpIHtcbiAgICAgICAgaWYgKHkgPCAwKSB7XG4gICAgICAgICAgLy8gVXB3YXJkIHN3aXBlLlxuICAgICAgICAgIGlmICh0aGlzLnZlbG9jaXR5WSA8IC10aGlzLm9wdHMudmVsb2NpdHlUaHJlc2hvbGQgfHwgeSA8IC10aGlzLmRpc3JlZ2FyZFZlbG9jaXR5VGhyZXNob2xkWSkge1xuICAgICAgICAgICAgdGhpcy5maXJlKCdzd2lwZXVwJywgZXZlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBEb3dud2FyZCBzd2lwZS5cbiAgICAgICAgICBpZiAodGhpcy52ZWxvY2l0eVkgPiB0aGlzLm9wdHMudmVsb2NpdHlUaHJlc2hvbGQgfHwgeSA+IHRoaXMuZGlzcmVnYXJkVmVsb2NpdHlUaHJlc2hvbGRZKSB7XG4gICAgICAgICAgICB0aGlzLmZpcmUoJ3N3aXBlZG93bicsIGV2ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGFic1ggPCB0aGlzLm9wdHMucHJlc3NUaHJlc2hvbGQgJiYgYWJzWSA8IHRoaXMub3B0cy5wcmVzc1RocmVzaG9sZCkge1xuICAgICAgLy8gVGFwLlxuICAgICAgaWYgKHRoaXMuZG91YmxlVGFwV2FpdGluZykge1xuICAgICAgICB0aGlzLmRvdWJsZVRhcFdhaXRpbmcgPSBmYWxzZTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZG91YmxlVGFwVGltZXIpO1xuICAgICAgICB0aGlzLmZpcmUoJ2RvdWJsZXRhcCcsIGV2ZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZG91YmxlVGFwV2FpdGluZyA9IHRydWU7XG4gICAgICAgIHRoaXMuZG91YmxlVGFwVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMuZG91YmxlVGFwV2FpdGluZyA9IGZhbHNlLCB0aGlzLm9wdHMuZG91YmxlVGFwVGltZSk7XG4gICAgICAgIHRoaXMuZmlyZSgndGFwJywgZXZlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5UaW55R2VzdHVyZS5kZWZhdWx0cyA9IHtcbiAgdGhyZXNob2xkOiAodHlwZSwgc2VsZikgPT4gTWF0aC5tYXgoMjUsIE1hdGguZmxvb3IoMC4xNSAqICh0eXBlID09PSAneCcgPyB3aW5kb3cuaW5uZXJXaWR0aCB8fCBkb2N1bWVudC5ib2R5LmNsaWVudFdpZHRoIDogd2luZG93LmlubmVySGVpZ2h0IHx8IGRvY3VtZW50LmJvZHkuY2xpZW50SGVpZ2h0KSkpLFxuICB2ZWxvY2l0eVRocmVzaG9sZDogMTAsXG4gIGRpc3JlZ2FyZFZlbG9jaXR5VGhyZXNob2xkOiAodHlwZSwgc2VsZikgPT4gTWF0aC5mbG9vcigwLjUgKiAodHlwZSA9PT0gJ3gnID8gc2VsZi5lbGVtZW50LmNsaWVudFdpZHRoIDogc2VsZi5lbGVtZW50LmNsaWVudEhlaWdodCkpLFxuICBwcmVzc1RocmVzaG9sZDogOCxcbiAgZGlhZ29uYWxTd2lwZXM6IGZhbHNlLFxuICBkaWFnb25hbExpbWl0OiBNYXRoLnRhbig0NSAqIDEuNSAvIDE4MCAqIE1hdGguUEkpLFxuICBsb25nUHJlc3NUaW1lOiA1MDAsXG4gIGRvdWJsZVRhcFRpbWU6IDMwMCxcbiAgbW91c2VTdXBwb3J0OiB0cnVlXG59O1xuXG4vLyBQYXNzaXZlIGZlYXR1cmUgZGV0ZWN0aW9uLlxubGV0IHBhc3NpdmVJZlN1cHBvcnRlZCA9IGZhbHNlO1xuXG50cnkge1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndGVzdCcsIG51bGwsIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ3Bhc3NpdmUnLCB7IGdldDogZnVuY3Rpb24oKSB7IHBhc3NpdmVJZlN1cHBvcnRlZCA9IHsgcGFzc2l2ZTogdHJ1ZSB9OyB9IH0pKTtcbn0gY2F0Y2goZXJyKSB7fVxuIiwiZXhwb3J0IHsgaWRlbnRpdHkgYXMgbGluZWFyIH0gZnJvbSAnLi4vaW50ZXJuYWwvaW5kZXgubWpzJztcblxuLypcbkFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbWF0dGRlc2xcbkRpc3RyaWJ1dGVkIHVuZGVyIE1JVCBMaWNlbnNlIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXR0ZGVzbC9lYXNlcy9ibG9iL21hc3Rlci9MSUNFTlNFLm1kXG4qL1xuZnVuY3Rpb24gYmFja0luT3V0KHQpIHtcbiAgICBjb25zdCBzID0gMS43MDE1OCAqIDEuNTI1O1xuICAgIGlmICgodCAqPSAyKSA8IDEpXG4gICAgICAgIHJldHVybiAwLjUgKiAodCAqIHQgKiAoKHMgKyAxKSAqIHQgLSBzKSk7XG4gICAgcmV0dXJuIDAuNSAqICgodCAtPSAyKSAqIHQgKiAoKHMgKyAxKSAqIHQgKyBzKSArIDIpO1xufVxuZnVuY3Rpb24gYmFja0luKHQpIHtcbiAgICBjb25zdCBzID0gMS43MDE1ODtcbiAgICByZXR1cm4gdCAqIHQgKiAoKHMgKyAxKSAqIHQgLSBzKTtcbn1cbmZ1bmN0aW9uIGJhY2tPdXQodCkge1xuICAgIGNvbnN0IHMgPSAxLjcwMTU4O1xuICAgIHJldHVybiAtLXQgKiB0ICogKChzICsgMSkgKiB0ICsgcykgKyAxO1xufVxuZnVuY3Rpb24gYm91bmNlT3V0KHQpIHtcbiAgICBjb25zdCBhID0gNC4wIC8gMTEuMDtcbiAgICBjb25zdCBiID0gOC4wIC8gMTEuMDtcbiAgICBjb25zdCBjID0gOS4wIC8gMTAuMDtcbiAgICBjb25zdCBjYSA9IDQzNTYuMCAvIDM2MS4wO1xuICAgIGNvbnN0IGNiID0gMzU0NDIuMCAvIDE4MDUuMDtcbiAgICBjb25zdCBjYyA9IDE2MDYxLjAgLyAxODA1LjA7XG4gICAgY29uc3QgdDIgPSB0ICogdDtcbiAgICByZXR1cm4gdCA8IGFcbiAgICAgICAgPyA3LjU2MjUgKiB0MlxuICAgICAgICA6IHQgPCBiXG4gICAgICAgICAgICA/IDkuMDc1ICogdDIgLSA5LjkgKiB0ICsgMy40XG4gICAgICAgICAgICA6IHQgPCBjXG4gICAgICAgICAgICAgICAgPyBjYSAqIHQyIC0gY2IgKiB0ICsgY2NcbiAgICAgICAgICAgICAgICA6IDEwLjggKiB0ICogdCAtIDIwLjUyICogdCArIDEwLjcyO1xufVxuZnVuY3Rpb24gYm91bmNlSW5PdXQodCkge1xuICAgIHJldHVybiB0IDwgMC41XG4gICAgICAgID8gMC41ICogKDEuMCAtIGJvdW5jZU91dCgxLjAgLSB0ICogMi4wKSlcbiAgICAgICAgOiAwLjUgKiBib3VuY2VPdXQodCAqIDIuMCAtIDEuMCkgKyAwLjU7XG59XG5mdW5jdGlvbiBib3VuY2VJbih0KSB7XG4gICAgcmV0dXJuIDEuMCAtIGJvdW5jZU91dCgxLjAgLSB0KTtcbn1cbmZ1bmN0aW9uIGNpcmNJbk91dCh0KSB7XG4gICAgaWYgKCh0ICo9IDIpIDwgMSlcbiAgICAgICAgcmV0dXJuIC0wLjUgKiAoTWF0aC5zcXJ0KDEgLSB0ICogdCkgLSAxKTtcbiAgICByZXR1cm4gMC41ICogKE1hdGguc3FydCgxIC0gKHQgLT0gMikgKiB0KSArIDEpO1xufVxuZnVuY3Rpb24gY2lyY0luKHQpIHtcbiAgICByZXR1cm4gMS4wIC0gTWF0aC5zcXJ0KDEuMCAtIHQgKiB0KTtcbn1cbmZ1bmN0aW9uIGNpcmNPdXQodCkge1xuICAgIHJldHVybiBNYXRoLnNxcnQoMSAtIC0tdCAqIHQpO1xufVxuZnVuY3Rpb24gY3ViaWNJbk91dCh0KSB7XG4gICAgcmV0dXJuIHQgPCAwLjUgPyA0LjAgKiB0ICogdCAqIHQgOiAwLjUgKiBNYXRoLnBvdygyLjAgKiB0IC0gMi4wLCAzLjApICsgMS4wO1xufVxuZnVuY3Rpb24gY3ViaWNJbih0KSB7XG4gICAgcmV0dXJuIHQgKiB0ICogdDtcbn1cbmZ1bmN0aW9uIGN1YmljT3V0KHQpIHtcbiAgICBjb25zdCBmID0gdCAtIDEuMDtcbiAgICByZXR1cm4gZiAqIGYgKiBmICsgMS4wO1xufVxuZnVuY3Rpb24gZWxhc3RpY0luT3V0KHQpIHtcbiAgICByZXR1cm4gdCA8IDAuNVxuICAgICAgICA/IDAuNSAqXG4gICAgICAgICAgICBNYXRoLnNpbigoKCsxMy4wICogTWF0aC5QSSkgLyAyKSAqIDIuMCAqIHQpICpcbiAgICAgICAgICAgIE1hdGgucG93KDIuMCwgMTAuMCAqICgyLjAgKiB0IC0gMS4wKSlcbiAgICAgICAgOiAwLjUgKlxuICAgICAgICAgICAgTWF0aC5zaW4oKCgtMTMuMCAqIE1hdGguUEkpIC8gMikgKiAoMi4wICogdCAtIDEuMCArIDEuMCkpICpcbiAgICAgICAgICAgIE1hdGgucG93KDIuMCwgLTEwLjAgKiAoMi4wICogdCAtIDEuMCkpICtcbiAgICAgICAgICAgIDEuMDtcbn1cbmZ1bmN0aW9uIGVsYXN0aWNJbih0KSB7XG4gICAgcmV0dXJuIE1hdGguc2luKCgxMy4wICogdCAqIE1hdGguUEkpIC8gMikgKiBNYXRoLnBvdygyLjAsIDEwLjAgKiAodCAtIDEuMCkpO1xufVxuZnVuY3Rpb24gZWxhc3RpY091dCh0KSB7XG4gICAgcmV0dXJuIChNYXRoLnNpbigoLTEzLjAgKiAodCArIDEuMCkgKiBNYXRoLlBJKSAvIDIpICogTWF0aC5wb3coMi4wLCAtMTAuMCAqIHQpICsgMS4wKTtcbn1cbmZ1bmN0aW9uIGV4cG9Jbk91dCh0KSB7XG4gICAgcmV0dXJuIHQgPT09IDAuMCB8fCB0ID09PSAxLjBcbiAgICAgICAgPyB0XG4gICAgICAgIDogdCA8IDAuNVxuICAgICAgICAgICAgPyArMC41ICogTWF0aC5wb3coMi4wLCAyMC4wICogdCAtIDEwLjApXG4gICAgICAgICAgICA6IC0wLjUgKiBNYXRoLnBvdygyLjAsIDEwLjAgLSB0ICogMjAuMCkgKyAxLjA7XG59XG5mdW5jdGlvbiBleHBvSW4odCkge1xuICAgIHJldHVybiB0ID09PSAwLjAgPyB0IDogTWF0aC5wb3coMi4wLCAxMC4wICogKHQgLSAxLjApKTtcbn1cbmZ1bmN0aW9uIGV4cG9PdXQodCkge1xuICAgIHJldHVybiB0ID09PSAxLjAgPyB0IDogMS4wIC0gTWF0aC5wb3coMi4wLCAtMTAuMCAqIHQpO1xufVxuZnVuY3Rpb24gcXVhZEluT3V0KHQpIHtcbiAgICB0IC89IDAuNTtcbiAgICBpZiAodCA8IDEpXG4gICAgICAgIHJldHVybiAwLjUgKiB0ICogdDtcbiAgICB0LS07XG4gICAgcmV0dXJuIC0wLjUgKiAodCAqICh0IC0gMikgLSAxKTtcbn1cbmZ1bmN0aW9uIHF1YWRJbih0KSB7XG4gICAgcmV0dXJuIHQgKiB0O1xufVxuZnVuY3Rpb24gcXVhZE91dCh0KSB7XG4gICAgcmV0dXJuIC10ICogKHQgLSAyLjApO1xufVxuZnVuY3Rpb24gcXVhcnRJbk91dCh0KSB7XG4gICAgcmV0dXJuIHQgPCAwLjVcbiAgICAgICAgPyArOC4wICogTWF0aC5wb3codCwgNC4wKVxuICAgICAgICA6IC04LjAgKiBNYXRoLnBvdyh0IC0gMS4wLCA0LjApICsgMS4wO1xufVxuZnVuY3Rpb24gcXVhcnRJbih0KSB7XG4gICAgcmV0dXJuIE1hdGgucG93KHQsIDQuMCk7XG59XG5mdW5jdGlvbiBxdWFydE91dCh0KSB7XG4gICAgcmV0dXJuIE1hdGgucG93KHQgLSAxLjAsIDMuMCkgKiAoMS4wIC0gdCkgKyAxLjA7XG59XG5mdW5jdGlvbiBxdWludEluT3V0KHQpIHtcbiAgICBpZiAoKHQgKj0gMikgPCAxKVxuICAgICAgICByZXR1cm4gMC41ICogdCAqIHQgKiB0ICogdCAqIHQ7XG4gICAgcmV0dXJuIDAuNSAqICgodCAtPSAyKSAqIHQgKiB0ICogdCAqIHQgKyAyKTtcbn1cbmZ1bmN0aW9uIHF1aW50SW4odCkge1xuICAgIHJldHVybiB0ICogdCAqIHQgKiB0ICogdDtcbn1cbmZ1bmN0aW9uIHF1aW50T3V0KHQpIHtcbiAgICByZXR1cm4gLS10ICogdCAqIHQgKiB0ICogdCArIDE7XG59XG5mdW5jdGlvbiBzaW5lSW5PdXQodCkge1xuICAgIHJldHVybiAtMC41ICogKE1hdGguY29zKE1hdGguUEkgKiB0KSAtIDEpO1xufVxuZnVuY3Rpb24gc2luZUluKHQpIHtcbiAgICBjb25zdCB2ID0gTWF0aC5jb3ModCAqIE1hdGguUEkgKiAwLjUpO1xuICAgIGlmIChNYXRoLmFicyh2KSA8IDFlLTE0KVxuICAgICAgICByZXR1cm4gMTtcbiAgICBlbHNlXG4gICAgICAgIHJldHVybiAxIC0gdjtcbn1cbmZ1bmN0aW9uIHNpbmVPdXQodCkge1xuICAgIHJldHVybiBNYXRoLnNpbigodCAqIE1hdGguUEkpIC8gMik7XG59XG5cbmV4cG9ydCB7IGJhY2tJbiwgYmFja0luT3V0LCBiYWNrT3V0LCBib3VuY2VJbiwgYm91bmNlSW5PdXQsIGJvdW5jZU91dCwgY2lyY0luLCBjaXJjSW5PdXQsIGNpcmNPdXQsIGN1YmljSW4sIGN1YmljSW5PdXQsIGN1YmljT3V0LCBlbGFzdGljSW4sIGVsYXN0aWNJbk91dCwgZWxhc3RpY091dCwgZXhwb0luLCBleHBvSW5PdXQsIGV4cG9PdXQsIHF1YWRJbiwgcXVhZEluT3V0LCBxdWFkT3V0LCBxdWFydEluLCBxdWFydEluT3V0LCBxdWFydE91dCwgcXVpbnRJbiwgcXVpbnRJbk91dCwgcXVpbnRPdXQsIHNpbmVJbiwgc2luZUluT3V0LCBzaW5lT3V0IH07XG4iLCJpbXBvcnQgeyB3cml0YWJsZSB9IGZyb20gJy4uL3N0b3JlL2luZGV4Lm1qcyc7XG5pbXBvcnQgeyBub3csIGxvb3AsIGFzc2lnbiB9IGZyb20gJy4uL2ludGVybmFsL2luZGV4Lm1qcyc7XG5pbXBvcnQgeyBsaW5lYXIgfSBmcm9tICcuLi9lYXNpbmcvaW5kZXgubWpzJztcblxuZnVuY3Rpb24gaXNfZGF0ZShvYmopIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cblxuZnVuY3Rpb24gdGlja19zcHJpbmcoY3R4LCBsYXN0X3ZhbHVlLCBjdXJyZW50X3ZhbHVlLCB0YXJnZXRfdmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIGN1cnJlbnRfdmFsdWUgPT09ICdudW1iZXInIHx8IGlzX2RhdGUoY3VycmVudF92YWx1ZSkpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBjb25zdCBkZWx0YSA9IHRhcmdldF92YWx1ZSAtIGN1cnJlbnRfdmFsdWU7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgY29uc3QgdmVsb2NpdHkgPSAoY3VycmVudF92YWx1ZSAtIGxhc3RfdmFsdWUpIC8gKGN0eC5kdCB8fCAxIC8gNjApOyAvLyBndWFyZCBkaXYgYnkgMFxuICAgICAgICBjb25zdCBzcHJpbmcgPSBjdHgub3B0cy5zdGlmZm5lc3MgKiBkZWx0YTtcbiAgICAgICAgY29uc3QgZGFtcGVyID0gY3R4Lm9wdHMuZGFtcGluZyAqIHZlbG9jaXR5O1xuICAgICAgICBjb25zdCBhY2NlbGVyYXRpb24gPSAoc3ByaW5nIC0gZGFtcGVyKSAqIGN0eC5pbnZfbWFzcztcbiAgICAgICAgY29uc3QgZCA9ICh2ZWxvY2l0eSArIGFjY2VsZXJhdGlvbikgKiBjdHguZHQ7XG4gICAgICAgIGlmIChNYXRoLmFicyhkKSA8IGN0eC5vcHRzLnByZWNpc2lvbiAmJiBNYXRoLmFicyhkZWx0YSkgPCBjdHgub3B0cy5wcmVjaXNpb24pIHtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXRfdmFsdWU7IC8vIHNldHRsZWRcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGN0eC5zZXR0bGVkID0gZmFsc2U7IC8vIHNpZ25hbCBsb29wIHRvIGtlZXAgdGlja2luZ1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgcmV0dXJuIGlzX2RhdGUoY3VycmVudF92YWx1ZSkgP1xuICAgICAgICAgICAgICAgIG5ldyBEYXRlKGN1cnJlbnRfdmFsdWUuZ2V0VGltZSgpICsgZCkgOiBjdXJyZW50X3ZhbHVlICsgZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGN1cnJlbnRfdmFsdWUpKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRfdmFsdWUubWFwKChfLCBpKSA9PiB0aWNrX3NwcmluZyhjdHgsIGxhc3RfdmFsdWVbaV0sIGN1cnJlbnRfdmFsdWVbaV0sIHRhcmdldF92YWx1ZVtpXSkpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgY3VycmVudF92YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgY29uc3QgbmV4dF92YWx1ZSA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGsgaW4gY3VycmVudF92YWx1ZSkge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgbmV4dF92YWx1ZVtrXSA9IHRpY2tfc3ByaW5nKGN0eCwgbGFzdF92YWx1ZVtrXSwgY3VycmVudF92YWx1ZVtrXSwgdGFyZ2V0X3ZhbHVlW2tdKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHJldHVybiBuZXh0X3ZhbHVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3Qgc3ByaW5nICR7dHlwZW9mIGN1cnJlbnRfdmFsdWV9IHZhbHVlc2ApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNwcmluZyh2YWx1ZSwgb3B0cyA9IHt9KSB7XG4gICAgY29uc3Qgc3RvcmUgPSB3cml0YWJsZSh2YWx1ZSk7XG4gICAgY29uc3QgeyBzdGlmZm5lc3MgPSAwLjE1LCBkYW1waW5nID0gMC44LCBwcmVjaXNpb24gPSAwLjAxIH0gPSBvcHRzO1xuICAgIGxldCBsYXN0X3RpbWU7XG4gICAgbGV0IHRhc2s7XG4gICAgbGV0IGN1cnJlbnRfdG9rZW47XG4gICAgbGV0IGxhc3RfdmFsdWUgPSB2YWx1ZTtcbiAgICBsZXQgdGFyZ2V0X3ZhbHVlID0gdmFsdWU7XG4gICAgbGV0IGludl9tYXNzID0gMTtcbiAgICBsZXQgaW52X21hc3NfcmVjb3ZlcnlfcmF0ZSA9IDA7XG4gICAgbGV0IGNhbmNlbF90YXNrID0gZmFsc2U7XG4gICAgZnVuY3Rpb24gc2V0KG5ld192YWx1ZSwgb3B0cyA9IHt9KSB7XG4gICAgICAgIHRhcmdldF92YWx1ZSA9IG5ld192YWx1ZTtcbiAgICAgICAgY29uc3QgdG9rZW4gPSBjdXJyZW50X3Rva2VuID0ge307XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IG9wdHMuaGFyZCB8fCAoc3ByaW5nLnN0aWZmbmVzcyA+PSAxICYmIHNwcmluZy5kYW1waW5nID49IDEpKSB7XG4gICAgICAgICAgICBjYW5jZWxfdGFzayA9IHRydWU7IC8vIGNhbmNlbCBhbnkgcnVubmluZyBhbmltYXRpb25cbiAgICAgICAgICAgIGxhc3RfdGltZSA9IG5vdygpO1xuICAgICAgICAgICAgbGFzdF92YWx1ZSA9IG5ld192YWx1ZTtcbiAgICAgICAgICAgIHN0b3JlLnNldCh2YWx1ZSA9IHRhcmdldF92YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3B0cy5zb2Z0KSB7XG4gICAgICAgICAgICBjb25zdCByYXRlID0gb3B0cy5zb2Z0ID09PSB0cnVlID8gLjUgOiArb3B0cy5zb2Z0O1xuICAgICAgICAgICAgaW52X21hc3NfcmVjb3ZlcnlfcmF0ZSA9IDEgLyAocmF0ZSAqIDYwKTtcbiAgICAgICAgICAgIGludl9tYXNzID0gMDsgLy8gaW5maW5pdGUgbWFzcywgdW5hZmZlY3RlZCBieSBzcHJpbmcgZm9yY2VzXG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0YXNrKSB7XG4gICAgICAgICAgICBsYXN0X3RpbWUgPSBub3coKTtcbiAgICAgICAgICAgIGNhbmNlbF90YXNrID0gZmFsc2U7XG4gICAgICAgICAgICB0YXNrID0gbG9vcChub3cgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChjYW5jZWxfdGFzaykge1xuICAgICAgICAgICAgICAgICAgICBjYW5jZWxfdGFzayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0YXNrID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbnZfbWFzcyA9IE1hdGgubWluKGludl9tYXNzICsgaW52X21hc3NfcmVjb3ZlcnlfcmF0ZSwgMSk7XG4gICAgICAgICAgICAgICAgY29uc3QgY3R4ID0ge1xuICAgICAgICAgICAgICAgICAgICBpbnZfbWFzcyxcbiAgICAgICAgICAgICAgICAgICAgb3B0czogc3ByaW5nLFxuICAgICAgICAgICAgICAgICAgICBzZXR0bGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBkdDogKG5vdyAtIGxhc3RfdGltZSkgKiA2MCAvIDEwMDBcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRfdmFsdWUgPSB0aWNrX3NwcmluZyhjdHgsIGxhc3RfdmFsdWUsIHZhbHVlLCB0YXJnZXRfdmFsdWUpO1xuICAgICAgICAgICAgICAgIGxhc3RfdGltZSA9IG5vdztcbiAgICAgICAgICAgICAgICBsYXN0X3ZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgc3RvcmUuc2V0KHZhbHVlID0gbmV4dF92YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGN0eC5zZXR0bGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhc2sgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gIWN0eC5zZXR0bGVkO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bGZpbCA9PiB7XG4gICAgICAgICAgICB0YXNrLnByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuID09PSBjdXJyZW50X3Rva2VuKVxuICAgICAgICAgICAgICAgICAgICBmdWxmaWwoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3Qgc3ByaW5nID0ge1xuICAgICAgICBzZXQsXG4gICAgICAgIHVwZGF0ZTogKGZuLCBvcHRzKSA9PiBzZXQoZm4odGFyZ2V0X3ZhbHVlLCB2YWx1ZSksIG9wdHMpLFxuICAgICAgICBzdWJzY3JpYmU6IHN0b3JlLnN1YnNjcmliZSxcbiAgICAgICAgc3RpZmZuZXNzLFxuICAgICAgICBkYW1waW5nLFxuICAgICAgICBwcmVjaXNpb25cbiAgICB9O1xuICAgIHJldHVybiBzcHJpbmc7XG59XG5cbmZ1bmN0aW9uIGdldF9pbnRlcnBvbGF0b3IoYSwgYikge1xuICAgIGlmIChhID09PSBiIHx8IGEgIT09IGEpXG4gICAgICAgIHJldHVybiAoKSA9PiBhO1xuICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgYTtcbiAgICBpZiAodHlwZSAhPT0gdHlwZW9mIGIgfHwgQXJyYXkuaXNBcnJheShhKSAhPT0gQXJyYXkuaXNBcnJheShiKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbnRlcnBvbGF0ZSB2YWx1ZXMgb2YgZGlmZmVyZW50IHR5cGUnKTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYSkpIHtcbiAgICAgICAgY29uc3QgYXJyID0gYi5tYXAoKGJpLCBpKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0X2ludGVycG9sYXRvcihhW2ldLCBiaSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdCA9PiBhcnIubWFwKGZuID0+IGZuKHQpKTtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGlmICghYSB8fCAhYilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT2JqZWN0IGNhbm5vdCBiZSBudWxsJyk7XG4gICAgICAgIGlmIChpc19kYXRlKGEpICYmIGlzX2RhdGUoYikpIHtcbiAgICAgICAgICAgIGEgPSBhLmdldFRpbWUoKTtcbiAgICAgICAgICAgIGIgPSBiLmdldFRpbWUoKTtcbiAgICAgICAgICAgIGNvbnN0IGRlbHRhID0gYiAtIGE7XG4gICAgICAgICAgICByZXR1cm4gdCA9PiBuZXcgRGF0ZShhICsgdCAqIGRlbHRhKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoYik7XG4gICAgICAgIGNvbnN0IGludGVycG9sYXRvcnMgPSB7fTtcbiAgICAgICAga2V5cy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0b3JzW2tleV0gPSBnZXRfaW50ZXJwb2xhdG9yKGFba2V5XSwgYltrZXldKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgICAgICAgICAga2V5cy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBpbnRlcnBvbGF0b3JzW2tleV0odCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmICh0eXBlID09PSAnbnVtYmVyJykge1xuICAgICAgICBjb25zdCBkZWx0YSA9IGIgLSBhO1xuICAgICAgICByZXR1cm4gdCA9PiBhICsgdCAqIGRlbHRhO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBpbnRlcnBvbGF0ZSAke3R5cGV9IHZhbHVlc2ApO1xufVxuZnVuY3Rpb24gdHdlZW5lZCh2YWx1ZSwgZGVmYXVsdHMgPSB7fSkge1xuICAgIGNvbnN0IHN0b3JlID0gd3JpdGFibGUodmFsdWUpO1xuICAgIGxldCB0YXNrO1xuICAgIGxldCB0YXJnZXRfdmFsdWUgPSB2YWx1ZTtcbiAgICBmdW5jdGlvbiBzZXQobmV3X3ZhbHVlLCBvcHRzKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBzdG9yZS5zZXQodmFsdWUgPSBuZXdfdmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRhcmdldF92YWx1ZSA9IG5ld192YWx1ZTtcbiAgICAgICAgbGV0IHByZXZpb3VzX3Rhc2sgPSB0YXNrO1xuICAgICAgICBsZXQgc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICBsZXQgeyBkZWxheSA9IDAsIGR1cmF0aW9uID0gNDAwLCBlYXNpbmcgPSBsaW5lYXIsIGludGVycG9sYXRlID0gZ2V0X2ludGVycG9sYXRvciB9ID0gYXNzaWduKGFzc2lnbih7fSwgZGVmYXVsdHMpLCBvcHRzKTtcbiAgICAgICAgaWYgKGR1cmF0aW9uID09PSAwKSB7XG4gICAgICAgICAgICBpZiAocHJldmlvdXNfdGFzaykge1xuICAgICAgICAgICAgICAgIHByZXZpb3VzX3Rhc2suYWJvcnQoKTtcbiAgICAgICAgICAgICAgICBwcmV2aW91c190YXNrID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0b3JlLnNldCh2YWx1ZSA9IHRhcmdldF92YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhcnQgPSBub3coKSArIGRlbGF5O1xuICAgICAgICBsZXQgZm47XG4gICAgICAgIHRhc2sgPSBsb29wKG5vdyA9PiB7XG4gICAgICAgICAgICBpZiAobm93IDwgc3RhcnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBpZiAoIXN0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICBmbiA9IGludGVycG9sYXRlKHZhbHVlLCBuZXdfdmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZHVyYXRpb24gPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gZHVyYXRpb24odmFsdWUsIG5ld192YWx1ZSk7XG4gICAgICAgICAgICAgICAgc3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJldmlvdXNfdGFzaykge1xuICAgICAgICAgICAgICAgIHByZXZpb3VzX3Rhc2suYWJvcnQoKTtcbiAgICAgICAgICAgICAgICBwcmV2aW91c190YXNrID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGVsYXBzZWQgPSBub3cgLSBzdGFydDtcbiAgICAgICAgICAgIGlmIChlbGFwc2VkID4gZHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBzdG9yZS5zZXQodmFsdWUgPSBuZXdfdmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIHN0b3JlLnNldCh2YWx1ZSA9IGZuKGVhc2luZyhlbGFwc2VkIC8gZHVyYXRpb24pKSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0YXNrLnByb21pc2U7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHNldCxcbiAgICAgICAgdXBkYXRlOiAoZm4sIG9wdHMpID0+IHNldChmbih0YXJnZXRfdmFsdWUsIHZhbHVlKSwgb3B0cyksXG4gICAgICAgIHN1YnNjcmliZTogc3RvcmUuc3Vic2NyaWJlXG4gICAgfTtcbn1cblxuZXhwb3J0IHsgc3ByaW5nLCB0d2VlbmVkIH07XG4iLCJpbXBvcnQgVGlueUdlc3R1cmUgZnJvbSAndGlueWdlc3R1cmUnO1xuaW1wb3J0IHsgdHdlZW5lZCB9IGZyb20gJ3N2ZWx0ZS9tb3Rpb24nO1xuaW1wb3J0IHsgY3ViaWNJbk91dCB9IGZyb20gJ3N2ZWx0ZS9lYXNpbmcnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBQYW5uYWJsZShub2RlKSB7XG4gIGNvbnN0IGdlc3R1cmUgPSBuZXcgVGlueUdlc3R1cmUobm9kZSk7XG4gIGxldCBhbmltYXRpb25GcmFtZSA9IG51bGw7XG4gIGNvbnN0IHByZXZlbnREZWZhdWx0ID0gKGV2ZW50KSA9PiB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfTtcblxuICBjb25zdCBsZWZ0ID0gdHdlZW5lZCgwLCB7XG4gICAgZHVyYXRpb246IDMwMCxcbiAgICBlYXNpbmc6IGN1YmljSW5PdXQsXG4gIH0pO1xuICBjb25zdCB0b3AgPSB0d2VlbmVkKDAsIHtcbiAgICBkdXJhdGlvbjogMzAwLFxuICAgIGVhc2luZzogY3ViaWNJbk91dCxcbiAgfSk7XG5cbiAgY29uc3QgbGVmdFVuc3ViID0gbGVmdC5zdWJzY3JpYmUoKHZhbHVlKSA9PiB7XG4gICAgbm9kZS5zdHlsZS5sZWZ0ID0gdmFsdWUgKyAncHgnO1xuICB9KTtcbiAgY29uc3QgdG9wVW5zdWIgPSB0b3Auc3Vic2NyaWJlKCh2YWx1ZSkgPT4ge1xuICAgIG5vZGUuc3R5bGUudG9wID0gdmFsdWUgKyAncHgnO1xuICB9KTtcblxuICBub2RlLnN0eWxlLnRyYW5zaXRpb24gPVxuICAgIChub2RlLnN0eWxlLnRyYW5zaXRpb24gPyBub2RlLnN0eWxlLnRyYW5zaXRpb24gKyAnLCAnIDogJycpICtcbiAgICAnb3BhY2l0eSBlYXNlIC4zcyc7XG5cbiAgbm9kZS5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgcHJldmVudERlZmF1bHQsIHsgcGFzc2l2ZTogZmFsc2UgfSk7XG5cbiAgZ2VzdHVyZS5vbigncGFubW92ZScsICgpID0+IHtcbiAgICBpZiAoYW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYW5pbWF0aW9uRnJhbWUgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIGlmICghZ2VzdHVyZS5zd2lwaW5nRGlyZWN0aW9uLnN0YXJ0c1dpdGgoJ3ByZS0nKSkge1xuICAgICAgICBub2RlLnN0eWxlLm9wYWNpdHkgPSAnMC43JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUuc3R5bGUub3BhY2l0eSA9ICcxJztcbiAgICAgIH1cbiAgICAgIG5vZGUuc3R5bGUudHJhbnNmb3JtID1cbiAgICAgICAgJ3JvdGF0ZSgnICsgKGdlc3R1cmUudG91Y2hNb3ZlWCAvIDggKyBnZXN0dXJlLnRvdWNoTW92ZVkgLyA4KSArICdkZWcpJztcbiAgICAgIGxlZnQuc2V0KGdlc3R1cmUudG91Y2hNb3ZlWCwgeyBkdXJhdGlvbjogMCB9KTtcbiAgICAgIHRvcC5zZXQoZ2VzdHVyZS50b3VjaE1vdmVZLCB7IGR1cmF0aW9uOiAwIH0pO1xuICAgICAgYW5pbWF0aW9uRnJhbWUgPSBudWxsO1xuICAgIH0pO1xuICB9KTtcblxuICBnZXN0dXJlLm9uKCdwYW5lbmQnLCAoKSA9PiB7XG4gICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKGFuaW1hdGlvbkZyYW1lKTtcbiAgICBhbmltYXRpb25GcmFtZSA9IG51bGw7XG4gICAgbm9kZS5zdHlsZS50cmFuc2Zvcm0gPSBudWxsO1xuICAgIGxlZnQuc2V0KDApO1xuICAgIHRvcC5zZXQoMCk7XG4gICAgbm9kZS5zdHlsZS5vcGFjaXR5ID0gJzEnO1xuICB9KTtcblxuICByZXR1cm4ge1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBwcmV2ZW50RGVmYXVsdCwge1xuICAgICAgICBwYXNzaXZlOiBmYWxzZSxcbiAgICAgIH0pO1xuICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKGFuaW1hdGlvbkZyYW1lKTtcbiAgICAgIGxlZnRVbnN1YigpO1xuICAgICAgdG9wVW5zdWIoKTtcbiAgICAgIGdlc3R1cmUuZGVzdHJveSgpO1xuICAgIH0sXG4gIH07XG59XG4iLCJpbXBvcnQgVGlueUdlc3R1cmUgZnJvbSAndGlueWdlc3R1cmUnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBTd2lwZWFibGUobm9kZSkge1xuICBjb25zdCBnZXN0dXJlID0gbmV3IFRpbnlHZXN0dXJlKG5vZGUpO1xuICBsZXQgdGltZW91dDtcbiAgY29uc3QgcHJldmVudERlZmF1bHQgPSAoZXZlbnQpID0+IHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9O1xuXG4gIG5vZGUuc3R5bGUudHJhbnNpdGlvbiA9XG4gICAgKG5vZGUuc3R5bGUudHJhbnNpdGlvbiA/IG5vZGUuc3R5bGUudHJhbnNpdGlvbiArICcsICcgOiAnJykgK1xuICAgICd0cmFuc2Zvcm0gZWFzZSAwLjNzJztcblxuICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBwcmV2ZW50RGVmYXVsdCwgeyBwYXNzaXZlOiBmYWxzZSB9KTtcblxuICBnZXN0dXJlLm9uKCdzd2lwZXJpZ2h0JywgKCkgPT4ge1xuICAgIG5vZGUuc3R5bGUudHJhbnNmb3JtID0gJ3BlcnNwZWN0aXZlKDEwMDBweCkgdHJhbnNsYXRlM2QoMjAwMHB4LCAwLCAwKSc7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgIHNldFRpbWVvdXQoKCkgPT4gKG5vZGUuc3R5bGUudHJhbnNmb3JtID0gbnVsbCksIDEwMDApO1xuICB9KTtcbiAgZ2VzdHVyZS5vbignc3dpcGVsZWZ0JywgKCkgPT4ge1xuICAgIG5vZGUuc3R5bGUudHJhbnNmb3JtID0gJ3BlcnNwZWN0aXZlKDEwMDBweCkgdHJhbnNsYXRlM2QoLTIwMDBweCwgMCwgMCknO1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IChub2RlLnN0eWxlLnRyYW5zZm9ybSA9IG51bGwpLCAxMDAwKTtcbiAgfSk7XG4gIGdlc3R1cmUub24oJ3N3aXBldXAnLCAoKSA9PiB7XG4gICAgbm9kZS5zdHlsZS50cmFuc2Zvcm0gPSAncGVyc3BlY3RpdmUoMTAwMHB4KSB0cmFuc2xhdGUzZCgwLCAtMjAwMHB4LCAwKSc7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgIHNldFRpbWVvdXQoKCkgPT4gKG5vZGUuc3R5bGUudHJhbnNmb3JtID0gbnVsbCksIDEwMDApO1xuICB9KTtcbiAgZ2VzdHVyZS5vbignc3dpcGVkb3duJywgKCkgPT4ge1xuICAgIG5vZGUuc3R5bGUudHJhbnNmb3JtID0gJ3BlcnNwZWN0aXZlKDEwMDBweCkgdHJhbnNsYXRlM2QoMCwgMjAwMHB4LCAwKSc7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgIHNldFRpbWVvdXQoKCkgPT4gKG5vZGUuc3R5bGUudHJhbnNmb3JtID0gbnVsbCksIDEwMDApO1xuICB9KTtcblxuICByZXR1cm4ge1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBwcmV2ZW50RGVmYXVsdCwge1xuICAgICAgICBwYXNzaXZlOiBmYWxzZSxcbiAgICAgIH0pO1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgZ2VzdHVyZS5kZXN0cm95KCk7XG4gICAgfSxcbiAgfTtcbn1cbiIsImltcG9ydCBUaW55R2VzdHVyZSBmcm9tICd0aW55Z2VzdHVyZSc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFRhcHBhYmxlKG5vZGUsIG9wdGlvbnMpIHtcbiAgY29uc3QgZ2VzdHVyZSA9IG5ldyBUaW55R2VzdHVyZShub2RlKTtcbiAgbGV0IHRhcFRpbWVvdXQ7XG4gIGxldCBwcmVzc1RpbWVvdXQ7XG4gIGxldCBwcmVzc2VkID0gZmFsc2U7XG5cbiAgbm9kZS5zdHlsZS50cmFuc2l0aW9uID1cbiAgICAobm9kZS5zdHlsZS50cmFuc2l0aW9uID8gbm9kZS5zdHlsZS50cmFuc2l0aW9uICsgJywgJyA6ICcnKSArXG4gICAgJ2JhY2tncm91bmQtY29sb3IgZWFzZSAwLjNzLCBjb2xvciBlYXNlIDAuM3MnO1xuXG4gIGdlc3R1cmUub24oJ3RhcCcsICgpID0+IHtcbiAgICBpZiAoIXByZXNzZWQpIHtcbiAgICAgIG5vZGUuc3R5bGUudHJhbnNmb3JtID0gJ3BlcnNwZWN0aXZlKDEwMDBweCkgdHJhbnNsYXRlM2QoMCwgMCwgMTAwcHgpJztcbiAgICAgIGNsZWFyVGltZW91dCh0YXBUaW1lb3V0KTtcbiAgICAgIHRhcFRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IChub2RlLnN0eWxlLnRyYW5zZm9ybSA9IG51bGwpLCAzMDApO1xuICAgIH1cbiAgICBwcmVzc2VkID0gZmFsc2U7XG4gIH0pO1xuICBnZXN0dXJlLm9uKCdkb3VibGV0YXAnLCAoKSA9PiB7XG4gICAgbm9kZS5zdHlsZS50cmFuc2Zvcm0gPSAncGVyc3BlY3RpdmUoMTAwMHB4KSB0cmFuc2xhdGUzZCgwLCAwLCA0MDBweCknO1xuICAgIGNsZWFyVGltZW91dCh0YXBUaW1lb3V0KTtcbiAgICB0YXBUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiAobm9kZS5zdHlsZS50cmFuc2Zvcm0gPSBudWxsKSwgMzAwKTtcbiAgfSk7XG4gIGdlc3R1cmUub24oJ2xvbmdwcmVzcycsICgpID0+IHtcbiAgICBwcmVzc2VkID0gdHJ1ZTtcbiAgICBub2RlLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IG9wdGlvbnMuYmdDb2xvcjtcbiAgICBub2RlLnN0eWxlLmNvbG9yID0gb3B0aW9ucy5jb2xvcjtcbiAgICBjbGVhclRpbWVvdXQocHJlc3NUaW1lb3V0KTtcbiAgfSk7XG5cbiAgZ2VzdHVyZS5vbigncGFuZW5kJywgKCkgPT4ge1xuICAgIHByZXNzVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgbm9kZS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBudWxsO1xuICAgICAgbm9kZS5zdHlsZS5jb2xvciA9IG51bGw7XG4gICAgfSwgMzAwKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHtcbiAgICBkZXN0cm95KCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRhcFRpbWVvdXQpO1xuICAgICAgY2xlYXJUaW1lb3V0KHByZXNzVGltZW91dCk7XG4gICAgICBnZXN0dXJlLmRlc3Ryb3koKTtcbiAgICB9LFxuICB9O1xufVxuIiwiPGRpdiBjbGFzcz1cImNvbnRhaW5lclwiPlxuICA8TXlDb21wb25lbnRcbiAgICB1c2U9e1tcbiAgICAgIFBhbm5hYmxlLFxuICAgICAgU3dpcGVhYmxlLFxuICAgICAgW1xuICAgICAgICBUYXBwYWJsZSxcbiAgICAgICAge1xuICAgICAgICAgIGJnQ29sb3I6ICd2YXIoLS1tZGMtdGhlbWUtc2Vjb25kYXJ5KScsXG4gICAgICAgICAgY29sb3I6ICd2YXIoLS1tZGMtdGhlbWUtb24tc2Vjb25kYXJ5KScsXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgIF19XG4gID5cbiAgICBTd2lwZSBtZS48YnIgLz5cbiAgICBUYXAgbWUuPGJyIC8+XG4gICAgUHJlc3MgbWUuXG4gIDwvTXlDb21wb25lbnQ+XG48L2Rpdj5cblxuPHNjcmlwdD5cbiAgaW1wb3J0IE15Q29tcG9uZW50IGZyb20gJy4vX1VzZUFjdGlvbnNDb21wb25lbnQuc3ZlbHRlJztcbiAgaW1wb3J0IFBhbm5hYmxlIGZyb20gJy4vX1VzZUFjdGlvbnNQYW5uYWJsZS5qcyc7XG4gIGltcG9ydCBTd2lwZWFibGUgZnJvbSAnLi9fVXNlQWN0aW9uc1N3aXBlYWJsZS5qcyc7XG4gIGltcG9ydCBUYXBwYWJsZSBmcm9tICcuL19Vc2VBY3Rpb25zVGFwcGFibGUuanMnO1xuPC9zY3JpcHQ+XG5cbjxzdHlsZT5cbiAgLmNvbnRhaW5lciB7XG4gICAgaGVpZ2h0OiA4MHZoO1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgYm9yZGVyOiAxcHggc29saWQgY3VycmVudGNvbG9yO1xuICAgIG92ZXJmbG93OiBoaWRkZW47XG4gIH1cbjwvc3R5bGU+XG4iLCI8c3ZlbHRlOmhlYWQ+XG4gIDx0aXRsZT5Db21tb24gLSBTTVVJPC90aXRsZT5cbjwvc3ZlbHRlOmhlYWQ+XG5cbjxzZWN0aW9uPlxuICA8aDI+Q29tbW9uPC9oMj5cbiAgPHA+QSBjb21tb24gTGFiZWwgYW5kIEljb24sIGhlbHBlciB1dGlsaXRpZXMsIGFuZCBlbGVtZW50YWwgY29tcG9uZW50cy48L3A+XG5cbiAgPHByZSBjbGFzcz1cImRlbW8tc3BhY2VkXCI+bnBtIGkgLUQgQHNtdWkvY29tbW9uPC9wcmU+XG5cbiAgPERlbW8gY29tcG9uZW50PXtDb21tb25MYWJlbEljb259IGZpbGU9XCJjb21tb24vX0NvbW1vbkxhYmVsSWNvbi5zdmVsdGVcIj5cbiAgICBDb21tb24gTGFiZWwgYW5kIEljb25cbiAgICA8c3ZlbHRlOmZyYWdtZW50IHNsb3Q9XCJzdWJ0aXRsZVwiPlxuICAgICAgVGhlIGNvbW1vbiBsYWJlbCBhbmQgaWNvbiBhcmUgYWxzbyBleHBvcnRlZCBmcm9tIGVhY2ggcGFja2FnZSB0aGF0IHVzZXNcbiAgICAgIHRoZW0uXG4gICAgPC9zdmVsdGU6ZnJhZ21lbnQ+XG4gIDwvRGVtbz5cblxuICA8aDQ+Q29tbW9uIEZlYXR1cmVzIGFuZCBVc2UgUGF0dGVybnM8L2g0PlxuXG4gIDxEZW1vIGNvbXBvbmVudD17VGFyZ2V0aW5nQ2xhc3Nlc30gZmlsZT1cImNvbW1vbi9fVGFyZ2V0aW5nQ2xhc3Nlcy5zdmVsdGVcIj5cbiAgICBUYXJnZXRpbmcgQ2xhc3Nlc1xuICAgIDxzdmVsdGU6ZnJhZ21lbnQgc2xvdD1cInN1YnRpdGxlXCI+XG4gICAgICBCZWNhdXNlIFN2ZWx0ZSBsaW1pdHMgeW91ciBDU1MgdG8gPGVtPm9ubHk8L2VtPiB0aGUgY3VycmVudCBjb21wb25lbnQsIHlvdVxuICAgICAgbmVlZCB0byB1c2UgYSBcIjpnbG9iYWxcIiBzZWxlY3RvciB0byB0YXJnZXQgU01VSSBlbGVtZW50cy5cbiAgICA8L3N2ZWx0ZTpmcmFnbWVudD5cbiAgPC9EZW1vPlxuXG4gIDxEZW1vIGNvbXBvbmVudD17RXZlbnRzQW5kTW9kaWZpZXJzfSBmaWxlPVwiY29tbW9uL19FdmVudHNBbmRNb2RpZmllcnMuc3ZlbHRlXCI+XG4gICAgRXZlbnRzIGFuZCBNb2RpZmllcnNcbiAgICA8c3ZlbHRlOmZyYWdtZW50IHNsb3Q9XCJzdWJ0aXRsZVwiPlxuICAgICAgU01VSSBzdXBwb3J0cyBsaXN0ZW5pbmcgdG8gPHN0cm9uZz5hbGw8L3N0cm9uZz4gZXZlbnRzLiBZb3UgY2FuIGFsc28gdXNlIG1vZGlmaWVyc1xuICAgICAgd2l0aCB0aGUgXCIkXCIgc3ludGF4LlxuICAgIDwvc3ZlbHRlOmZyYWdtZW50PlxuICA8L0RlbW8+XG5cbiAgPERlbW9cbiAgICBjb21wb25lbnQ9e0VsZW1lbnRhbENvbXBvbmVudHN9XG4gICAgZmlsZT1cImNvbW1vbi9fRWxlbWVudGFsQ29tcG9uZW50cy5zdmVsdGVcIlxuICA+XG4gICAgRWxlbWVudGFsIENvbXBvbmVudHNcbiAgICA8c3ZlbHRlOmZyYWdtZW50IHNsb3Q9XCJzdWJ0aXRsZVwiPlxuICAgICAgTWFueSBTTVVJIGNvbXBvbmVudHMgbGV0IHlvdSBjdXN0b21pemUgd2hpY2ggRE9NIGVsZW1lbnQgaXMgdXNlZCB0byByZW5kZXJcbiAgICAgIHRoZW0uXG4gICAgPC9zdmVsdGU6ZnJhZ21lbnQ+XG4gIDwvRGVtbz5cblxuICA8aDQ+SGVscGVyIFV0aWxpdGllczwvaDQ+XG5cbiAgPERlbW9cbiAgICBjb21wb25lbnQ9e0NsYXNzQWRkZXJCdWlsZGVyfVxuICAgIGZpbGVzPXtbXG4gICAgICAnY29tbW9uL19DbGFzc0FkZGVyQnVpbGRlci5zdmVsdGUnLFxuICAgICAgJ2NvbW1vbi9fQ2xhc3NBZGRlckJ1aWxkZXJDb21wb25lbnQuanMnLFxuICAgIF19XG4gID5cbiAgICBDbGFzcyBBZGRlciBCdWlsZGVyXG4gICAgPHN2ZWx0ZTpmcmFnbWVudCBzbG90PVwic3VidGl0bGVcIj5cbiAgICAgIFVzZSB0aGlzIHRvIGJ1aWxkIGEgQ2xhc3NBZGRlciBjb21wb25lbnQuIENsYXNzQWRkZXIgY29tcG9uZW50cyBhcmUgdXNlZnVsXG4gICAgICBmb3IgcmVkdWNpbmcgdGhlIHNpemUgb2YgeW91ciBidW5kbGUuIElmIHlvdSBoYXZlIHRvbnMgb2Ygc2ltcGxlXG4gICAgICBjb21wb25lbnRzIHRoYXQganVzdCBuZWVkIHRvIGFkZCBjbGFzc2VzL3Byb3BzIG9yIHNldCBhIGNvbnRleHQsIHVzaW5nXG4gICAgICBDbGFzc0FkZGVyIGNvbXBvbmVudHMgbWVhbnMgdGhlcmUncyBvbmx5IG9uZSBcImJpZ1wiIFN2ZWx0ZSBjb21wb25lbnQgaW5cbiAgICAgIHlvdXIgYnVuZGxlIGZvciBhbGwgb2YgdGhlc2UgbWFueSB0aW55IGNvbXBvbmVudHMuXG4gICAgPC9zdmVsdGU6ZnJhZ21lbnQ+XG4gIDwvRGVtbz5cblxuICA8RGVtbyBjb21wb25lbnQ9e0NsYXNzTWFwfSBmaWxlPVwiY29tbW9uL19DbGFzc01hcC5zdmVsdGVcIj5cbiAgICBDbGFzcyBNYXBcbiAgICA8c3ZlbHRlOmZyYWdtZW50IHNsb3Q9XCJzdWJ0aXRsZVwiPlxuICAgICAgQnVpbGQgYSBjbGFzcyBzdHJpbmcgZnJvbSBhIG1hcCBvZiBjbGFzcyBuYW1lcyB0byBjb25kaXRpb25zLiBUaGlzIGlzXG4gICAgICB1c2VmdWwgd2hlbiB5b3UgbmVlZCB0byBhZGQgY2xhc3NlcyB0byBhIGNvbXBvbmVudCwgc2luY2UgU3ZlbHRlJ3NcbiAgICAgIFwiY2xhc3M6XCIgZGlyZWN0aXZlcyBkb24ndCB3b3JrIG9uIGNvbXBvbmVudHMuIChJdCdzIGFsc28gdXNlZnVsIGZvclxuICAgICAgYWN0aW9ucyB0aGF0IHRha2UgPGNvZGU+YWRkQ2xhc3M8L2NvZGU+IGFuZCA8Y29kZT5yZW1vdmVDbGFzczwvY29kZT4gZnVuY3Rpb25zLilcbiAgICA8L3N2ZWx0ZTpmcmFnbWVudD5cbiAgPC9EZW1vPlxuXG4gIDxEZW1vIGNvbXBvbmVudD17RGlzcGF0Y2h9IGZpbGU9XCJjb21tb24vX0Rpc3BhdGNoLnN2ZWx0ZVwiPlxuICAgIERpc3BhdGNoXG4gICAgPHN2ZWx0ZTpmcmFnbWVudCBzbG90PVwic3VidGl0bGVcIj5cbiAgICAgIERpc3BhdGNoIGEgY3VzdG9tIGV2ZW50LiBUaGlzIGRpZmZlcnMgZnJvbSBTdmVsdGUncyBjb21wb25lbnQgZXZlbnRcbiAgICAgIHN5c3RlbSwgYmVjYXVzZSB0aGVzZSBldmVudHMgcmVxdWlyZSBhIERPTSBlbGVtZW50IGFzIGEgdGFyZ2V0LCBjYW4gYnViYmxlXG4gICAgICAoYW5kIGRvIGJ5IGRlZmF1bHQpLCBhbmQgYXJlIGNhbmNlbGFibGUgd2l0aCA8Y29kZVxuICAgICAgICA+ZXZlbnQucHJldmVudERlZmF1bHQoKTwvY29kZVxuICAgICAgPi4gQWxsIFNNVUkvTURDIGV2ZW50cyBhcmUgZGlzcGF0Y2hlZCB3aXRoIHRoaXMgaW5zdGVhZCBvZiBTdmVsdGUnc1xuICAgICAgPGNvZGU+Y3JlYXRlRXZlbnREaXNwYXRjaGVyPC9jb2RlPi5cbiAgICA8L3N2ZWx0ZTpmcmFnbWVudD5cbiAgPC9EZW1vPlxuXG4gIDxEZW1vXG4gICAgY29tcG9uZW50PXtFeGNsdWRlQW5kUHJlZml4RmlsdGVyfVxuICAgIGZpbGVzPXtbXG4gICAgICAnY29tbW9uL19FeGNsdWRlQW5kUHJlZml4RmlsdGVyLnN2ZWx0ZScsXG4gICAgICAnY29tbW9uL19FeGNsdWRlQW5kUHJlZml4RmlsdGVyQ29tcG9uZW50LnN2ZWx0ZScsXG4gICAgXX1cbiAgPlxuICAgIEV4Y2x1ZGUgYW5kIFByZWZpeCBGaWx0ZXJcbiAgICA8c3ZlbHRlOmZyYWdtZW50IHNsb3Q9XCJzdWJ0aXRsZVwiPlxuICAgICAgRXhjbHVkZSBkaWZmZXJzIGZyb20gbm9ybWFsIDxjb2RlPm9taXQ8L2NvZGU+IGZ1bmN0aW9ucyBieSBhbHNvIGV4Y2x1ZGluZyBhbGxcbiAgICAgIHByb3BlcnRpZXMgdGhhdCBiZWdpbiB3aXRoIGEgZ2l2ZW4gc3RyaW5nIGlmIHRoYXQgc3RyaW5nIGVuZHMgd2l0aCBcIiRcIi4gUHJlZml4XG4gICAgICBGaWx0ZXIgZmlsdGVycyBhbiBvYmplY3QgZm9yIG9ubHkgcHJvcGVydGllcyB3aXRoIGEgY2VydGFpbiBwcmVmaXguIFRoZXkgYXJlXG4gICAgICB1c3VhbGx5IHVzZWQgdG9nZXRoZXIgdG8gYWxsb3cgcHJvcHMgdG8gYmUgZ2l2ZW4gdG8gbXVsdGlwbGUgZWxlbWVudHMgd2l0aGluXG4gICAgICBhIGNvbXBvbmVudC5cbiAgICA8L3N2ZWx0ZTpmcmFnbWVudD5cbiAgPC9EZW1vPlxuXG4gIDxEZW1vXG4gICAgY29tcG9uZW50PXtGb3J3YXJkRXZlbnRzQnVpbGRlcn1cbiAgICBmaWxlcz17W1xuICAgICAgJ2NvbW1vbi9fRm9yd2FyZEV2ZW50c0J1aWxkZXIuc3ZlbHRlJyxcbiAgICAgICdjb21tb24vX0ZvcndhcmRFdmVudHNCdWlsZGVyQ29tcG9uZW50LnN2ZWx0ZScsXG4gICAgXX1cbiAgPlxuICAgIEZvcndhcmQgRXZlbnRzIEJ1aWxkZXJcbiAgICA8c3ZlbHRlOmZyYWdtZW50IHNsb3Q9XCJzdWJ0aXRsZVwiPlxuICAgICAgQnVpbGQgYW4gYWN0aW9uIHRvIGFsbG93ICoqYWxsKiogZXZlbnRzIHRvIGJlIGZvcndhcmRlZCBmcm9tIGEgU3ZlbHRlXG4gICAgICBjb21wb25lbnQsIHdpdGggc3VwcG9ydCBmb3IgZXZlbnQgbW9kaWZpZXJzIHVzaW5nIHRoZSBcIiRcIiBzeW50YXguXG4gICAgICA8dWw+XG4gICAgICAgIDxsaT5cbiAgICAgICAgICBUaGlzIGlzIGVzcGVjaWFsbHkgdXNlZnVsIGZvciBVSSBsaWJyYXJ5IGNvbXBvbmVudHMsIGFzIGl0IGlzXG4gICAgICAgICAgZ2VuZXJhbGx5IHVua25vd24gd2hpY2ggZXZlbnRzIHdpbGwgYmUgcmVxdWlyZWQgZnJvbSB0aGVtIGZvciBhbGxcbiAgICAgICAgICBkZXNpcmVkIHVzZSBjYXNlcy4gRm9yIGV4YW1wbGUsIGlmIGEgQnV0dG9uIGNvbXBvbmVudCBvbmx5IGZvcndhcmRzIGEgPGNvZGVcbiAgICAgICAgICAgID5jbGljazwvY29kZVxuICAgICAgICAgID5cbiAgICAgICAgICBldmVudCwgdGhlbiBubyB1c2UgY2FzZSB0aGF0IHJlcXVpcmVzIHRoZSA8Y29kZT5tb3VzZW92ZXI8L2NvZGU+IG9yXG4gICAgICAgICAgdGhlXG4gICAgICAgICAgPGNvZGU+a2V5cHJlc3M8L2NvZGU+XG4gICAgICAgICAgZXZlbnQgY2FuIGJlIHVzZWQgd2l0aCBpdC5cbiAgICAgICAgPC9saT5cbiAgICAgICAgPGxpPlxuICAgICAgICAgIEluIGFkZGl0aW9uLCBhIGNvbXBvbmVudCB0aGF0IHVzZXMgU3ZlbHRlJ3MgYnVpbHQgaW4gZXZlbnQgZm9yd2FyZGluZ1xuICAgICAgICAgIHN5c3RlbSBjYW5ub3QgYWxsb3cgZXZlbnQgbGlzdGVuZXJzIG9uIHRoZSBcImNhcHR1cmVcIiBwaGFzZSBvZiB0aGVcbiAgICAgICAgICBldmVudCBsaWZlY3ljbGUuIEl0IGFsc28gY2Fubm90IGFsbG93IGV2ZW50cyB0byBiZSBjYW5jZWxhYmxlIHdpdGggdGhlXG4gICAgICAgICAgYnJvd3NlcidzIGJ1aWx0IGluXG4gICAgICAgICAgPGNvZGU+cHJldmVudERlZmF1bHQ8L2NvZGU+XG4gICAgICAgICAgZnVuY3Rpb24uIEluIGZhY3QsIHRoZSBvbmUgYmlnIGFkdmFudGFnZSB0byBTdmVsdGUncyBldmVudCBzeXN0ZW0sIHRoZVxuICAgICAgICAgIGZhY3QgdGhhdCB5b3UgZG9uJ3QgbmVlZCBhbiBlbGVtZW50IGFzIGFuIGV2ZW50IHRhcmdldCwgZG9lc24ndCBldmVuIGFwcGx5XG4gICAgICAgICAgdG8gVUkgbGlicmFyeSBjb21wb25lbnRzLlxuICAgICAgICA8L2xpPlxuICAgICAgPC91bD5cbiAgICA8L3N2ZWx0ZTpmcmFnbWVudD5cbiAgPC9EZW1vPlxuXG4gIDxEZW1vXG4gICAgY29tcG9uZW50PXtVc2VBY3Rpb25zfVxuICAgIGZpbGVzPXtbXG4gICAgICAnY29tbW9uL19Vc2VBY3Rpb25zLnN2ZWx0ZScsXG4gICAgICAnY29tbW9uL19Vc2VBY3Rpb25zQ29tcG9uZW50LnN2ZWx0ZScsXG4gICAgICAnY29tbW9uL19Vc2VBY3Rpb25zUGFubmFibGUuanMnLFxuICAgICAgJ2NvbW1vbi9fVXNlQWN0aW9uc1N3aXBlYWJsZS5qcycsXG4gICAgICAnY29tbW9uL19Vc2VBY3Rpb25zVGFwcGFibGUuanMnLFxuICAgIF19XG4gID5cbiAgICBVc2UgQWN0aW9uc1xuICAgIDxzdmVsdGU6ZnJhZ21lbnQgc2xvdD1cInN1YnRpdGxlXCI+XG4gICAgICBBbiBhY3Rpb24gdGhhdCB0YWtlcyBhY3Rpb25zIGFuZCBydW5zIHRoZW0gb24gdGhlIGVsZW1lbnQuIFVzZWQgdG8gYWxsb3dcbiAgICAgIGFjdGlvbnMgb24gY29tcG9uZW50cywgYW5kIGZvcndhcmQgYWN0aW9ucyBmcm9tIG9uZSBjb21wb25lbnQgdG8gYW5vdGhlcixcbiAgICAgIHVudGlsIHRoZSB1bHRpbWF0ZSBjb21wb25lbnQgZmluYWxseSByZW5kZXJzIHRoZSBET00gZWxlbWVudC5cbiAgICA8L3N2ZWx0ZTpmcmFnbWVudD5cbiAgPC9EZW1vPlxuPC9zZWN0aW9uPlxuXG48c2NyaXB0PlxuICBpbXBvcnQgRGVtbyBmcm9tICcuLi8uLi8uLi9jb21wb25lbnRzL0RlbW8uc3ZlbHRlJztcbiAgaW1wb3J0IENvbW1vbkxhYmVsSWNvbiBmcm9tICcuL19Db21tb25MYWJlbEljb24uc3ZlbHRlJztcbiAgaW1wb3J0IFRhcmdldGluZ0NsYXNzZXMgZnJvbSAnLi9fVGFyZ2V0aW5nQ2xhc3Nlcy5zdmVsdGUnO1xuICBpbXBvcnQgRXZlbnRzQW5kTW9kaWZpZXJzIGZyb20gJy4vX0V2ZW50c0FuZE1vZGlmaWVycy5zdmVsdGUnO1xuICBpbXBvcnQgRWxlbWVudGFsQ29tcG9uZW50cyBmcm9tICcuL19FbGVtZW50YWxDb21wb25lbnRzLnN2ZWx0ZSc7XG4gIGltcG9ydCBDbGFzc0FkZGVyQnVpbGRlciBmcm9tICcuL19DbGFzc0FkZGVyQnVpbGRlci5zdmVsdGUnO1xuICBpbXBvcnQgQ2xhc3NNYXAgZnJvbSAnLi9fQ2xhc3NNYXAuc3ZlbHRlJztcbiAgaW1wb3J0IERpc3BhdGNoIGZyb20gJy4vX0Rpc3BhdGNoLnN2ZWx0ZSc7XG4gIGltcG9ydCBFeGNsdWRlQW5kUHJlZml4RmlsdGVyIGZyb20gJy4vX0V4Y2x1ZGVBbmRQcmVmaXhGaWx0ZXIuc3ZlbHRlJztcbiAgaW1wb3J0IEZvcndhcmRFdmVudHNCdWlsZGVyIGZyb20gJy4vX0ZvcndhcmRFdmVudHNCdWlsZGVyLnN2ZWx0ZSc7XG4gIGltcG9ydCBVc2VBY3Rpb25zIGZyb20gJy4vX1VzZUFjdGlvbnMuc3ZlbHRlJztcbjwvc2NyaXB0PlxuIl0sIm5hbWVzIjpbImxpbmVhciJdLCJtYXBwaW5n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QU0sQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ3hELEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQSxFQUFFLE9BQU8sTUFBTSxDQUFDO0FBQ2hCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7ZUNDN0IsZUFBZTs7Ozs7Ozs7Ozs7OztlQVVmLGdCQUFnQjs7Ozs7Ozs7Ozs7OztlQVFoQixrQkFBa0I7Ozs7Ozs7Ozs7Ozs7ZUFTdEIsbUJBQW1COzs7Ozs7Ozs7Ozs7O2VBYW5CLGlCQUFpQjs7S0FFMUIsa0NBQWtDO0tBQ2xDLHVDQUF1Qzs7Ozs7Ozs7Ozs7OztlQWExQixRQUFROzs7Ozs7Ozs7Ozs7O2VBVVIsUUFBUTs7Ozs7Ozs7Ozs7OztlQWFaLHNCQUFzQjs7S0FFL0IsdUNBQXVDO0tBQ3ZDLGdEQUFnRDs7Ozs7Ozs7Ozs7OztlQWN2QyxvQkFBb0I7O0tBRTdCLHFDQUFxQztLQUNyQyw4Q0FBOEM7Ozs7Ozs7Ozs7Ozs7ZUFrQ3JDLFVBQVU7O0tBRW5CLDJCQUEyQjtLQUMzQixvQ0FBb0M7S0FDcEMsK0JBQStCO0tBQy9CLGdDQUFnQztLQUNoQywrQkFBK0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsifQ==
